module.exports = [
"[project]/node_modules/@remotion/studio-shared/dist/ansi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stripAnsi = void 0;
exports.splitAnsi = splitAnsi;
const ansiRegex = ()=>{
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))'
    ].join('|');
    return new RegExp(pattern, 'g');
};
function splitAnsi(str) {
    const parts = str.match(ansiRegex());
    if (!parts) return [
        str
    ];
    const result = [];
    let offset = 0;
    let ptr = 0;
    for(let i = 0; i < parts.length; i++){
        offset = str.indexOf(parts[i], offset);
        if (offset === -1) throw new Error('Could not split string');
        if (ptr !== offset) result.push(str.slice(ptr, offset));
        if (ptr === offset && result.length) {
            result[result.length - 1] += parts[i];
        } else {
            if (offset === 0) result.push('');
            result.push(parts[i]);
        }
        ptr = offset + parts[i].length;
    }
    result.push(str.slice(ptr));
    return result;
}
const stripAnsi = (str)=>{
    if (typeof str !== 'string') {
        throw new TypeError(`Expected a \`string\`, got \`${typeof str}\``);
    }
    return str.replace(ansiRegex(), '');
};
exports.stripAnsi = stripAnsi;
}),
"[project]/node_modules/@remotion/studio-shared/dist/default-buffer-state-delay-in-milliseconds.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS = void 0;
exports.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS = 300;
}),
"[project]/node_modules/@remotion/studio-shared/dist/format-bytes.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatBytes = void 0;
const BYTE_UNITS = [
    'B',
    'kB',
    'MB',
    'GB',
    'TB',
    'PB',
    'EB',
    'ZB',
    'YB'
];
const BIBYTE_UNITS = [
    'B',
    'kiB',
    'MiB',
    'GiB',
    'TiB',
    'PiB',
    'EiB',
    'ZiB',
    'YiB'
];
const BIT_UNITS = [
    'b',
    'kbit',
    'Mbit',
    'Gbit',
    'Tbit',
    'Pbit',
    'Ebit',
    'Zbit',
    'Ybit'
];
const BIBIT_UNITS = [
    'b',
    'kibit',
    'Mibit',
    'Gibit',
    'Tibit',
    'Pibit',
    'Eibit',
    'Zibit',
    'Yibit'
];
/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/ const toLocaleString = (number, locale, options)=>{
    if (typeof locale === 'string' || Array.isArray(locale)) {
        return number.toLocaleString(locale, options);
    }
    if (locale === true || options !== undefined) {
        return number.toLocaleString(undefined, options);
    }
    return String(number);
};
const formatBytes = (number, options = {
    locale: 'en-US',
    signed: false,
    maximumFractionDigits: 1
})=>{
    if (!Number.isFinite(number)) {
        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
    }
    options = {
        bits: false,
        binary: false,
        ...options
    };
    const UNITS = options.bits ? options.binary ? BIBIT_UNITS : BIT_UNITS : options.binary ? BIBYTE_UNITS : BYTE_UNITS;
    if (options.signed && number === 0) {
        return `0 $ {
            UNITS[0]
        }`;
    }
    const isNegative = number < 0;
    const prefix = isNegative ? '-' : options.signed ? '+' : '';
    if (isNegative) {
        number = -number;
    }
    let localeOptions;
    if (options.minimumFractionDigits !== undefined) {
        localeOptions = {
            minimumFractionDigits: options.minimumFractionDigits
        };
    }
    if (options.maximumFractionDigits !== undefined) {
        localeOptions = {
            maximumFractionDigits: options.maximumFractionDigits,
            ...localeOptions
        };
    }
    if (number < 1) {
        const numString = toLocaleString(number, options.locale, localeOptions);
        return prefix + numString + ' ' + UNITS[0];
    }
    const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
    number /= (options.binary ? 1024 : 1000) ** exponent;
    const numberString = toLocaleString(Number(number), options.locale, localeOptions);
    const unit = UNITS[exponent];
    return prefix + numberString + ' ' + unit;
};
exports.formatBytes = formatBytes;
}),
"[project]/node_modules/@remotion/studio-shared/dist/get-default-out-name.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultOutLocation = void 0;
const getDefaultOutLocation = ({ compositionName, defaultExtension, type, compositionDefaultOutName, clientSideRender })=>{
    const nameToUse = compositionDefaultOutName !== null && compositionDefaultOutName !== void 0 ? compositionDefaultOutName : compositionName;
    if (type === 'sequence') {
        if (clientSideRender) {
            return nameToUse;
        }
        return `out/${nameToUse}`;
    }
    if (clientSideRender) {
        return `${nameToUse}.${defaultExtension}`;
    }
    return `out/${nameToUse}.${defaultExtension}`;
};
exports.getDefaultOutLocation = getDefaultOutLocation;
}),
"[project]/node_modules/@remotion/studio-shared/dist/get-location-from-build-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLocationFromBuildError = void 0;
const no_react_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
const getLocationFromBuildError = (err)=>{
    var _a;
    if (!err.stack) {
        return null;
    }
    if (!err.stack.startsWith('Error: Module build failed') && !err.stack.startsWith('Error: Cannot find module')) {
        return null;
    }
    const split = err.stack.split('\n');
    return (_a = split.map((s)=>{
        if (s.startsWith('Error')) {
            return null;
        }
        const matchWebpackOrEsbuild = s.match(/(.*):([0-9]+):([0-9]+): (.*)/);
        if (matchWebpackOrEsbuild) {
            return {
                fileName: matchWebpackOrEsbuild[1],
                lineNumber: Number(matchWebpackOrEsbuild[2]),
                columnNumber: Number(matchWebpackOrEsbuild[3]),
                message: matchWebpackOrEsbuild[4]
            };
        }
        const matchMissingModule = s.match(/\s+at(.*)\s\((.*)\)/);
        if (!matchMissingModule) {
            return null;
        }
        if (s.includes('webpackMissingModule')) {
            return null;
        }
        const [, filename] = matchMissingModule;
        return {
            columnNumber: 0,
            lineNumber: 1,
            message: split[0],
            fileName: filename.trim()
        };
    }).filter(no_react_1.NoReactInternals.truthy)[0]) !== null && _a !== void 0 ? _a : null;
};
exports.getLocationFromBuildError = getLocationFromBuildError;
}),
"[project]/node_modules/@remotion/studio-shared/dist/get-project-name.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getProjectName = void 0;
const getProjectName = ({ gitSource, resolvedRemotionRoot, basename })=>{
    // Directory name
    if (!gitSource) {
        return basename(resolvedRemotionRoot);
    }
    // Subfolder name of a Git repo, e.g `example`
    if (gitSource.relativeFromGitRoot.trim()) {
        return basename(gitSource.relativeFromGitRoot.trim());
    }
    // Name of the repo
    return gitSource.name;
};
exports.getProjectName = getProjectName;
}),
"[project]/node_modules/@remotion/studio-shared/dist/hot-middleware.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hotMiddlewareOptions = void 0;
exports.hotMiddlewareOptions = {
    path: '/__webpack_hmr',
    timeout: 20 * 1000,
    reload: true,
    warn: true,
    heartbeat: 10 * 1000
};
}),
"[project]/node_modules/@remotion/studio-shared/dist/max-timeline-tracks.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_TIMELINE_TRACKS = void 0;
exports.DEFAULT_TIMELINE_TRACKS = 90;
}),
"[project]/node_modules/@remotion/studio-shared/dist/package-info.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.apiDocs = exports.installableMap = exports.descriptions = exports.packages = void 0;
exports.packages = [
    'svg-3d-engine',
    'ai-improvements',
    'animation-utils',
    'animated-emoji',
    'astro-example',
    'babel-loader',
    'bugs',
    'bundler',
    'cli',
    'cloudrun',
    'compositor-darwin-arm64',
    'compositor-darwin-x64',
    'compositor-linux-arm64-gnu',
    'compositor-linux-arm64-musl',
    'compositor-linux-x64-gnu',
    'compositor-linux-x64-musl',
    'compositor-win32-x64-msvc',
    'core',
    'create-video',
    'discord-poster',
    'docusaurus-plugin',
    'docs',
    'enable-scss',
    'eslint-config',
    'eslint-config-flat',
    'eslint-config-internal',
    'eslint-plugin',
    'example-without-zod',
    'example',
    'fonts',
    'gif',
    'google-fonts',
    'install-whisper-cpp',
    'it-tests',
    'react18-tests',
    'lambda-go-example',
    'lambda-go',
    'lambda-php',
    'lambda-ruby',
    'lambda-python',
    'lambda',
    'lambda-client',
    'layout-utils',
    'rounded-text-box',
    'licensing',
    'lottie',
    'mcp',
    'media-utils',
    'motion-blur',
    'noise',
    'paths',
    'player-example',
    'player',
    'preload',
    'renderer',
    'rive',
    'shapes',
    'skia',
    'promo-pages',
    'streaming',
    'serverless',
    'serverless-client',
    'studio-server',
    'studio-shared',
    'studio',
    'tailwind',
    'tailwind-v4',
    'test-utils',
    'three',
    'transitions',
    'media-parser',
    'zod-types',
    'webcodecs',
    'convert',
    'captions',
    'openai-whisper',
    'compositor',
    'example-videos',
    'whisper-web',
    'media',
    'web-renderer',
    'design'
];
exports.descriptions = {
    compositor: 'Rust binary for Remotion',
    player: 'React component for embedding a Remotion preview into your app',
    cloudrun: 'Render Remotion videos on Google Cloud Run',
    renderer: 'Render Remotion videos using Node.js or Bun',
    cli: 'Control Remotion features using the `npx remotion` command',
    core: 'Make videos programmatically',
    lambda: 'Render Remotion videos on AWS Lambda',
    bundler: 'Bundle Remotion compositions using Webpack',
    'studio-server': 'Run a Remotion Studio with a server backend',
    'install-whisper-cpp': 'Helpers for installing and using Whisper.cpp',
    'whisper-web': 'Helpers for using Whisper.cpp in browser using WASM',
    'google-fonts': 'Use Google Fonts in Remotion',
    mcp: "Remotion's Model Context Protocol",
    'media-utils': 'Utilities for working with media files',
    lottie: 'Include Lottie animations in Remotion',
    licensing: 'Manage your Remotion.pro license',
    'layout-utils': 'Utilities for working with layouts',
    'rounded-text-box': 'Create a TikTok-like multiline text box SVG path with rounded corners',
    noise: 'Noise generation functions',
    'motion-blur': 'Motion blur effect for Remotion',
    preload: 'Preloads assets for use in Remotion',
    shapes: 'Generate SVG shapes',
    'zod-types': 'Zod types for Remotion',
    gif: 'Embed GIFs in a Remotion video',
    'eslint-plugin': 'Rules for writing Remotion code',
    'eslint-config': 'Default configuration for Remotion templates (ESLint <= 8)',
    'eslint-config-flat': 'Default configuration for Remotion templates (ESLint >= 9)',
    'compositor-linux-x64-gnu': 'Linux x64 binary for the Remotion Rust code',
    'compositor-linux-x64-musl': 'Linux x64 binary for the Remotion Rust code',
    'compositor-darwin-x64': 'MacOS x64 binary for the Remotion Rust code',
    'compositor-darwin-arm64': 'MacOS Apple Silicon binary for the Remotion Rust code',
    'compositor-linux-arm64-gnu': 'Linux ARM64 binary for the Remotion Rust code',
    'compositor-linux-arm64-musl': 'Linux ARM64 binary for the Remotion Rust code',
    'babel-loader': 'Babel loader for Remotion',
    fonts: 'Helpers for loading local fonts into Remotion',
    transitions: 'Library for creating transitions in Remotion',
    'enable-scss': 'Enable SCSS support in Remotion',
    'create-video': 'Create a new Remotion project',
    'studio-shared': 'Internal package for shared objects between the Studio backend and frontend',
    tailwind: 'Enable TailwindCSS support in Remotion (TailwindCSS v3)',
    'tailwind-v4': 'Enable TailwindCSS support in Remotion (TailwindCSS v4)',
    streaming: 'Utilities for streaming data between programs',
    'media-parser': 'A pure JavaScript library for parsing video files',
    rive: 'Embed Rive animations in a Remotion video',
    paths: 'Utilities for working with SVG paths',
    studio: 'APIs for interacting with the Remotion Studio',
    skia: 'Include React Native Skia components in a Remotion video',
    three: 'Include React Three Fiber components in a Remotion video',
    'astro-example': null,
    'lambda-go-example': null,
    'compositor-win32-x64-msvc': null,
    'animation-utils': 'Helpers for animating CSS properties',
    'test-utils': null,
    'example-without-zod': null,
    'lambda-go': null,
    example: null,
    'lambda-php': null,
    'lambda-client': null,
    bugs: null,
    docs: null,
    'it-tests': null,
    'react18-tests': null,
    'lambda-python': null,
    'lambda-ruby': null,
    'player-example': null,
    'ai-improvements': null,
    'discord-poster': null,
    'docusaurus-plugin': null,
    'animated-emoji': 'Google Fonts Animated Emojis as Remotion components',
    serverless: 'A runtime for distributed rendering',
    webcodecs: 'Media conversion in the browser',
    convert: 'Video conversion tool - convert.remotion.dev',
    captions: 'Primitives for dealing with captions',
    'openai-whisper': 'Work with the output of the OpenAI Whisper API',
    'eslint-config-internal': "ESLint condig for Remotion's internal packages",
    'example-videos': null,
    'promo-pages': null,
    'svg-3d-engine': '3D SVG extrusion effects',
    'serverless-client': null,
    media: 'Experimental WebCodecs-based media tags',
    'web-renderer': 'Render videos in the browser (not yet released)',
    design: 'Design system'
};
exports.installableMap = {
    'svg-3d-engine': false,
    'ai-improvements': false,
    'animation-utils': true,
    'animated-emoji': true,
    'astro-example': false,
    'babel-loader': false,
    bugs: false,
    bundler: false,
    cli: false,
    cloudrun: true,
    'lambda-client': false,
    'serverless-client': false,
    'compositor-darwin-arm64': false,
    'compositor-darwin-x64': false,
    'compositor-linux-arm64-gnu': false,
    'compositor-linux-arm64-musl': false,
    'compositor-linux-x64-gnu': false,
    'compositor-linux-x64-musl': false,
    'compositor-win32-x64-msvc': false,
    core: false,
    'create-video': false,
    'discord-poster': false,
    'docusaurus-plugin': false,
    docs: false,
    'enable-scss': true,
    'eslint-config': false,
    'eslint-config-flat': false,
    'eslint-config-internal': false,
    'eslint-plugin': false,
    'example-without-zod': false,
    example: false,
    fonts: true,
    gif: true,
    'google-fonts': true,
    'install-whisper-cpp': true,
    'whisper-web': true,
    'it-tests': false,
    'react18-tests': false,
    'lambda-go-example': false,
    'lambda-go': false,
    'lambda-php': false,
    'lambda-ruby': false,
    'lambda-python': false,
    lambda: true,
    mcp: true,
    'layout-utils': true,
    'rounded-text-box': true,
    licensing: true,
    lottie: true,
    'media-utils': true,
    'motion-blur': true,
    noise: true,
    paths: true,
    'player-example': false,
    player: true,
    preload: true,
    renderer: true,
    rive: true,
    shapes: true,
    skia: true,
    'promo-pages': false,
    streaming: false,
    serverless: false,
    'studio-server': false,
    'studio-shared': false,
    studio: true,
    tailwind: true,
    'tailwind-v4': true,
    'test-utils': false,
    three: true,
    transitions: true,
    'media-parser': true,
    'zod-types': true,
    webcodecs: true,
    convert: false,
    captions: true,
    'openai-whisper': true,
    compositor: false,
    'example-videos': false,
    media: true,
    'web-renderer': false,
    design: false
};
exports.apiDocs = {
    player: 'https://www.remotion.dev/docs/player',
    cloudrun: 'https://www.remotion.dev/docs/cloudrun',
    renderer: 'https://www.remotion.dev/docs/renderer',
    cli: 'https://www.remotion.dev/docs/cli',
    core: 'https://www.remotion.dev/docs/remotion',
    lambda: 'https://www.remotion.dev/docs/lambda',
    bundler: 'https://www.remotion.dev/docs/bundler',
    'lambda-client': null,
    'serverless-client': null,
    'studio-server': null,
    'install-whisper-cpp': 'https://www.remotion.dev/docs/install-whisper-cpp',
    'whisper-web': 'https://www.remotion.dev/docs/whisper-web',
    'google-fonts': 'https://www.remotion.dev/docs/google-fonts',
    'media-utils': 'https://www.remotion.dev/docs/media-utils',
    lottie: 'https://www.remotion.dev/docs/lottie',
    licensing: 'https://www.remotion.dev/docs/licensing',
    'layout-utils': 'https://www.remotion.dev/docs/layout-utils',
    'rounded-text-box': 'https://www.remotion.dev/docs/rounded-text-box',
    noise: 'https://www.remotion.dev/docs/noise',
    mcp: 'https://www.remotion.dev/docs/ai/mcp',
    'motion-blur': 'https://www.remotion.dev/docs/motion-blur',
    preload: 'https://www.remotion.dev/docs/preload',
    shapes: 'https://www.remotion.dev/docs/shapes',
    'zod-types': 'https://www.remotion.dev/docs/zod-types',
    gif: 'https://www.remotion.dev/docs/gif',
    'eslint-plugin': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',
    'eslint-config': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',
    'eslint-config-flat': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',
    'compositor-linux-x64-gnu': null,
    'compositor-linux-x64-musl': null,
    'compositor-darwin-x64': null,
    'ai-improvements': null,
    'discord-poster': null,
    'docusaurus-plugin': null,
    'animation-utils': 'https://www.remotion.dev/docs/animation-utils/',
    'example-without-zod': null,
    'lambda-go': null,
    example: null,
    'lambda-php': null,
    bugs: null,
    docs: null,
    'it-tests': null,
    'react18-tests': null,
    'lambda-python': null,
    'lambda-ruby': 'https://www.remotion.dev/docs/lambda/ruby',
    'player-example': null,
    'astro-example': null,
    'lambda-go-example': null,
    'test-utils': null,
    'babel-loader': 'https://www.remotion.dev/docs/legacy-babel',
    'compositor-darwin-arm64': null,
    'compositor-linux-arm64-gnu': null,
    'compositor-linux-arm64-musl': null,
    'compositor-win32-x64-msvc': null,
    'enable-scss': 'https://www.remotion.dev/docs/enable-scss/overview',
    'create-video': 'https://remotion.dev/templates',
    'studio-shared': null,
    'media-parser': 'https://www.remotion.dev/docs/media-parser',
    fonts: 'https://www.remotion.dev/docs/fonts-api',
    paths: 'https://www.remotion.dev/paths',
    rive: 'https://www.remotion.dev/docs/rive',
    tailwind: 'https://www.remotion.dev/docs/tailwind/tailwind',
    'tailwind-v4': 'https://www.remotion.dev/docs/tailwind/tailwind',
    skia: 'https://www.remotion.dev/docs/skia',
    three: 'https://www.remotion.dev/docs/three',
    streaming: null,
    serverless: null,
    studio: 'https://www.remotion.dev/docs/studio/api',
    transitions: 'https://www.remotion.dev/transitions',
    'animated-emoji': 'https://www.remotion.dev/docs/animated-emoji',
    webcodecs: 'https://remotion.dev/webcodecs',
    convert: 'https://convert.remotion.dev',
    captions: 'https://remotion.dev/docs/captions',
    'openai-whisper': 'https://www.remotion.dev/docs/openai-whisper',
    'eslint-config-internal': null,
    compositor: null,
    'example-videos': null,
    'promo-pages': null,
    'svg-3d-engine': null,
    media: 'https://remotion.dev/docs/media',
    // TODO: Add docs
    'web-renderer': null,
    design: 'https://www.remotion.dev/design'
};
}),
"[project]/node_modules/@remotion/studio-shared/dist/source-map-endpoint.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SOURCE_MAP_ENDPOINT = void 0;
exports.SOURCE_MAP_ENDPOINT = '/source-map-helper.wasm';
}),
"[project]/node_modules/@remotion/studio-shared/dist/stringify-default-props.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringifyDefaultProps = void 0;
const no_react_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
function replacerWithPath(replacer) {
    const m = new Map();
    return function(field, value) {
        const path = [
            m.get(this),
            field
        ].flat(1);
        if (value === Object(value)) {
            m.set(value, path);
        }
        return replacer.call(this, field, value, path.filter((item)=>typeof item !== 'undefined' && item !== ''));
    };
}
const doesMatchPath = (path1, enumPaths)=>{
    return enumPaths.some((p)=>// especially 0 for root!
        path1.length === p.length && path1.every((item, index)=>{
            if (p[index] === '[]' && !Number.isNaN(Number(item))) {
                return true;
            }
            if (p[index] === '{}' && typeof item === 'string') {
                return true;
            }
            return item === p[index];
        }));
};
const stringifyDefaultProps = ({ props, enumPaths })=>{
    return JSON.stringify(props, replacerWithPath(function(key, value, path) {
        /* Don't replace with arrow function! This function uses `this` */ const item = this[key];
        if (typeof item === 'string' && doesMatchPath(path, enumPaths)) {
            return `${item}__ADD_AS_CONST__`;
        }
        // For zMatrix()
        if (doesMatchPath(path, enumPaths)) {
            return `__REMOVEQUOTE__${JSON.stringify(item)}__ADD_AS_LITERAL_CONST__`;
        }
        if (typeof item === 'string' && item.startsWith(no_react_1.NoReactInternals.FILE_TOKEN)) {
            return `__REMOVEQUOTE____WRAP_IN_STATIC_FILE_START__${decodeURIComponent(item.replace(no_react_1.NoReactInternals.FILE_TOKEN, ''))}__WRAP_IN_STATIC_FILE_END____REMOVEQUOTE__`;
        }
        if (typeof item === 'string' && item.startsWith(no_react_1.NoReactInternals.DATE_TOKEN)) {
            return `__REMOVEQUOTE____WRAP_IN_DATE_START__${decodeURIComponent(item.replace(no_react_1.NoReactInternals.DATE_TOKEN, ''))}__WRAP_IN_DATE_END____REMOVEQUOTE__`;
        }
        return value;
    })).replace(/"__REMOVEQUOTE__/g, '').replace(/__REMOVEQUOTE__"/g, '').replace(/__ADD_AS_CONST__"/g, '" as const').replace(/__ADD_AS_LITERAL_CONST__"/g, ' as const').replace(/__WRAP_IN_STATIC_FILE_START__/g, 'staticFile("').replace(/__WRAP_IN_STATIC_FILE_END__/g, '")').replace(/__WRAP_IN_DATE_START__/g, 'new Date("').replace(/__WRAP_IN_DATE_END__/g, '")');
};
exports.stringifyDefaultProps = stringifyDefaultProps;
}),
"[project]/node_modules/@remotion/studio-shared/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringifyDefaultProps = exports.SOURCE_MAP_ENDPOINT = exports.packages = exports.installableMap = exports.descriptions = exports.apiDocs = exports.DEFAULT_TIMELINE_TRACKS = exports.hotMiddlewareOptions = exports.getProjectName = exports.getLocationFromBuildError = exports.getDefaultOutLocation = exports.formatBytes = exports.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS = exports.stripAnsi = exports.splitAnsi = void 0;
var ansi_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/ansi.js [app-route] (ecmascript)");
Object.defineProperty(exports, "splitAnsi", {
    enumerable: true,
    get: function() {
        return ansi_1.splitAnsi;
    }
});
Object.defineProperty(exports, "stripAnsi", {
    enumerable: true,
    get: function() {
        return ansi_1.stripAnsi;
    }
});
var default_buffer_state_delay_in_milliseconds_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/default-buffer-state-delay-in-milliseconds.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS", {
    enumerable: true,
    get: function() {
        return default_buffer_state_delay_in_milliseconds_1.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS;
    }
});
var format_bytes_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/format-bytes.js [app-route] (ecmascript)");
Object.defineProperty(exports, "formatBytes", {
    enumerable: true,
    get: function() {
        return format_bytes_1.formatBytes;
    }
});
var get_default_out_name_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/get-default-out-name.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getDefaultOutLocation", {
    enumerable: true,
    get: function() {
        return get_default_out_name_1.getDefaultOutLocation;
    }
});
var get_location_from_build_error_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/get-location-from-build-error.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getLocationFromBuildError", {
    enumerable: true,
    get: function() {
        return get_location_from_build_error_1.getLocationFromBuildError;
    }
});
var get_project_name_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/get-project-name.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getProjectName", {
    enumerable: true,
    get: function() {
        return get_project_name_1.getProjectName;
    }
});
var hot_middleware_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/hot-middleware.js [app-route] (ecmascript)");
Object.defineProperty(exports, "hotMiddlewareOptions", {
    enumerable: true,
    get: function() {
        return hot_middleware_1.hotMiddlewareOptions;
    }
});
var max_timeline_tracks_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/max-timeline-tracks.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DEFAULT_TIMELINE_TRACKS", {
    enumerable: true,
    get: function() {
        return max_timeline_tracks_1.DEFAULT_TIMELINE_TRACKS;
    }
});
var package_info_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/package-info.js [app-route] (ecmascript)");
Object.defineProperty(exports, "apiDocs", {
    enumerable: true,
    get: function() {
        return package_info_1.apiDocs;
    }
});
Object.defineProperty(exports, "descriptions", {
    enumerable: true,
    get: function() {
        return package_info_1.descriptions;
    }
});
Object.defineProperty(exports, "installableMap", {
    enumerable: true,
    get: function() {
        return package_info_1.installableMap;
    }
});
Object.defineProperty(exports, "packages", {
    enumerable: true,
    get: function() {
        return package_info_1.packages;
    }
});
var source_map_endpoint_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/source-map-endpoint.js [app-route] (ecmascript)");
Object.defineProperty(exports, "SOURCE_MAP_ENDPOINT", {
    enumerable: true,
    get: function() {
        return source_map_endpoint_1.SOURCE_MAP_ENDPOINT;
    }
});
var stringify_default_props_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/stringify-default-props.js [app-route] (ecmascript)");
Object.defineProperty(exports, "stringifyDefaultProps", {
    enumerable: true,
    get: function() {
        return stringify_default_props_1.stringifyDefaultProps;
    }
});
}),
"[project]/node_modules/@remotion/bundler/dist/copy-dir.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.copyDir = copyDir;
const node_fs_1 = __importDefault(__turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)"));
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
async function copyDir({ src, dest, onSymlinkDetected, onProgress, copiedBytes = 0, lastReportedProgress = 0 }) {
    await node_fs_1.default.promises.mkdir(dest, {
        recursive: true
    });
    const entries = await node_fs_1.default.promises.readdir(src, {
        withFileTypes: true
    });
    for (const entry of entries){
        const srcPath = node_path_1.default.join(src, entry.name);
        const destPath = node_path_1.default.join(dest, entry.name);
        if (entry.isDirectory()) {
            copiedBytes = await copyDir({
                src: srcPath,
                dest: destPath,
                onSymlinkDetected,
                onProgress,
                copiedBytes,
                lastReportedProgress
            });
        } else if (entry.isSymbolicLink()) {
            const realpath = await node_fs_1.default.promises.realpath(srcPath);
            onSymlinkDetected(entry, src);
            await node_fs_1.default.promises.symlink(realpath, destPath);
        } else {
            const [, { size }] = await Promise.all([
                node_fs_1.default.promises.copyFile(srcPath, destPath),
                node_fs_1.default.promises.stat(srcPath)
            ]);
            copiedBytes += size;
            if (copiedBytes - lastReportedProgress > 1024 * 1024 * 10) {
                onProgress(copiedBytes);
                lastReportedProgress = copiedBytes;
            }
        }
    }
    return copiedBytes;
}
}),
"[project]/node_modules/@remotion/bundler/dist/index-html.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.indexHtml = void 0;
const remotion_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
const indexHtml = ({ publicPath, editorName, inputProps, envVariables, staticHash, remotionRoot, studioServerCommand, renderQueue, numberOfAudioTags, publicFiles, includeFavicon, title, renderDefaults, publicFolderExists, gitSource, projectName, installedDependencies, packageManager, audioLatencyHint, logLevel, mode })=>// Must setup remotion_editorName and remotion.remotion_projectName before bundle.js is loaded
    `
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		${includeFavicon ? `<link id="__remotion_favicon" rel="icon" type="image/png" href="${publicPath}favicon.ico" />` : ''}
		<title>${title}</title>
	</head>
	<body>
		<script>window.remotion_numberOfAudioTags = ${numberOfAudioTags};</script>
		<script>window.remotion_audioLatencyHint = "${audioLatencyHint}";</script>
		${mode === 'dev' ? `<script>window.remotion_logLevel = "${logLevel}";</script>` : ''}
		<script>window.remotion_staticBase = "${staticHash}";</script>
		${editorName ? `<script>window.remotion_editorName = "${editorName}";</script>` : '<script>window.remotion_editorName = null;</script>'}
		<script>window.remotion_projectName = ${JSON.stringify(projectName)};</script>
		<script>window.remotion_publicPath = ${JSON.stringify(publicPath)};</script>
		<script>window.remotion_renderDefaults = ${JSON.stringify(renderDefaults)};</script>
		<script>window.remotion_cwd = ${JSON.stringify(remotionRoot)};</script>
		<script>window.remotion_studioServerCommand = ${studioServerCommand ? JSON.stringify(studioServerCommand) : 'null'};</script>
		${inputProps ? `<script>window.remotion_inputProps = ${JSON.stringify(JSON.stringify(inputProps))};</script>` : ''}
		${renderQueue ? `<script>window.remotion_initialRenderQueue = ${JSON.stringify(renderQueue)};</script>` : ''}
		${envVariables ? `<script>window.process = {env: ${JSON.stringify(envVariables)}};</script>` : ''}
		${gitSource ? `<script>window.remotion_gitSource = ${JSON.stringify(gitSource)};</script>` : ''}
		${mode === 'dev' ? `
		<script>window.remotion_isStudio = true;</script>
		<script>window.remotion_isReadOnlyStudio = false;</script>`.trimStart() : ''}
		<script>window.remotion_staticFiles = ${JSON.stringify(publicFiles)}</script>
		<script>window.remotion_installedPackages = ${JSON.stringify(installedDependencies)}</script>
		<script>window.remotion_packageManager = ${JSON.stringify(packageManager)}</script>
		<script>window.remotion_publicFolderExists = ${publicFolderExists ? `"${publicFolderExists}"` : 'null'};</script>
		<script>
				window.siteVersion = '11';
				window.remotion_version = '${remotion_1.VERSION}';
		</script>
		
		<div id="video-container"></div>
		<div id="${remotion_1.Internals.REMOTION_STUDIO_CONTAINER_ELEMENT}"></div>
		<div id="menuportal-0"></div>
		<div id="menuportal-1"></div>
		<div id="menuportal-2"></div>
		<div id="menuportal-3"></div>
		<div id="menuportal-4"></div>
		<div id="menuportal-5"></div>
		<div id="remotion-error-overlay"></div>
		<div id="server-disconnected-overlay"></div>
		<script src="${publicPath}bundle.js"></script>
	</body>
</html>
`.trim();
exports.indexHtml = indexHtml;
}),
"[project]/node_modules/@remotion/bundler/dist/read-recursively.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readRecursively = void 0;
const node_fs_1 = __importStar(__turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)"));
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
// There can be symbolic links that point to files that don't exist.
// https://github.com/remotion-dev/remotion/issues/2587
const statOrNull = (p)=>{
    try {
        return (0, node_fs_1.statSync)(p);
    } catch (_a) {
        return null;
    }
};
const encodeBySplitting = (p)=>{
    // Intentional: split by path.sep, then join by /
    const splitBySlash = p.split(node_path_1.default.sep);
    const encodedArray = splitBySlash.map((element)=>{
        return encodeURIComponent(element);
    });
    const merged = encodedArray.join('/');
    return merged;
};
const readRecursively = ({ folder, output = [], startPath, staticHash, limit })=>{
    const absFolder = node_path_1.default.join(startPath, folder);
    if (!node_fs_1.default.existsSync(absFolder)) {
        return [];
    }
    const files = node_fs_1.default.readdirSync(absFolder);
    for (const file of files){
        if (output.length >= limit) {
            break;
        }
        if (file.startsWith('.DS_Store')) {
            continue;
        }
        const stat = statOrNull(node_path_1.default.join(absFolder, file));
        if (!stat) {
            continue;
        }
        if (stat.isDirectory()) {
            (0, exports.readRecursively)({
                startPath,
                folder: node_path_1.default.join(folder, file),
                output,
                staticHash,
                limit
            });
        } else if (stat.isFile()) {
            output.push({
                name: node_path_1.default.join(folder, file),
                lastModified: Math.floor(stat.mtimeMs),
                sizeInBytes: stat.size,
                src: staticHash + '/' + encodeBySplitting(node_path_1.default.join(folder, file))
            });
        } else if (stat.isSymbolicLink()) {
            const realpath = node_fs_1.default.realpathSync(node_path_1.default.join(folder, file));
            const realStat = statOrNull(realpath);
            if (!realStat) {
                continue;
            }
            if (realStat.isFile()) {
                output.push({
                    name: realpath,
                    lastModified: Math.floor(realStat.mtimeMs),
                    sizeInBytes: realStat.size,
                    src: staticHash + '/' + encodeBySplitting(realpath)
                });
            }
        }
    }
    return output.sort((a, b)=>a.name.localeCompare(b.name));
};
exports.readRecursively = readRecursively;
}),
"[project]/node_modules/@remotion/bundler/dist/fast-refresh/helpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Source code is adapted from https://github.com/WebHotelier/webpack-fast-refresh#readme and rewritten in Typescript. This file is MIT licensed.
 */ /**
 * MIT License
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
// This file is copied from the Metro JavaScript bundler, with minor tweaks for
// webpack compatibility.
//
// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js
const RefreshRuntime = __turbopack_context__.r("[project]/node_modules/react-refresh/runtime.js [app-route] (ecmascript)");
function isSafeExport(key) {
    return key === '__esModule' || key === '__N_SSG' || key === '__N_SSP' || key === 'config';
}
function registerExportsForReactRefresh(moduleExports, moduleID) {
    RefreshRuntime.register(moduleExports, moduleID + ' %exports%');
    if (moduleExports === null || moduleExports === undefined || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return;
    }
    for(const key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        // @ts-expect-error
        const exportValue = moduleExports[key];
        const typeID = moduleID + ' %exports% ' + key;
        RefreshRuntime.register(exportValue, typeID);
    }
}
function isReactRefreshBoundary(moduleExports) {
    if (RefreshRuntime.isLikelyComponentType(moduleExports)) {
        return true;
    }
    if (moduleExports === null || moduleExports === undefined || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        return false;
    }
    let hasExports = false;
    let areAllExportsComponents = true;
    for(const key in moduleExports){
        hasExports = true;
        if (isSafeExport(key)) {
            continue;
        }
        // @ts-expect-error
        const exportValue = moduleExports[key];
        if (!RefreshRuntime.isLikelyComponentType(exportValue)) {
            areAllExportsComponents = false;
        }
    }
    return hasExports && areAllExportsComponents;
}
function getRefreshBoundarySignature(moduleExports) {
    const signature = [];
    signature.push(RefreshRuntime.getFamilyByType(moduleExports));
    if (moduleExports === null || moduleExports === undefined || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return signature;
    }
    for(const key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        // @ts-expect-error
        const exportValue = moduleExports[key];
        signature.push(key);
        signature.push(RefreshRuntime.getFamilyByType(exportValue));
    }
    return signature;
}
function shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {
    const prevSignature = getRefreshBoundarySignature(prevExports);
    const nextSignature = getRefreshBoundarySignature(nextExports);
    if (prevSignature.length !== nextSignature.length) {
        return true;
    }
    for(let i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) {
            return true;
        }
    }
    return false;
}
function scheduleUpdate() {
    var _a, _b;
    const execute = ()=>{
        try {
            RefreshRuntime.performReactRefresh();
        } catch (err) {
            // eslint-disable-next-line no-console
            console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\n' + err);
        }
    };
    // Only trigger refresh if the webpack HMR state is idle
    if (((_a = __webpack_module__.hot) === null || _a === void 0 ? void 0 : _a.status()) === 'idle') {
        return;
    }
    (_b = __webpack_module__.hot) === null || _b === void 0 ? void 0 : _b.addStatusHandler((status)=>{
        if (status === 'idle') {
            execute();
        }
    });
}
exports.default = {
    registerExportsForReactRefresh,
    isReactRefreshBoundary,
    shouldInvalidateReactRefreshBoundary,
    getRefreshBoundarySignature,
    scheduleUpdate
};
}),
"[project]/node_modules/@remotion/bundler/dist/fast-refresh/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/// <reference lib="dom" />
/// <reference lib="dom.iterable" />
/**
 * Source code is adapted from https://github.com/WebHotelier/webpack-fast-refresh#readme and rewritten in Typescript. This file is MIT licensed.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const RefreshRuntime = __turbopack_context__.r("[project]/node_modules/react-refresh/runtime.js [app-route] (ecmascript)");
const helpers_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/fast-refresh/helpers.js [app-route] (ecmascript)"));
// Hook into ReactDOM initialization
RefreshRuntime.injectIntoGlobalHook(self);
// noop fns to prevent runtime errors during initialization
self.$RefreshReg$ = ()=>undefined;
self.$RefreshSig$ = ()=>(type)=>type;
// Register global helpers
self.$RefreshHelpers$ = helpers_1.default;
// Register a helper for module execution interception
self.$RefreshInterceptModuleExecution$ = function(webpackModuleId) {
    const prevRefreshReg = self.$RefreshReg$;
    const prevRefreshSig = self.$RefreshSig$;
    self.$RefreshReg$ = (type, id)=>{
        RefreshRuntime.register(type, webpackModuleId + ' ' + id);
    };
    self.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
    // Modeled after `useEffect` cleanup pattern:
    return ()=>{
        self.$RefreshReg$ = prevRefreshReg;
        self.$RefreshSig$ = prevRefreshSig;
    };
};
}),
"[project]/node_modules/@remotion/bundler/dist/setup-environment.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// https://github.com/remotion-dev/remotion/issues/3412#issuecomment-1910120552
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.injectCSS = void 0;
function getEnvVar() {
    const parts = [
        'proc',
        'ess',
        '.',
        'en',
        'v',
        '.',
        'NOD',
        'E_EN',
        'V'
    ];
    return parts.join('');
}
const getEnvVariables = ()=>{
    if (window.remotion_isStudio) {
        // For the Studio, we already set the environment variables in index-html.ts.
        // We just add NODE_ENV here.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return {
            NODE_ENV: ("TURBOPACK compile-time value", "development")
        };
    }
    const param = window.remotion_envVariables;
    if (!param) {
        return {};
    }
    return {
        ...JSON.parse(param),
        NODE_ENV: ("TURBOPACK compile-time value", "development")
    };
};
const setupEnvVariables = ()=>{
    const env = getEnvVariables();
    if (!window.process) {
        window.process = {};
    }
    if (!window.process.env) {
        window.process.env = {};
    }
    Object.keys(env).forEach((key)=>{
        window.process.env[key] = env[key];
    });
};
setupEnvVariables();
const injected = {};
const injectCSS = (css)=>{
    // Skip in node
    if (typeof document === 'undefined') {
        return;
    }
    if (injected[css]) {
        return;
    }
    const head = document.head || document.getElementsByTagName('head')[0];
    const style = document.createElement('style');
    style.appendChild(document.createTextNode(css));
    head.prepend(style);
    injected[css] = true;
};
exports.injectCSS = injectCSS;
(0, exports.injectCSS)(`
  .css-reset, .css-reset * {
    font-size: 16px;
    line-height: 1.5;
    color: white;
    font-family: Arial, Helvetica, sans-serif;
    background: transparent;
    box-sizing: border-box;
  }

  .algolia-docsearch-suggestion--highlight {
    font-size: 15px;
    line-height: 1.25;
  }

  .__remotion-info-button-container code {
    font-family: monospace;
    font-size: 14px;
    color: #0584f2
  }

  .__remotion-vertical-scrollbar::-webkit-scrollbar {
      width: 6px;
  }
  .__remotion-vertical-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.0);
  }
  .__remotion-vertical-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.6);
  }
  .__remotion-vertical-scrollbar:hover::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 1);
  }


  .__remotion-horizontal-scrollbar::-webkit-scrollbar {
    height: 6px;
  }
  .__remotion-horizontal-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.0);
  }
  .__remotion-horizontal-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.6);
  }
  .__remotion-horizontal-scrollbar:hover::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 1);
  }


  @-moz-document url-prefix() {
    .__remotion-vertical-scrollbar {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.6) rgba(0, 0, 0, 0);
    }

    .__remotion-vertical-scrollbar:hover {
      scrollbar-color: rgba(0, 0, 0, 1) rgba(0, 0, 0, 0);
    }

    .__remotion-horizontal-scrollbar {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.6) rgba(0, 0, 0, 0);
    }

    .__remotion-horizontal-scrollbar:hover {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 1) rgba(0, 0, 0, 0);
    }
  }


  .__remotion-timeline-slider {
    appearance: none;
    width: 100px;
    border-radius: 3px;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    accent-color: #ffffff;
  }
  
  .__remotion-timeline-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background-color: #ffffff;
    appearance: none;
  }
`);
}),
"[project]/node_modules/@remotion/bundler/react-shim.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
;
if (typeof globalThis === 'undefined') {
    window.React = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__;
} else {
    globalThis.React = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__;
}
}),
"[project]/node_modules/@remotion/bundler/dist/esbuild-loader/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const esbuild_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)");
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
const isTsExtensionPtrn = /\.ts$/i;
const isTypescriptInstalled = ()=>{
    try {
        "[externals]/typescript [external] (typescript, cjs)";
        return true;
    } catch (_a) {
        return false;
    }
};
async function ESBuildLoader(source) {
    var _a, _b, _c;
    const done = this.async();
    const options = this.getOptions();
    const { implementation, remotionRoot, ...esbuildTransformOptions } = options;
    const tsConfigPath = node_path_1.default.join(remotionRoot, 'tsconfig.json');
    if (implementation && typeof implementation.transform !== 'function') {
        done(new TypeError(`esbuild-loader: options.implementation.transform must be an ESBuild transform function. Received ${typeof implementation.transform}`));
        return;
    }
    const transform = (_a = implementation === null || implementation === void 0 ? void 0 : implementation.transform) !== null && _a !== void 0 ? _a : esbuild_1.transform;
    const transformOptions = {
        ...esbuildTransformOptions,
        target: (_b = options.target) !== null && _b !== void 0 ? _b : 'es2015',
        loader: (_c = options.loader) !== null && _c !== void 0 ? _c : 'js',
        sourcemap: this.sourceMap,
        sourcefile: this.resourcePath
    };
    if (!('tsconfigRaw' in transformOptions) && isTypescriptInstalled()) {
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
        const typescript = __turbopack_context__.r("[externals]/typescript [external] (typescript, cjs)");
        const tsConfig = typescript.readConfigFile(tsConfigPath, typescript.sys.readFile);
        transformOptions.tsconfigRaw = tsConfig.config;
    }
    // https://github.com/privatenumber/esbuild-loader/pull/107
    if (transformOptions.loader === 'tsx' && isTsExtensionPtrn.test(this.resourcePath)) {
        transformOptions.loader = 'ts';
    }
    try {
        const { code, map } = await transform(source, transformOptions);
        done(null, code, map && JSON.parse(map));
    } catch (error) {
        done(error);
    }
}
exports.default = ESBuildLoader;
}),
"[project]/node_modules/@remotion/bundler/dist/fast-refresh/loader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 *  Be careful when refactoring this file!
 * This gets injected into every file of the browser.
 * You cannot have returns, optional chains, inverse the if statement etc.
 * Check the Typescript output in dist/ to see that no extra `var` statements were produced
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
// This file is copied from the @vercel/next.js, with removed TS annotations
//
// https://github.com/vercel/next.js/blob/canary/packages/react-refresh-utils/loader.ts
// This function gets unwrapped into global scope, which is why we don't invert
// if-blocks. Also, you cannot use `return`.
function RefreshModuleRuntime() {
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:
    '$RefreshHelpers$' in self) {
        const currentExports = __webpack_module__.exports;
        const prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            __webpack_module__.hot.dispose((data)=>{
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            __webpack_module__.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    __webpack_module__.hot.invalidate();
                } else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        } else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            const isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                __webpack_module__.hot.invalidate();
            }
        }
    }
}
let refreshModuleRuntime = RefreshModuleRuntime.toString();
refreshModuleRuntime = refreshModuleRuntime.slice(refreshModuleRuntime.indexOf('{') + 1, refreshModuleRuntime.lastIndexOf('}'));
const ReactRefreshLoader = function(source, inputSourceMap) {
    // Importing a module that declares the global variables _a and _b
    // will conflict with the global variables that React Fast Refresh uses.
    // https://github.com/remotion-dev/remotion/issues/3699
    const renamedSymbols = refreshModuleRuntime.replace(/_a/g, '_remotion_globalVariableA').replace(/_b/g, '_remotion_globalVariableB');
    this.callback(null, `${source}\n;${renamedSymbols}`, inputSourceMap);
};
exports.default = ReactRefreshLoader;
}),
"[project]/node_modules/@remotion/bundler/dist/case-sensitive-paths.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CaseSensitivePathsPlugin = void 0;
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
// Inlined from https://github.com/umijs/case-sensitive-paths-webpack-plugin/blob/master/src/index.ts
/**
 * The MIT License (MIT)

Copyright (c) 2022-present UmiJS Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */ const PLUGIN_NAME = 'CaseSensitive';
class CaseSensitivePathsPlugin {
    constructor(){
        this.context = '';
        this.cacheMap = new Map();
        this.deferrerMap = new Map();
    }
    /**
     * Check if resource need to be checked
     */ isCheckable(res, type, issuer) {
        return(// skip base64 url in css files
        type !== 'asset/inline' && // skip resources which outside project
        res.startsWith(this.context) && // skip node_modules
        !/(\/|\\)node_modules\1/.test(res) && // skip duplicated css resource by unknown reason
        res !== issuer);
    }
    /**
     * Check if file exists with case sensitive
     */ checkFileExistsWithCase(res) {
        return new Promise((resolve, reject)=>{
            let full = res;
            let caseError = null;
            const deferrers = [];
            // check every level directories for resource, except outside project
            while(full.length > this.context.length){
                const { dir, base: current } = path_1.default.parse(full);
                let deferrer;
                if (this.cacheMap.get(dir)) {
                    // use cache first
                    deferrer = Promise.resolve(this.cacheMap.get(dir));
                } else if (this.deferrerMap.get(dir)) {
                    // wait another same directory to be resolved
                    deferrer = this.deferrerMap.get(dir);
                } else {
                    // read directory for the first time
                    deferrer = new Promise((resolve2)=>{
                        this.fs.readdir(dir, (_, files = [])=>{
                            // save cache, resolve promise and release deferrer
                            this.cacheMap.set(dir, files);
                            resolve2(files);
                            this.deferrerMap.delete(dir);
                        });
                    });
                    // save deferrer for another called
                    this.deferrerMap.set(dir, deferrer);
                }
                // check current file synchronously, for performance
                deferrer.then((files)=>{
                    // try to find correct name
                    // if current file not exists in current directory and there has no existing error
                    if (!files.includes(current) && !caseError) {
                        const correctName = files.find((file)=>file.toLowerCase() === current.toLowerCase());
                        // only throw first error for the single resource
                        if (correctName) {
                            caseError = new Error(`Capitalization mismatch in \`${path_1.default.join(res)}\`: \`${current}\` does not match the name on disk \`${correctName}\``);
                            reject(caseError);
                        }
                    }
                });
                deferrers.push(deferrer);
                // continue to check upper directory
                full = dir;
            }
            Promise.all(deferrers).then(()=>{
                // resolve if no error
                if (!caseError) {
                    resolve(caseError);
                }
            });
        });
    }
    /**
     * reset this plugin, wait for the next compilation
     */ reset() {
        this.cacheMap = new Map();
        this.deferrerMap = new Map();
    }
    apply(compiler) {
        this.context = compiler.options.context || process.cwd();
        this.fs = compiler.inputFileSystem;
        compiler.hooks.normalModuleFactory.tap(PLUGIN_NAME, (factory)=>{
            factory.hooks.afterResolve.tapAsync(PLUGIN_NAME, (data, done)=>{
                var _a, _b;
                // compatible with webpack 4.x
                const { createData = data } = data;
                if (createData.resource && this.isCheckable(createData.resource, createData.type, (_b = (_a = createData.resourceResolveData) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.issuer)) {
                    this.checkFileExistsWithCase(createData.resource.replace(/\?.+$/, '')// replace escaped \0# with # see: https://github.com/webpack/enhanced-resolve#escaping
                    .replace('\u0000#', '#')).then(()=>done(null), (err)=>done(err));
                } else {
                    done(null);
                }
            });
        });
        compiler.hooks.done.tap(PLUGIN_NAME, ()=>{
            this.reset();
        });
    }
}
exports.CaseSensitivePathsPlugin = CaseSensitivePathsPlugin;
}),
"[project]/node_modules/@remotion/bundler/dist/fast-refresh/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Source code is adapted from https://github.com/WebHotelier/webpack-fast-refresh#readme and rewritten in Typescript. This file is MIT licensed.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReactFreshWebpackPlugin = void 0;
const webpack_1 = __turbopack_context__.r("[externals]/webpack [external] (webpack, cjs)");
class ReactRefreshRuntimeModule extends webpack_1.RuntimeModule {
    constructor(){
        super('react refresh', 5);
    }
    generate() {
        const { runtimeTemplate } = this.compilation;
        return webpack_1.Template.asString([
            `${webpack_1.RuntimeGlobals.interceptModuleExecution}.push(${runtimeTemplate.basicFunction('options', [
                `const originalFactory = options.factory;`,
                `options.factory = ${runtimeTemplate.basicFunction('moduleObject, moduleExports, webpackRequire', [
                    // Legacy CSS implementations will `eval` browser code in a Node.js
                    // context to extract CSS. For backwards compatibility, we need to check
                    // we're in a browser context before continuing.
                    `const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;`,
                    `const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};`,
                    'try {',
                    webpack_1.Template.indent('originalFactory.call(this, moduleObject, moduleExports, webpackRequire);'),
                    '} finally {',
                    webpack_1.Template.indent(`cleanup();`),
                    '}'
                ])}`
            ])})`
        ]);
    }
}
class ReactFreshWebpackPlugin {
    apply(compiler) {
        const webpackMajorVersion = parseInt(webpack_1.version !== null && webpack_1.version !== void 0 ? webpack_1.version : '', 10);
        if (webpackMajorVersion < 5) {
            throw new Error(`ReactFreshWebpackPlugin does not support webpack v${webpackMajorVersion}.`);
        }
        compiler.hooks.compilation.tap(this.constructor.name, (compilation)=>{
            compilation.mainTemplate.hooks.localVars.tap(this.constructor.name, (source)=>webpack_1.Template.asString([
                    source,
                    '',
                    '// noop fns to prevent runtime errors during initialization',
                    'if (typeof self !== "undefined") {',
                    webpack_1.Template.indent('self.$RefreshReg$ = function () {};'),
                    webpack_1.Template.indent('self.$RefreshSig$ = function () {'),
                    webpack_1.Template.indent(webpack_1.Template.indent('return function (type) {')),
                    webpack_1.Template.indent(webpack_1.Template.indent(webpack_1.Template.indent('return type;'))),
                    webpack_1.Template.indent(webpack_1.Template.indent('};')),
                    webpack_1.Template.indent('};'),
                    '}'
                ]));
            compilation.hooks.additionalTreeRuntimeRequirements.tap(this.constructor.name, (chunk)=>{
                compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());
            });
        });
    }
}
exports.ReactFreshWebpackPlugin = ReactFreshWebpackPlugin;
}),
"[project]/node_modules/@remotion/bundler/dist/hide-expression-dependency.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// When Webpack cannot resolve these dependencies, it will not print an error message.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AllowDependencyExpressionPlugin = void 0;
// If importing TypeScript, it will give this warning:
// WARNING in ./node_modules/typescript/lib/typescript.js 6304:33-52
// Critical dependency: the request of a dependency is an expression
class AllowDependencyExpressionPlugin {
    filter(error) {
        if (error.message.includes('the request of a dependency is an expression')) {
            return false;
        }
        return true;
    }
    apply(compiler) {
        compiler.hooks.afterCompile.tap('Com', (compilation)=>{
            compilation.errors = compilation.errors.filter(this.filter);
        });
        compiler.hooks.afterEmit.tap('AllowOptionalDependenciesPlugin', (compilation)=>{
            compilation.errors = compilation.errors.filter(this.filter);
            compilation.warnings = compilation.warnings.filter(this.filter);
        });
    }
}
exports.AllowDependencyExpressionPlugin = AllowDependencyExpressionPlugin;
}),
"[project]/node_modules/@remotion/bundler/dist/ignore-packfilecache-warnings.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Suppress the frequent Webpack warnings about serializing large strings in the cache
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IgnorePackFileCacheWarningsPlugin = void 0;
class IgnorePackFileCacheWarningsPlugin {
    filter(error) {
        if (error.message.includes('Serializing big strings')) {
            return false;
        }
        return true;
    }
    apply(compiler) {
        compiler.hooks.afterCompile.tap('IgnorePackFileCacheWarningsPlugin', (compilation)=>{
            compilation.warnings = compilation.warnings.filter(this.filter);
        });
        compiler.hooks.afterEmit.tap('IgnorePackFileCacheWarningsPlugin', (compilation)=>{
            compilation.warnings = compilation.warnings.filter(this.filter);
        });
    }
}
exports.IgnorePackFileCacheWarningsPlugin = IgnorePackFileCacheWarningsPlugin;
}),
"[project]/node_modules/@remotion/bundler/dist/optional-dependencies.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// When Webpack cannot resolve these dependencies, it will not print an error message.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AllowOptionalDependenciesPlugin = void 0;
const OPTIONAL_DEPENDENCIES = [
    'zod',
    '@remotion/zod-types',
    'react-native-reanimated',
    'react-native-reanimated/package.json'
];
const SOURCE_MAP_IGNORE = [
    'path',
    'fs'
];
class AllowOptionalDependenciesPlugin {
    filter(error) {
        for (const dependency of OPTIONAL_DEPENDENCIES){
            if (error.message.includes(`Can't resolve '${dependency}'`)) {
                return false;
            }
        }
        for (const dependency of SOURCE_MAP_IGNORE){
            if (error.message.includes(`Can't resolve '${dependency}'`) && error.message.includes('source-map')) {
                return false;
            }
        }
        return true;
    }
    apply(compiler) {
        compiler.hooks.afterCompile.tap('Com', (compilation)=>{
            compilation.errors = compilation.errors.filter(this.filter);
        });
        compiler.hooks.afterEmit.tap('AllowOptionalDependenciesPlugin', (compilation)=>{
            compilation.errors = compilation.errors.filter(this.filter);
            compilation.warnings = compilation.warnings.filter(this.filter);
        });
    }
}
exports.AllowOptionalDependenciesPlugin = AllowOptionalDependenciesPlugin;
}),
"[project]/node_modules/@remotion/bundler/dist/stringify-with-circular-references.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonStringifyWithCircularReferences = void 0;
const jsonStringifyWithCircularReferences = (circ)=>{
    let seen = [];
    const val = JSON.stringify(circ, (_, value)=>{
        if (typeof value === 'object' && value !== null && seen) {
            if (seen.includes(value)) {
                return '[Circular]';
            }
            seen.push(value);
        }
        return value;
    });
    seen = null;
    return val;
};
exports.jsonStringifyWithCircularReferences = jsonStringifyWithCircularReferences;
}),
"[project]/node_modules/@remotion/bundler/dist/webpack-cache.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cacheExists = exports.clearCache = exports.getWebpackCacheName = exports.getWebpackCacheEnvDir = void 0;
const node_fs_1 = __importDefault(__turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)"));
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
const version_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/version.mjs [app-route] (ecmascript)");
// Inlined from https://github.com/webpack/webpack/blob/4c2ee7a4ddb8db2362ca83b6c4190523387ba7ee/lib/config/defaults.js#L265
// An algorithm to determine where Webpack will cache the depencies
const getWebpackCacheDir = (remotionRoot)=>{
    let dir = remotionRoot;
    for(;;){
        try {
            if (node_fs_1.default.statSync(node_path_1.default.join(dir, 'package.json')).isFile()) {
                break;
            }
        } catch (_a) {}
        const parent = node_path_1.default.dirname(dir);
        if (dir === parent) {
            dir = undefined;
            break;
        }
        dir = parent;
    }
    if (!dir) {
        return node_path_1.default.resolve(remotionRoot, '.cache/webpack');
    }
    if (process.versions.pnp === '1') {
        return node_path_1.default.resolve(dir, '.pnp/.cache/webpack');
    }
    if (process.versions.pnp === '3') {
        return node_path_1.default.resolve(dir, '.yarn/.cache/webpack');
    }
    return node_path_1.default.resolve(dir, 'node_modules/.cache/webpack');
};
const getPrefix = (environment)=>{
    return `remotion-${environment}-${version_1.VERSION}`;
};
const getWebpackCacheEnvDir = (environment)=>{
    return getPrefix(environment);
};
exports.getWebpackCacheEnvDir = getWebpackCacheEnvDir;
const getWebpackCacheName = (environment, hash)=>{
    return [
        (0, exports.getWebpackCacheEnvDir)(environment),
        hash
    ].join(node_path_1.default.sep);
};
exports.getWebpackCacheName = getWebpackCacheName;
const remotionCacheLocationForEnv = (remotionRoot, environment)=>{
    return node_path_1.default.join(getWebpackCacheDir(remotionRoot), (0, exports.getWebpackCacheEnvDir)(environment));
};
const remotionCacheLocation = (remotionRoot, environment, hash)=>{
    return node_path_1.default.join(getWebpackCacheDir(remotionRoot), (0, exports.getWebpackCacheName)(environment, hash));
};
const clearCache = (remotionRoot, env)=>{
    return node_fs_1.default.promises.rm(remotionCacheLocationForEnv(remotionRoot, env), {
        recursive: true
    });
};
exports.clearCache = clearCache;
const hasOtherCache = ({ remotionRoot, environment })=>{
    const cacheDir = node_fs_1.default.readdirSync(getWebpackCacheDir(remotionRoot));
    if (cacheDir.find((c)=>{
        return c.startsWith(getPrefix(environment));
    })) {
        return true;
    }
    return false;
};
const cacheExists = (remotionRoot, environment, hash)=>{
    if (node_fs_1.default.existsSync(remotionCacheLocation(remotionRoot, environment, hash))) {
        return 'exists';
    }
    if (!node_fs_1.default.existsSync(getWebpackCacheDir(remotionRoot))) {
        return 'does-not-exist';
    }
    if (hasOtherCache({
        remotionRoot,
        environment
    })) {
        return 'other-exists';
    }
    return 'does-not-exist';
};
exports.cacheExists = cacheExists;
}),
"[project]/node_modules/@remotion/bundler/dist/webpack-config.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.webpackConfig = void 0;
const node_crypto_1 = __turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
const react_dom_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-route] (ecmascript)"));
const no_react_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
const webpack_1 = __importStar(__turbopack_context__.r("[externals]/webpack [external] (webpack, cjs)"));
const case_sensitive_paths_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/case-sensitive-paths.js [app-route] (ecmascript)");
const fast_refresh_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/fast-refresh/index.js [app-route] (ecmascript)");
const hide_expression_dependency_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/hide-expression-dependency.js [app-route] (ecmascript)");
const ignore_packfilecache_warnings_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/ignore-packfilecache-warnings.js [app-route] (ecmascript)");
const optional_dependencies_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/optional-dependencies.js [app-route] (ecmascript)");
const stringify_with_circular_references_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/stringify-with-circular-references.js [app-route] (ecmascript)");
const webpack_cache_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/webpack-cache.js [app-route] (ecmascript)");
const esbuild = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)");
if (!(react_dom_1.default === null || react_dom_1.default === void 0 ? void 0 : react_dom_1.default.version)) {
    throw new Error('Could not find "react-dom" package. Did you install it?');
}
const reactDomVersion = react_dom_1.default.version.split('.')[0];
if (reactDomVersion === '0') {
    throw new Error(`Version ${reactDomVersion} of "react-dom" is not supported by Remotion`);
}
const shouldUseReactDomClient = no_react_1.NoReactInternals.ENABLE_V5_BREAKING_CHANGES ? true : parseInt(reactDomVersion, 10) >= 18;
function truthy(value) {
    return Boolean(value);
}
const webpackConfig = async ({ entry, userDefinedComponent, outDir, environment, webpackOverride = (f)=>f, onProgress, enableCaching = true, maxTimelineTracks, remotionRoot, keyboardShortcutsEnabled, bufferStateDelayInMilliseconds, poll, experimentalClientSideRenderingEnabled })=>{
    const esbuildLoaderOptions = {
        target: 'chrome85',
        loader: 'tsx',
        implementation: esbuild,
        remotionRoot
    };
    let lastProgress = 0;
    const isBun = typeof Bun !== 'undefined';
    const define = new webpack_1.default.DefinePlugin({
        'process.env.MAX_TIMELINE_TRACKS': maxTimelineTracks,
        'process.env.KEYBOARD_SHORTCUTS_ENABLED': keyboardShortcutsEnabled,
        'process.env.BUFFER_STATE_DELAY_IN_MILLISECONDS': bufferStateDelayInMilliseconds,
        'process.env.EXPERIMENTAL_CLIENT_SIDE_RENDERING_ENABLED': experimentalClientSideRenderingEnabled
    });
    const conf = await webpackOverride({
        optimization: {
            minimize: false
        },
        experiments: {
            lazyCompilation: isBun ? false : environment === 'production' ? false : {
                entries: false
            }
        },
        watchOptions: {
            poll: poll !== null && poll !== void 0 ? poll : undefined,
            aggregateTimeout: 0,
            ignored: [
                '**/.git/**',
                '**/.turbo/**',
                '**/node_modules/**'
            ]
        },
        // Higher source map quality in development to power line numbers for stack traces
        devtool: environment === 'development' ? 'source-map' : 'cheap-module-source-map',
        entry: [
            // Fast Refresh must come first,
            // because setup-environment imports ReactDOM.
            // If React DOM is imported before Fast Refresh, Fast Refresh does not work
            environment === 'development' ? "[project]/node_modules/@remotion/bundler/dist/fast-refresh/runtime.js [app-route] (ecmascript)" : null,
            "[project]/node_modules/@remotion/bundler/dist/setup-environment.js [app-route] (ecmascript)",
            userDefinedComponent,
            "[project]/node_modules/@remotion/bundler/react-shim.js [app-route] (ecmascript)",
            entry
        ].filter(Boolean),
        mode: environment,
        plugins: environment === 'development' ? [
            new fast_refresh_1.ReactFreshWebpackPlugin(),
            new case_sensitive_paths_1.CaseSensitivePathsPlugin(),
            new webpack_1.default.HotModuleReplacementPlugin(),
            define,
            new optional_dependencies_1.AllowOptionalDependenciesPlugin(),
            new hide_expression_dependency_1.AllowDependencyExpressionPlugin(),
            new ignore_packfilecache_warnings_1.IgnorePackFileCacheWarningsPlugin()
        ] : [
            new webpack_1.ProgressPlugin((p)=>{
                if (onProgress) {
                    if (p === 1 && p > lastProgress || p - lastProgress > 0.05) {
                        lastProgress = p;
                        onProgress(Number((p * 100).toFixed(2)));
                    }
                }
            }),
            define,
            new optional_dependencies_1.AllowOptionalDependenciesPlugin(),
            new hide_expression_dependency_1.AllowDependencyExpressionPlugin(),
            new ignore_packfilecache_warnings_1.IgnorePackFileCacheWarningsPlugin()
        ],
        output: {
            hashFunction: 'xxhash64',
            filename: no_react_1.NoReactInternals.bundleName,
            devtoolModuleFilenameTemplate: '[resource-path]',
            assetModuleFilename: environment === 'development' ? '[path][name][ext]' : '[hash][ext]'
        },
        resolve: {
            extensions: [
                '.ts',
                '.tsx',
                '.web.js',
                '.js',
                '.jsx',
                '.mjs',
                '.cjs'
            ],
            alias: {
                // Only one version of react
                'react/jsx-runtime': "[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-route] (ecmascript)",
                'react/jsx-dev-runtime': "[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js [app-route] (ecmascript)",
                react: "[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)",
                // Needed to not fail on this: https://github.com/remotion-dev/remotion/issues/5045
                'remotion/no-react': node_path_1.default.resolve("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)", '..', '..', 'esm', 'no-react.mjs'),
                remotion: node_path_1.default.resolve("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)", '..', '..', 'esm', 'index.mjs'),
                '@remotion/media-parser/worker': node_path_1.default.resolve("[project]/node_modules/@remotion/media-parser/dist/index.js [app-route] (ecmascript)", '..', 'esm', 'worker.mjs'),
                // test visual controls before removing this
                '@remotion/studio': "[project]/node_modules/@remotion/studio/dist/index.js [app-route] (ecmascript)",
                'react-dom/client': shouldUseReactDomClient ? "[project]/node_modules/next/dist/compiled/react-dom/client.js [app-route] (ecmascript)" : "[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-route] (ecmascript)"
            }
        },
        module: {
            rules: [
                {
                    test: /\.css$/i,
                    use: [
                        "[project]/node_modules/style-loader/dist/cjs.js [app-route] (ecmascript)",
                        "[project]/node_modules/css-loader/dist/cjs.js [app-route] (ecmascript)"
                    ],
                    type: 'javascript/auto'
                },
                {
                    test: /\.(png|svg|jpg|jpeg|webp|gif|bmp|webm|mp4|mov|mp3|m4a|wav|aac)$/,
                    type: 'asset/resource'
                },
                {
                    test: /\.tsx?$/,
                    use: [
                        {
                            loader: "[project]/node_modules/@remotion/bundler/dist/esbuild-loader/index.js [app-route] (ecmascript)",
                            options: esbuildLoaderOptions
                        },
                        // Keep the order to match babel-loader
                        environment === 'development' ? {
                            loader: "[project]/node_modules/@remotion/bundler/dist/fast-refresh/loader.js [app-route] (ecmascript)"
                        } : null
                    ].filter(truthy)
                },
                {
                    test: /\.(woff(2)?|otf|ttf|eot)(\?v=\d+\.\d+\.\d+)?$/,
                    type: 'asset/resource'
                },
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    use: [
                        {
                            loader: "[project]/node_modules/@remotion/bundler/dist/esbuild-loader/index.js [app-route] (ecmascript)",
                            options: esbuildLoaderOptions
                        },
                        environment === 'development' ? {
                            loader: "[project]/node_modules/@remotion/bundler/dist/fast-refresh/loader.js [app-route] (ecmascript)"
                        } : null
                    ].filter(truthy)
                }
            ]
        }
    });
    const hash = (0, node_crypto_1.createHash)('md5').update((0, stringify_with_circular_references_1.jsonStringifyWithCircularReferences)(conf)).digest('hex');
    return [
        hash,
        {
            ...conf,
            cache: enableCaching ? {
                type: 'filesystem',
                name: (0, webpack_cache_1.getWebpackCacheName)(environment, hash),
                version: hash
            } : false,
            output: {
                ...conf.output,
                ...outDir ? {
                    path: outDir
                } : {}
            },
            context: remotionRoot
        }
    ];
};
exports.webpackConfig = webpackConfig;
}),
"[project]/node_modules/@remotion/bundler/dist/bundle.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.internalBundle = exports.findClosestFolderWithItem = exports.getConfig = void 0;
exports.bundle = bundle;
const studio_shared_1 = __turbopack_context__.r("[project]/node_modules/@remotion/studio-shared/dist/index.js [app-route] (ecmascript)");
const node_fs_1 = __importStar(__turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)"));
const node_os_1 = __importDefault(__turbopack_context__.r("[externals]/node:os [external] (node:os, cjs)"));
const node_path_1 = __importDefault(__turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)"));
const node_util_1 = __turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)");
const node_worker_threads_1 = __turbopack_context__.r("[externals]/node:worker_threads [external] (node:worker_threads, cjs)");
const webpack_1 = __importDefault(__turbopack_context__.r("[externals]/webpack [external] (webpack, cjs)"));
const copy_dir_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/copy-dir.js [app-route] (ecmascript)");
const index_html_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/index-html.js [app-route] (ecmascript)");
const read_recursively_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/read-recursively.js [app-route] (ecmascript)");
const webpack_config_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/webpack-config.js [app-route] (ecmascript)");
const promisified = (0, node_util_1.promisify)(webpack_1.default);
const prepareOutDir = async (specified)=>{
    if (specified) {
        await node_fs_1.default.promises.mkdir(specified, {
            recursive: true
        });
        return specified;
    }
    return node_fs_1.default.promises.mkdtemp(node_path_1.default.join(node_os_1.default.tmpdir(), 'remotion-webpack-bundle-'));
};
const trimLeadingSlash = (p)=>{
    if (p.startsWith('/')) {
        return trimLeadingSlash(p.substr(1));
    }
    return p;
};
const trimTrailingSlash = (p)=>{
    if (p.endsWith('/')) {
        return trimTrailingSlash(p.substr(0, p.length - 1));
    }
    return p;
};
const getConfig = ({ entryPoint, outDir, resolvedRemotionRoot, onProgress, options, bufferStateDelayInMilliseconds, maxTimelineTracks })=>{
    var _a, _b;
    return (0, webpack_config_1.webpackConfig)({
        entry: node_path_1.default.join("[project]/node_modules/@remotion/studio/dist/renderEntry.js [app-route] (ecmascript)", '..', 'esm', 'renderEntry.mjs'),
        userDefinedComponent: entryPoint,
        outDir,
        environment: 'production',
        webpackOverride: (_a = options === null || options === void 0 ? void 0 : options.webpackOverride) !== null && _a !== void 0 ? _a : (f)=>f,
        onProgress: (p)=>{
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(p);
        },
        enableCaching: (_b = options === null || options === void 0 ? void 0 : options.enableCaching) !== null && _b !== void 0 ? _b : true,
        maxTimelineTracks,
        remotionRoot: resolvedRemotionRoot,
        keyboardShortcutsEnabled: true,
        bufferStateDelayInMilliseconds,
        poll: null,
        experimentalClientSideRenderingEnabled: false
    });
};
exports.getConfig = getConfig;
const convertArgumentsIntoOptions = (args)=>{
    var _a;
    if (args.length === 0) {
        throw new TypeError('bundle() was called without arguments');
    }
    const firstArg = args[0];
    if (typeof firstArg === 'string') {
        return {
            entryPoint: firstArg,
            onProgress: args[1],
            ...(_a = args[2]) !== null && _a !== void 0 ? _a : {}
        };
    }
    if (typeof firstArg.entryPoint !== 'string') {
        throw new TypeError('bundle() was called without the `entryPoint` option');
    }
    return firstArg;
};
const recursionLimit = 5;
const findClosestFolderWithItem = (currentDir, file)=>{
    let possibleFile = '';
    for(let i = 0; i < recursionLimit; i++){
        possibleFile = node_path_1.default.join(currentDir, file);
        const exists = node_fs_1.default.existsSync(possibleFile);
        if (exists) {
            return node_path_1.default.dirname(possibleFile);
        }
        currentDir = node_path_1.default.dirname(currentDir);
    }
    return null;
};
exports.findClosestFolderWithItem = findClosestFolderWithItem;
const findClosestPackageJsonFolder = (currentDir)=>{
    return (0, exports.findClosestFolderWithItem)(currentDir, 'package.json');
};
const validateEntryPoint = async (entryPoint)=>{
    const contents = await node_fs_1.promises.readFile(entryPoint, 'utf8');
    if (!contents.includes('registerRoot')) {
        throw new Error([
            `You passed ${entryPoint} as your entry point, but this file does not contain "registerRoot".`,
            'You should use the file that calls registerRoot() as the entry point.',
            'To ignore this error, pass "ignoreRegisterRootWarning" to bundle().',
            'This error cannot be ignored on the CLI.'
        ].join(' '));
    }
};
const internalBundle = async (actualArgs)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const entryPoint = node_path_1.default.resolve(process.cwd(), actualArgs.entryPoint);
    const resolvedRemotionRoot = (_b = (_a = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.rootDir) !== null && _a !== void 0 ? _a : findClosestPackageJsonFolder(entryPoint)) !== null && _b !== void 0 ? _b : process.cwd();
    if (!actualArgs.ignoreRegisterRootWarning) {
        await validateEntryPoint(entryPoint);
    }
    const outDir = await prepareOutDir((_c = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.outDir) !== null && _c !== void 0 ? _c : null);
    (_d = actualArgs.onDirectoryCreated) === null || _d === void 0 ? void 0 : _d.call(actualArgs, outDir);
    // The config might use an override which might use
    // `process.cwd()`. The context should always be the Remotion root.
    // This is not supported in worker threads (used for tests)
    const currentCwd = process.cwd();
    if (node_worker_threads_1.isMainThread) {
        process.chdir(resolvedRemotionRoot);
    }
    const { onProgress, ...options } = actualArgs;
    const [, config] = await (0, exports.getConfig)({
        outDir,
        entryPoint,
        resolvedRemotionRoot,
        onProgress,
        options,
        // Should be null to keep cache hash working
        bufferStateDelayInMilliseconds: (_e = actualArgs.bufferStateDelayInMilliseconds) !== null && _e !== void 0 ? _e : null,
        maxTimelineTracks: (_f = actualArgs.maxTimelineTracks) !== null && _f !== void 0 ? _f : null
    });
    const output = await promisified([
        config
    ]);
    if (node_worker_threads_1.isMainThread) {
        process.chdir(currentCwd);
    }
    if (!output) {
        throw new Error('Expected webpack output');
    }
    const { errors } = output.toJson();
    if (errors !== undefined && errors.length > 0) {
        throw new Error(errors[0].message + '\n' + errors[0].details);
    }
    const publicPath = (_g = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.publicPath) !== null && _g !== void 0 ? _g : '/';
    const staticHash = '/' + [
        trimTrailingSlash(trimLeadingSlash(publicPath)),
        'public'
    ].filter(Boolean).join('/');
    const from = (options === null || options === void 0 ? void 0 : options.publicDir) ? node_path_1.default.resolve(resolvedRemotionRoot, options.publicDir) : node_path_1.default.join(resolvedRemotionRoot, 'public');
    const to = node_path_1.default.join(outDir, 'public');
    let symlinkWarningShown = false;
    const showSymlinkWarning = (ent, src)=>{
        if (symlinkWarningShown) {
            return;
        }
        const absolutePath = node_path_1.default.join(src, ent.name);
        if (options.onSymlinkDetected) {
            options.onSymlinkDetected(absolutePath);
            return;
        }
        symlinkWarningShown = true;
        // eslint-disable-next-line no-console
        console.warn(`\nFound a symbolic link in the public folder (${absolutePath}). The symlink will be forwarded into the bundle.`);
    };
    if (node_fs_1.default.existsSync(from)) {
        await (0, copy_dir_1.copyDir)({
            src: from,
            dest: to,
            onSymlinkDetected: showSymlinkWarning,
            onProgress: (prog)=>{
                var _a;
                return (_a = options.onPublicDirCopyProgress) === null || _a === void 0 ? void 0 : _a.call(options, prog);
            },
            copiedBytes: 0,
            lastReportedProgress: 0
        });
    }
    const html = (0, index_html_1.indexHtml)({
        staticHash,
        publicPath,
        editorName: null,
        inputProps: null,
        remotionRoot: resolvedRemotionRoot,
        studioServerCommand: null,
        renderQueue: null,
        numberOfAudioTags: 0,
        publicFiles: (0, read_recursively_1.readRecursively)({
            folder: '.',
            startPath: from,
            staticHash,
            limit: 10000
        }).map((f)=>{
            return {
                ...f,
                name: f.name.split(node_path_1.default.sep).join('/')
            };
        }),
        includeFavicon: true,
        title: 'Remotion Bundle',
        renderDefaults: undefined,
        publicFolderExists: `${publicPath + (publicPath.endsWith('/') ? '' : '/')}public`,
        gitSource: (_h = actualArgs.gitSource) !== null && _h !== void 0 ? _h : null,
        projectName: (0, studio_shared_1.getProjectName)({
            gitSource: (_j = actualArgs.gitSource) !== null && _j !== void 0 ? _j : null,
            resolvedRemotionRoot,
            basename: node_path_1.default.basename
        }),
        installedDependencies: null,
        packageManager: 'unknown',
        // Actual log level is set in setPropsAndEnv()
        logLevel: 'info',
        mode: 'bundle',
        audioLatencyHint: (_k = actualArgs.audioLatencyHint) !== null && _k !== void 0 ? _k : 'interactive'
    });
    node_fs_1.default.writeFileSync(node_path_1.default.join(outDir, 'index.html'), html);
    node_fs_1.default.copyFileSync(node_path_1.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/@remotion/bundler/dist"), '../favicon.ico'), node_path_1.default.join(outDir, 'favicon.ico'));
    node_fs_1.default.copyFileSync(node_path_1.default.resolve("[project]/node_modules/@remotion/bundler/node_modules/source-map/source-map.js [app-route] (ecmascript)", '..', 'lib', 'mappings.wasm'), node_path_1.default.join(outDir, studio_shared_1.SOURCE_MAP_ENDPOINT.replace('/', '')));
    return outDir;
};
exports.internalBundle = internalBundle;
/*
 * @description Bundles a Remotion project using Webpack and prepares it for rendering.
 * @see [Documentation](https://remotion.dev/docs/bundle)
 */ async function bundle(...args) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const actualArgs = convertArgumentsIntoOptions(args);
    const result = await (0, exports.internalBundle)({
        bufferStateDelayInMilliseconds: (_a = actualArgs.bufferStateDelayInMilliseconds) !== null && _a !== void 0 ? _a : null,
        enableCaching: (_b = actualArgs.enableCaching) !== null && _b !== void 0 ? _b : true,
        entryPoint: actualArgs.entryPoint,
        gitSource: (_c = actualArgs.gitSource) !== null && _c !== void 0 ? _c : null,
        ignoreRegisterRootWarning: (_d = actualArgs.ignoreRegisterRootWarning) !== null && _d !== void 0 ? _d : false,
        maxTimelineTracks: (_e = actualArgs.maxTimelineTracks) !== null && _e !== void 0 ? _e : null,
        onDirectoryCreated: (_f = actualArgs.onDirectoryCreated) !== null && _f !== void 0 ? _f : ()=>{},
        onProgress: (_g = actualArgs.onProgress) !== null && _g !== void 0 ? _g : ()=>{},
        onPublicDirCopyProgress: (_h = actualArgs.onPublicDirCopyProgress) !== null && _h !== void 0 ? _h : ()=>{},
        onSymlinkDetected: (_j = actualArgs.onSymlinkDetected) !== null && _j !== void 0 ? _j : ()=>{},
        outDir: (_k = actualArgs.outDir) !== null && _k !== void 0 ? _k : null,
        publicDir: (_l = actualArgs.publicDir) !== null && _l !== void 0 ? _l : null,
        publicPath: (_m = actualArgs.publicPath) !== null && _m !== void 0 ? _m : null,
        rootDir: (_o = actualArgs.rootDir) !== null && _o !== void 0 ? _o : null,
        webpackOverride: (_p = actualArgs.webpackOverride) !== null && _p !== void 0 ? _p : (f)=>f,
        audioLatencyHint: (_q = actualArgs.audioLatencyHint) !== null && _q !== void 0 ? _q : null
    });
    return result;
}
}),
"[project]/node_modules/@remotion/bundler/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.webpack = exports.bundle = exports.BundlerInternals = void 0;
const bundle_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/bundle.js [app-route] (ecmascript)");
const index_html_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/index-html.js [app-route] (ecmascript)");
const read_recursively_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/read-recursively.js [app-route] (ecmascript)");
const webpack_cache_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/webpack-cache.js [app-route] (ecmascript)");
const webpack_config_1 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/webpack-config.js [app-route] (ecmascript)");
const esbuild = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)");
const webpack = __turbopack_context__.r("[externals]/webpack [external] (webpack, cjs)");
exports.webpack = webpack;
exports.BundlerInternals = {
    esbuild,
    webpackConfig: webpack_config_1.webpackConfig,
    indexHtml: index_html_1.indexHtml,
    cacheExists: webpack_cache_1.cacheExists,
    clearCache: webpack_cache_1.clearCache,
    getConfig: bundle_1.getConfig,
    readRecursively: read_recursively_1.readRecursively,
    findClosestFolderWithItem: bundle_1.findClosestFolderWithItem,
    internalBundle: bundle_1.internalBundle
};
var bundle_2 = __turbopack_context__.r("[project]/node_modules/@remotion/bundler/dist/bundle.js [app-route] (ecmascript)");
Object.defineProperty(exports, "bundle", {
    enumerable: true,
    get: function() {
        return bundle_2.bundle;
    }
});
}),
"[project]/node_modules/react-refresh/cjs/react-refresh-runtime.development.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @license React v0.9.0
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // ATTENTION
        // When adding new symbols to this file,
        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var REACT_ELEMENT_TYPE = 0xeac7;
        var REACT_PORTAL_TYPE = 0xeaca;
        var REACT_FRAGMENT_TYPE = 0xeacb;
        var REACT_STRICT_MODE_TYPE = 0xeacc;
        var REACT_PROFILER_TYPE = 0xead2;
        var REACT_PROVIDER_TYPE = 0xeacd;
        var REACT_CONTEXT_TYPE = 0xeace;
        var REACT_FORWARD_REF_TYPE = 0xead0;
        var REACT_SUSPENSE_TYPE = 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = 0xead8;
        var REACT_MEMO_TYPE = 0xead3;
        var REACT_LAZY_TYPE = 0xead4;
        var REACT_BLOCK_TYPE = 0xead9;
        var REACT_SERVER_BLOCK_TYPE = 0xeada;
        var REACT_FUNDAMENTAL_TYPE = 0xead5;
        var REACT_SCOPE_TYPE = 0xead7;
        var REACT_OPAQUE_ID_TYPE = 0xeae0;
        var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
        var REACT_OFFSCREEN_TYPE = 0xeae2;
        var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
        if (typeof Symbol === 'function' && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor('react.element');
            REACT_PORTAL_TYPE = symbolFor('react.portal');
            REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
            REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
            REACT_PROFILER_TYPE = symbolFor('react.profiler');
            REACT_PROVIDER_TYPE = symbolFor('react.provider');
            REACT_CONTEXT_TYPE = symbolFor('react.context');
            REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
            REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
            REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
            REACT_MEMO_TYPE = symbolFor('react.memo');
            REACT_LAZY_TYPE = symbolFor('react.lazy');
            REACT_BLOCK_TYPE = symbolFor('react.block');
            REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
            REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
            REACT_SCOPE_TYPE = symbolFor('react.scope');
            REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
            REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
            REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
        }
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
        // It's OK to reference families, but use WeakMap/Set for types.
        var allFamiliesByID = new Map();
        var allFamiliesByType = new PossiblyWeakMap();
        var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
        // that have actually been edited here. This keeps checks fast.
        // $FlowIssue
        var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
        // It is an array of [Family, NextType] tuples.
        var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
        var helpersByRendererID = new Map();
        var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
        var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
        var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
        // It needs to be weak because we do this even for roots that failed to mount.
        // If there is no WeakMap, we won't attempt to do retrying.
        // $FlowIssue
        var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;
        var isPerformingRefresh = false;
        function computeFullKey(signature) {
            if (signature.fullKey !== null) {
                return signature.fullKey;
            }
            var fullKey = signature.ownKey;
            var hooks;
            try {
                hooks = signature.getCustomHooks();
            } catch (err) {
                // This can happen in an edge case, e.g. if expression like Foo.useSomething
                // depends on Foo which is lazily initialized during rendering.
                // In that case just assume we'll have to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            for(var i = 0; i < hooks.length; i++){
                var hook = hooks[i];
                if (typeof hook !== 'function') {
                    // Something's wrong. Assume we need to remount.
                    signature.forceReset = true;
                    signature.fullKey = fullKey;
                    return fullKey;
                }
                var nestedHookSignature = allSignaturesByType.get(hook);
                if (nestedHookSignature === undefined) {
                    continue;
                }
                var nestedHookKey = computeFullKey(nestedHookSignature);
                if (nestedHookSignature.forceReset) {
                    signature.forceReset = true;
                }
                fullKey += '\n---\n' + nestedHookKey;
            }
            signature.fullKey = fullKey;
            return fullKey;
        }
        function haveEqualSignatures(prevType, nextType) {
            var prevSignature = allSignaturesByType.get(prevType);
            var nextSignature = allSignaturesByType.get(nextType);
            if (prevSignature === undefined && nextSignature === undefined) {
                return true;
            }
            if (prevSignature === undefined || nextSignature === undefined) {
                return false;
            }
            if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
                return false;
            }
            if (nextSignature.forceReset) {
                return false;
            }
            return true;
        }
        function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
        }
        function canPreserveStateBetween(prevType, nextType) {
            if (isReactClass(prevType) || isReactClass(nextType)) {
                return false;
            }
            if (haveEqualSignatures(prevType, nextType)) {
                return true;
            }
            return false;
        }
        function resolveFamily(type) {
            // Only check updated types to keep lookups fast.
            return updatedFamiliesByType.get(type);
        } // If we didn't care about IE11, we could use new Map/Set(iterable).
        function cloneMap(map) {
            var clone = new Map();
            map.forEach(function(value, key) {
                clone.set(key, value);
            });
            return clone;
        }
        function cloneSet(set) {
            var clone = new Set();
            set.forEach(function(value) {
                clone.add(value);
            });
            return clone;
        }
        function performReactRefresh() {
            if (pendingUpdates.length === 0) {
                return null;
            }
            if (isPerformingRefresh) {
                return null;
            }
            isPerformingRefresh = true;
            try {
                var staleFamilies = new Set();
                var updatedFamilies = new Set();
                var updates = pendingUpdates;
                pendingUpdates = [];
                updates.forEach(function(_ref) {
                    var family = _ref[0], nextType = _ref[1];
                    // Now that we got a real edit, we can create associations
                    // that will be read by the React reconciler.
                    var prevType = family.current;
                    updatedFamiliesByType.set(prevType, family);
                    updatedFamiliesByType.set(nextType, family);
                    family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                    if (canPreserveStateBetween(prevType, nextType)) {
                        updatedFamilies.add(family);
                    } else {
                        staleFamilies.add(family);
                    }
                }); // TODO: rename these fields to something more meaningful.
                var update = {
                    updatedFamilies: updatedFamilies,
                    // Families that will re-render preserving state
                    staleFamilies: staleFamilies // Families that will be remounted
                };
                helpersByRendererID.forEach(function(helpers) {
                    // Even if there are no roots, set the handler on first update.
                    // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                    helpers.setRefreshHandler(resolveFamily);
                });
                var didError = false;
                var firstError = null; // We snapshot maps and sets that are mutated during commits.
                // If we don't do this, there is a risk they will be mutated while
                // we iterate over them. For example, trying to recover a failed root
                // may cause another root to be added to the failed list -- an infinite loop.
                var failedRootsSnapshot = cloneSet(failedRoots);
                var mountedRootsSnapshot = cloneSet(mountedRoots);
                var helpersByRootSnapshot = cloneMap(helpersByRoot);
                failedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!failedRoots.has(root)) {}
                    if (rootElements === null) {
                        return;
                    }
                    if (!rootElements.has(root)) {
                        return;
                    }
                    var element = rootElements.get(root);
                    try {
                        helpers.scheduleRoot(root, element);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                mountedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!mountedRoots.has(root)) {}
                    try {
                        helpers.scheduleRefresh(root, update);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                if (didError) {
                    throw firstError;
                }
                return update;
            } finally{
                isPerformingRefresh = false;
            }
        }
        function register(type, id) {
            {
                if (type === null) {
                    return;
                }
                if (typeof type !== 'function' && typeof type !== 'object') {
                    return;
                } // This can happen in an edge case, e.g. if we register
                // return value of a HOC but it returns a cached component.
                // Ignore anything but the first registration for each type.
                if (allFamiliesByType.has(type)) {
                    return;
                } // Create family or remember to update it.
                // None of this bookkeeping affects reconciliation
                // until the first performReactRefresh() call above.
                var family = allFamiliesByID.get(id);
                if (family === undefined) {
                    family = {
                        current: type
                    };
                    allFamiliesByID.set(id, family);
                } else {
                    pendingUpdates.push([
                        family,
                        type
                    ]);
                }
                allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
                if (typeof type === 'object' && type !== null) {
                    switch(type.$$typeof){
                        case REACT_FORWARD_REF_TYPE:
                            register(type.render, id + '$render');
                            break;
                        case REACT_MEMO_TYPE:
                            register(type.type, id + '$type');
                            break;
                    }
                }
            }
        }
        function setSignature(type, key) {
            var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
            {
                allSignaturesByType.set(type, {
                    forceReset: forceReset,
                    ownKey: key,
                    fullKey: null,
                    getCustomHooks: getCustomHooks || function() {
                        return [];
                    }
                });
            }
        } // This is lazily called during first render for a type.
        // It captures Hook list at that time so inline requires don't break comparisons.
        function collectCustomHooksForSignature(type) {
            {
                var signature = allSignaturesByType.get(type);
                if (signature !== undefined) {
                    computeFullKey(signature);
                }
            }
        }
        function getFamilyByID(id) {
            {
                return allFamiliesByID.get(id);
            }
        }
        function getFamilyByType(type) {
            {
                return allFamiliesByType.get(type);
            }
        }
        function findAffectedHostInstances(families) {
            {
                var affectedInstances = new Set();
                mountedRoots.forEach(function(root) {
                    var helpers = helpersByRoot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
                    instancesForRoot.forEach(function(inst) {
                        affectedInstances.add(inst);
                    });
                });
                return affectedInstances;
            }
        }
        function injectIntoGlobalHook(globalObject) {
            {
                // For React Native, the global hook will be set up by require('react-devtools-core').
                // That code will run before us. So we need to monkeypatch functions on existing hook.
                // For React Web, the global hook will be set up by the extension.
                // This will also run before us.
                var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (hook === undefined) {
                    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
                    // Note that in this case it's important that renderer code runs *after* this method call.
                    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
                    var nextID = 0;
                    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                        renderers: new Map(),
                        supportsFiber: true,
                        inject: function(injected) {
                            return nextID++;
                        },
                        onScheduleFiberRoot: function(id, root, children) {},
                        onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},
                        onCommitFiberUnmount: function() {}
                    };
                } // Here, we just want to get a reference to scheduleRefresh.
                var oldInject = hook.inject;
                hook.inject = function(injected) {
                    var id = oldInject.apply(this, arguments);
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                    return id;
                }; // Do the same for any already injected roots.
                // This is useful if ReactDOM has already been initialized.
                // https://github.com/facebook/react/issues/17626
                hook.renderers.forEach(function(injected, id) {
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                }); // We also want to track currently mounted roots.
                var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
                var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};
                hook.onScheduleFiberRoot = function(id, root, children) {
                    if (!isPerformingRefresh) {
                        // If it was intentionally scheduled, don't attempt to restore.
                        // This includes intentionally scheduled unmounts.
                        failedRoots.delete(root);
                        if (rootElements !== null) {
                            rootElements.set(root, children);
                        }
                    }
                    return oldOnScheduleFiberRoot.apply(this, arguments);
                };
                hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
                    var helpers = helpersByRendererID.get(id);
                    if (helpers === undefined) {
                        return;
                    }
                    helpersByRoot.set(root, helpers);
                    var current = root.current;
                    var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
                    // This logic is copy-pasted from similar logic in the DevTools backend.
                    // If this breaks with some refactoring, you'll want to update DevTools too.
                    if (alternate !== null) {
                        var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
                        var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                        if (!wasMounted && isMounted) {
                            // Mount a new root.
                            mountedRoots.add(root);
                            failedRoots.delete(root);
                        } else if (wasMounted && isMounted) ;
                        else if (wasMounted && !isMounted) {
                            // Unmount an existing root.
                            mountedRoots.delete(root);
                            if (didError) {
                                // We'll remount it on future edits.
                                failedRoots.add(root);
                            } else {
                                helpersByRoot.delete(root);
                            }
                        } else if (!wasMounted && !isMounted) {
                            if (didError) {
                                // We'll remount it on future edits.
                                failedRoots.add(root);
                            }
                        }
                    } else {
                        // Mount a new root.
                        mountedRoots.add(root);
                    }
                    return oldOnCommitFiberRoot.apply(this, arguments);
                };
            }
        }
        function hasUnrecoverableErrors() {
            // TODO: delete this after removing dependency in RN.
            return false;
        } // Exposed for testing.
        function _getMountedRootCount() {
            {
                return mountedRoots.size;
            }
        } // This is a wrapper over more primitive functions for setting signature.
        // Signatures let us decide whether the Hook order has changed on refresh.
        //
        // This function is intended to be used as a transform target, e.g.:
        // var _s = createSignatureFunctionForTransform()
        //
        // function Hello() {
        //   const [foo, setFoo] = useState(0);
        //   const value = useCustomHook();
        //   _s(); /* Second call triggers collecting the custom Hook list.
        //          * This doesn't happen during the module evaluation because we
        //          * don't want to change the module order with inline requires.
        //          * Next calls are noops. */
        //   return <h1>Hi</h1>;
        // }
        //
        // /* First call specifies the signature: */
        // _s(
        //   Hello,
        //   'useState{[foo, setFoo]}(0)',
        //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
        // );
        function createSignatureFunctionForTransform() {
            {
                // We'll fill in the signature in two steps.
                // First, we'll know the signature itself. This happens outside the component.
                // Then, we'll know the references to custom Hooks. This happens inside the component.
                // After that, the returned function will be a fast path no-op.
                var status = 'needsSignature';
                var savedType;
                var hasCustomHooks;
                return function(type, key, forceReset, getCustomHooks) {
                    switch(status){
                        case 'needsSignature':
                            if (type !== undefined) {
                                // If we received an argument, this is the initial registration call.
                                savedType = type;
                                hasCustomHooks = typeof getCustomHooks === 'function';
                                setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.
                                status = 'needsCustomHooks';
                            }
                            break;
                        case 'needsCustomHooks':
                            if (hasCustomHooks) {
                                collectCustomHooksForSignature(savedType);
                            }
                            status = 'resolved';
                            break;
                    }
                    return type;
                };
            }
        }
        function isLikelyComponentType(type) {
            {
                switch(typeof type){
                    case 'function':
                        {
                            // First, deal with classes.
                            if (type.prototype != null) {
                                if (type.prototype.isReactComponent) {
                                    // React class.
                                    return true;
                                }
                                var ownNames = Object.getOwnPropertyNames(type.prototype);
                                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                                    // This looks like a class.
                                    return false;
                                } // eslint-disable-next-line no-proto
                                if (type.prototype.__proto__ !== Object.prototype) {
                                    // It has a superclass.
                                    return false;
                                } // Pass through.
                            // This looks like a regular function with empty prototype.
                            } // For plain functions and arrows, use name as a heuristic.
                            var name = type.name || type.displayName;
                            return typeof name === 'string' && /^[A-Z]/.test(name);
                        }
                    case 'object':
                        {
                            if (type != null) {
                                switch(type.$$typeof){
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_MEMO_TYPE:
                                        // Definitely React components.
                                        return true;
                                    default:
                                        return false;
                                }
                            }
                            return false;
                        }
                    default:
                        {
                            return false;
                        }
                }
            }
        }
        exports._getMountedRootCount = _getMountedRootCount;
        exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
        exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
        exports.findAffectedHostInstances = findAffectedHostInstances;
        exports.getFamilyByID = getFamilyByID;
        exports.getFamilyByType = getFamilyByType;
        exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
        exports.injectIntoGlobalHook = injectIntoGlobalHook;
        exports.isLikelyComponentType = isLikelyComponentType;
        exports.performReactRefresh = performReactRefresh;
        exports.register = register;
        exports.setSignature = setSignature;
    })();
}
}),
"[project]/node_modules/react-refresh/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react-refresh/cjs/react-refresh-runtime.development.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/@remotion/studio/node_modules/@remotion/zod-types/dist/esm/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/z-color.ts
__turbopack_context__.s([
    "ZodZypesInternals",
    ()=>ZodZypesInternals,
    "zColor",
    ()=>zColor,
    "zMatrix",
    ()=>zMatrix,
    "zTextarea",
    ()=>zTextarea
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$no$2d$react$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$studio$2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/studio/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
;
;
var REMOTION_COLOR_BRAND = "__remotion-color";
var parseColor = (value)=>{
    const colored = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$no$2d$react$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoReactInternals"].processColor(value).toString(16).padStart(8, "0");
    const opacity = parseInt(colored.slice(0, 2), 16);
    const r = parseInt(colored.slice(2, 4), 16);
    const g = parseInt(colored.slice(4, 6), 16);
    const b = parseInt(colored.slice(6, 8), 16);
    return {
        a: opacity,
        r,
        g,
        b
    };
};
var zColor = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$studio$2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().refine((value)=>{
        try {
            parseColor(value);
            return true;
        } catch  {
            return false;
        }
    }, {
        message: "Invalid color"
    }).describe(REMOTION_COLOR_BRAND);
;
var REMOTION_MATRIX_BRAND = "__remotion-matrix";
var zMatrix = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$studio$2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$studio$2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].number().step(0.01)).refine((value)=>{
        const count = value.length;
        const root = Math.sqrt(count);
        return Number.isInteger(root) && root > 0;
    }, {
        message: "Invalid matrix, must be a square matrix"
    }).describe(REMOTION_MATRIX_BRAND);
;
var REMOTION_TEXTAREA_BRAND = "__remotion-textarea";
var zTextarea = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$studio$2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().describe(REMOTION_TEXTAREA_BRAND);
// src/index.ts
var ZodZypesInternals = {
    parseColor,
    REMOTION_COLOR_BRAND,
    REMOTION_TEXTAREA_BRAND,
    REMOTION_MATRIX_BRAND
};
;
}),
"[project]/node_modules/style-loader/dist/runtime/isEqualLocals.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    var p;
    for(p in a){
        if (isNamedExport && p === "default") {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === "default") {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
}
module.exports = isEqualLocals;
}),
"[project]/node_modules/style-loader/dist/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getExportLazyStyleCode = getExportLazyStyleCode;
exports.getExportStyleCode = getExportStyleCode;
exports.getImportInsertBySelectorCode = getImportInsertBySelectorCode;
exports.getImportInsertStyleElementCode = getImportInsertStyleElementCode;
exports.getImportIsOldIECode = getImportIsOldIECode;
exports.getImportLinkAPICode = getImportLinkAPICode;
exports.getImportLinkContentCode = getImportLinkContentCode;
exports.getImportStyleAPICode = getImportStyleAPICode;
exports.getImportStyleContentCode = getImportStyleContentCode;
exports.getImportStyleDomAPICode = getImportStyleDomAPICode;
exports.getInsertOptionCode = getInsertOptionCode;
exports.getLinkHmrCode = getLinkHmrCode;
exports.getSetAttributesCode = getSetAttributesCode;
exports.getStyleHmrCode = getStyleHmrCode;
exports.getStyleTagTransformFn = getStyleTagTransformFn;
exports.getStyleTagTransformFnCode = getStyleTagTransformFnCode;
exports.getdomAPI = getdomAPI;
exports.stringifyRequest = stringifyRequest;
var _path = _interopRequireDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var _isEqualLocals = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/style-loader/dist/runtime/isEqualLocals.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function stringifyRequest(loaderContext, request) {
    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context, request));
}
function getImportLinkAPICode(esModule, loaderContext) {
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/injectStylesIntoLinkTag.js")}`);
    return esModule ? `import API from ${modulePath};` : `var API = require(${modulePath});`;
}
function getImportLinkContentCode(esModule, loaderContext, request) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return esModule ? `import content from ${modulePath};` : `var content = require(${modulePath});`;
}
function getImportStyleAPICode(esModule, loaderContext) {
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/injectStylesIntoStyleTag.js")}`);
    return esModule ? `import API from ${modulePath};` : `var API = require(${modulePath});`;
}
function getImportStyleDomAPICode(esModule, loaderContext, isSingleton, isAuto) {
    const styleAPI = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/styleDomAPI.js")}`);
    const singletonAPI = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/singletonStyleDomAPI.js")}`);
    if (isAuto) {
        return esModule ? `import domAPI from ${styleAPI};
        import domAPISingleton from ${singletonAPI};` : `var domAPI = require(${styleAPI});
        var domAPISingleton = require(${singletonAPI});`;
    }
    return esModule ? `import domAPI from ${isSingleton ? singletonAPI : styleAPI};` : `var domAPI = require(${isSingleton ? singletonAPI : styleAPI});`;
}
function getImportStyleContentCode(esModule, loaderContext, request) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return esModule ? `import content, * as namedExport from ${modulePath};` : `var content = require(${modulePath});`;
}
function getImportInsertBySelectorCode(esModule, loaderContext, insertType, options) {
    if (insertType === "module-path") {
        const modulePath = stringifyRequest(loaderContext, `${options.insert}`);
        loaderContext.addBuildDependency(options.insert);
        return esModule ? `import insertFn from ${modulePath};` : `var insertFn = require(${modulePath});`;
    }
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/insertBySelector.js")}`);
    return esModule ? `import insertFn from ${modulePath};` : `var insertFn = require(${modulePath});`;
}
function getInsertOptionCode(insertType, options) {
    if (insertType === "module-path") {
        return `options.insert = insertFn;`;
    }
    const insert = options.insert ? JSON.stringify(options.insert) : '"head"';
    return `options.insert = insertFn.bind(null, ${insert});`;
}
function getImportInsertStyleElementCode(esModule, loaderContext) {
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/insertStyleElement.js")}`);
    return esModule ? `import insertStyleElement from ${modulePath};` : `var insertStyleElement = require(${modulePath});`;
}
function getStyleHmrCode(esModule, loaderContext, request, lazy) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return `
if (module.hot) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = ${_isEqualLocals.default.toString()};
    var isNamedExport = ${esModule ? "!content.locals" : false};
    var oldLocals = isNamedExport ? namedExport : content.locals;

    module.hot.accept(
      ${modulePath},
      function () {
        ${esModule ? `if (!isEqualLocals(oldLocals, isNamedExport ? namedExport : content.locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? namedExport : content.locals;

              ${lazy ? `if (update && refs > 0) {
                      update(content);
                    }` : `update(content);`}` : `content = require(${modulePath});

              content = content.__esModule ? content.default : content;

              ${lazy ? "" : `if (typeof content === 'string') {
                      content = [[module.id, content, '']];
                    }`}

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              ${lazy ? `if (update && refs > 0) {
                        update(content);
                      }` : `update(content);`}`}
      }
    )
  }

  module.hot.dispose(function() {
    ${lazy ? `if (update) {
            update();
          }` : `update();`}
  });
}
`;
}
function getLinkHmrCode(esModule, loaderContext, request) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return `
if (module.hot) {
  module.hot.accept(
    ${modulePath},
    function() {
     ${esModule ? "update(content);" : `content = require(${modulePath});

           content = content.__esModule ? content.default : content;

           update(content);`}
    }
  );

  module.hot.dispose(function() {
    update();
  });
}`;
}
function getdomAPI(isAuto) {
    return isAuto ? "isOldIE() ? domAPISingleton : domAPI" : "domAPI";
}
function getImportIsOldIECode(esModule, loaderContext) {
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/isOldIE.js")}`);
    return esModule ? `import isOldIE from ${modulePath};` : `var isOldIE = require(${modulePath});`;
}
function getStyleTagTransformFnCode(esModule, loaderContext, options, isSingleton) {
    if (isSingleton) {
        return "";
    }
    if (typeof options.styleTagTransform !== "undefined") {
        const modulePath = stringifyRequest(loaderContext, `${options.styleTagTransform}`);
        loaderContext.addBuildDependency(options.styleTagTransform);
        return esModule ? `import styleTagTransformFn from ${modulePath};` : `var styleTagTransformFn = require(${modulePath});`;
    }
    const modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/styleTagTransform.js")}`);
    return esModule ? `import styleTagTransformFn from ${modulePath};` : `var styleTagTransformFn = require(${modulePath});`;
}
function getStyleTagTransformFn(options, isSingleton) {
    return isSingleton ? "" : `options.styleTagTransform = styleTagTransformFn`;
}
function getExportStyleCode(esModule, loaderContext, request) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return esModule ? `export * from ${modulePath};
       export default content && content.locals ? content.locals : undefined;` : "module.exports = content && content.locals || {};";
}
function getExportLazyStyleCode(esModule, loaderContext, request) {
    const modulePath = stringifyRequest(loaderContext, `!!${request}`);
    return esModule ? `export * from ${modulePath};
       export default exported;` : "module.exports = exported;";
}
function getSetAttributesCode(esModule, loaderContext, options) {
    let modulePath;
    if (typeof options.attributes !== "undefined") {
        modulePath = options.attributes.nonce !== "undefined" ? stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/setAttributesWithAttributesAndNonce.js")}`) : stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/setAttributesWithAttributes.js")}`);
    } else {
        modulePath = stringifyRequest(loaderContext, `!${_path.default.join(("TURBOPACK compile-time value", "/ROOT/node_modules/style-loader/dist"), "runtime/setAttributesWithoutAttributes.js")}`);
    }
    return esModule ? `import setAttributes from ${modulePath};` : `var setAttributes = require(${modulePath});`;
} // eslint-disable-next-line import/prefer-default-export
}),
"[project]/node_modules/style-loader/dist/options.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"title\":\"Style Loader options\",\"type\":\"object\",\"properties\":{\"injectType\":{\"description\":\"Allows to setup how styles will be injected into DOM.\",\"link\":\"https://github.com/webpack-contrib/style-loader#injecttype\",\"enum\":[\"styleTag\",\"singletonStyleTag\",\"autoStyleTag\",\"lazyStyleTag\",\"lazySingletonStyleTag\",\"lazyAutoStyleTag\",\"linkTag\"]},\"attributes\":{\"description\":\"Adds custom attributes to tag.\",\"link\":\"https://github.com/webpack-contrib/style-loader#attributes\",\"type\":\"object\"},\"insert\":{\"description\":\"Inserts `<style>`/`<link>` at the given position.\",\"link\":\"https://github.com/webpack-contrib/style-loader#insert\",\"type\":\"string\"},\"base\":{\"description\":\"Sets module ID base for DLLPlugin.\",\"link\":\"https://github.com/webpack-contrib/style-loader#base\",\"type\":\"number\"},\"esModule\":{\"description\":\"Use the ES modules syntax.\",\"link\":\"https://github.com/webpack-contrib/css-loader#esmodule\",\"type\":\"boolean\"},\"styleTagTransform\":{\"description\":\"Transform tag and css when insert 'style' tag into the DOM\",\"link\":\"https://github.com/webpack-contrib/style-loader#styleTagTransform\",\"type\":\"string\"}},\"additionalProperties\":false}"));}),
"[project]/node_modules/style-loader/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var _utils = __turbopack_context__.r("[project]/node_modules/style-loader/dist/utils.js [app-route] (ecmascript)");
var _options = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/style-loader/dist/options.json (json)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// eslint-disable-next-line consistent-return
const loader = function loader(content) {
    if (this._compiler && this._compiler.options && this._compiler.options.experiments && this._compiler.options.experiments.css && this._module && (this._module.type === "css" || this._module.type === "css/global" || this._module.type === "css/module" || this._module.type === "css/auto")) {
        return content;
    }
};
loader.pitch = function pitch(request) {
    if (this._compiler && this._compiler.options && this._compiler.options.experiments && this._compiler.options.experiments.css && this._module && (this._module.type === "css" || this._module.type === "css/global" || this._module.type === "css/module" || this._module.type === "css/auto")) {
        this.emitWarning(new Error('You can\'t use `experiments.css` (`experiments.futureDefaults` enable built-in CSS support by default) and `style-loader` together, please set `experiments.css` to `false` or set `{ type: "javascript/auto" }` for rules with `style-loader` in your webpack config (now `style-loader` does nothing).'));
        return;
    }
    const options = this.getOptions(_options.default);
    const injectType = options.injectType || "styleTag";
    const esModule = typeof options.esModule !== "undefined" ? options.esModule : true;
    const runtimeOptions = {};
    if (options.attributes) {
        runtimeOptions.attributes = options.attributes;
    }
    if (options.base) {
        runtimeOptions.base = options.base;
    }
    const insertType = options.insert && _path.default.isAbsolute(options.insert) ? "module-path" : "selector";
    switch(injectType){
        case "linkTag":
            {
                const hmrCode = this.hot ? (0, _utils.getLinkHmrCode)(esModule, this, request) : "";
                // eslint-disable-next-line consistent-return
                return `
      ${(0, _utils.getImportLinkAPICode)(esModule, this)}
      ${(0, _utils.getImportInsertBySelectorCode)(esModule, this, insertType, options)}
      ${(0, _utils.getImportLinkContentCode)(esModule, this, request)}
      ${esModule ? "" : `content = content.__esModule ? content.default : content;`}

var options = ${JSON.stringify(runtimeOptions)};

${(0, _utils.getInsertOptionCode)(insertType, options)}

var update = API(content, options);

${hmrCode}

${esModule ? "export default {}" : ""}`;
            }
        case "lazyStyleTag":
        case "lazyAutoStyleTag":
        case "lazySingletonStyleTag":
            {
                const isSingleton = injectType === "lazySingletonStyleTag";
                const isAuto = injectType === "lazyAutoStyleTag";
                const hmrCode = this.hot ? (0, _utils.getStyleHmrCode)(esModule, this, request, true) : "";
                // eslint-disable-next-line consistent-return
                return `
      var exported = {};

      ${(0, _utils.getImportStyleAPICode)(esModule, this)}
      ${(0, _utils.getImportStyleDomAPICode)(esModule, this, isSingleton, isAuto)}
      ${(0, _utils.getImportInsertBySelectorCode)(esModule, this, insertType, options)}
      ${(0, _utils.getSetAttributesCode)(esModule, this, options)}
      ${(0, _utils.getImportInsertStyleElementCode)(esModule, this)}
      ${(0, _utils.getStyleTagTransformFnCode)(esModule, this, options, isSingleton)}
      ${(0, _utils.getImportStyleContentCode)(esModule, this, request)}
      ${isAuto ? (0, _utils.getImportIsOldIECode)(esModule, this) : ""}
      ${esModule ? `if (content && content.locals) {
              exported.locals = content.locals;
            }
            ` : `content = content.__esModule ? content.default : content;

            exported.locals = content.locals || {};`}

var refs = 0;
var update;
var options = ${JSON.stringify(runtimeOptions)};

${(0, _utils.getStyleTagTransformFn)(options, isSingleton)};
options.setAttributes = setAttributes;
${(0, _utils.getInsertOptionCode)(insertType, options)}
options.domAPI = ${(0, _utils.getdomAPI)(isAuto)};
options.insertStyleElement = insertStyleElement;

exported.use = function(insertOptions) {
  options.options = insertOptions || {};

  if (!(refs++)) {
    update = API(content, options);
  }

  return exported;
};
exported.unuse = function() {
  if (refs > 0 && !--refs) {
    update();
    update = null;
  }
};

${hmrCode}

${(0, _utils.getExportLazyStyleCode)(esModule, this, request)}
`;
            }
        case "styleTag":
        case "autoStyleTag":
        case "singletonStyleTag":
        default:
            {
                const isSingleton = injectType === "singletonStyleTag";
                const isAuto = injectType === "autoStyleTag";
                const hmrCode = this.hot ? (0, _utils.getStyleHmrCode)(esModule, this, request, false) : "";
                // eslint-disable-next-line consistent-return
                return `
      ${(0, _utils.getImportStyleAPICode)(esModule, this)}
      ${(0, _utils.getImportStyleDomAPICode)(esModule, this, isSingleton, isAuto)}
      ${(0, _utils.getImportInsertBySelectorCode)(esModule, this, insertType, options)}
      ${(0, _utils.getSetAttributesCode)(esModule, this, options)}
      ${(0, _utils.getImportInsertStyleElementCode)(esModule, this)}
      ${(0, _utils.getStyleTagTransformFnCode)(esModule, this, options, isSingleton)}
      ${(0, _utils.getImportStyleContentCode)(esModule, this, request)}
      ${isAuto ? (0, _utils.getImportIsOldIECode)(esModule, this) : ""}
      ${esModule ? "" : `content = content.__esModule ? content.default : content;`}

var options = ${JSON.stringify(runtimeOptions)};

${(0, _utils.getStyleTagTransformFn)(options, isSingleton)};
options.setAttributes = setAttributes;
${(0, _utils.getInsertOptionCode)(insertType, options)}
options.domAPI = ${(0, _utils.getdomAPI)(isAuto)};
options.insertStyleElement = insertStyleElement;

var update = API(content, options);

${hmrCode}

${(0, _utils.getExportStyleCode)(esModule, this, request)}
`;
            }
    }
};
var _default = exports.default = loader;
}),
"[project]/node_modules/style-loader/dist/cjs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const loader = __turbopack_context__.r("[project]/node_modules/style-loader/dist/index.js [app-route] (ecmascript)");
module.exports = loader.default;
}),
"[project]/node_modules/json5/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// This is a generated file. Do not edit.
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
    Space_Separator: Space_Separator,
    ID_Start: ID_Start,
    ID_Continue: ID_Continue
};
var util = {
    isSpaceSeparator (c) {
        return typeof c === 'string' && unicode.Space_Separator.test(c);
    },
    isIdStartChar (c) {
        return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '$' || c === '_' || unicode.ID_Start.test(c));
    },
    isIdContinueChar (c) {
        return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '$' || c === '_' || c === '\u200C' || c === '\u200D' || unicode.ID_Continue.test(c));
    },
    isDigit (c) {
        return typeof c === 'string' && /[0-9]/.test(c);
    },
    isHexDigit (c) {
        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c);
    }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse = function parse(text, reviver) {
    source = String(text);
    parseState = 'start';
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root = undefined;
    do {
        token = lex();
        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }
        parseStates[parseState]();
    }while (token.type !== 'eof')
    if (typeof reviver === 'function') {
        return internalize({
            '': root
        }, '', reviver);
    }
    return root;
};
function internalize(holder, name, reviver) {
    const value = holder[name];
    if (value != null && typeof value === 'object') {
        if (Array.isArray(value)) {
            for(let i = 0; i < value.length; i++){
                const key = String(i);
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
        } else {
            for(const key in value){
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
        }
    }
    return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
    lexState = 'default';
    buffer = '';
    doubleQuote = false;
    sign = 1;
    for(;;){
        c = peek();
        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }
        const token = lexStates[lexState]();
        if (token) {
            return token;
        }
    }
}
function peek() {
    if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
    }
}
function read() {
    const c = peek();
    if (c === '\n') {
        line++;
        column = 0;
    } else if (c) {
        column += c.length;
    } else {
        column++;
    }
    if (c) {
        pos += c.length;
    }
    return c;
}
const lexStates = {
    default () {
        switch(c){
            case '\t':
            case '\v':
            case '\f':
            case ' ':
            case '\u00A0':
            case '\uFEFF':
            case '\n':
            case '\r':
            case '\u2028':
            case '\u2029':
                read();
                return;
            case '/':
                read();
                lexState = 'comment';
                return;
            case undefined:
                read();
                return newToken('eof');
        }
        if (util.isSpaceSeparator(c)) {
            read();
            return;
        }
        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }
        return lexStates[parseState]();
    },
    comment () {
        switch(c){
            case '*':
                read();
                lexState = 'multiLineComment';
                return;
            case '/':
                read();
                lexState = 'singleLineComment';
                return;
        }
        throw invalidChar(read());
    },
    multiLineComment () {
        switch(c){
            case '*':
                read();
                lexState = 'multiLineCommentAsterisk';
                return;
            case undefined:
                throw invalidChar(read());
        }
        read();
    },
    multiLineCommentAsterisk () {
        switch(c){
            case '*':
                read();
                return;
            case '/':
                read();
                lexState = 'default';
                return;
            case undefined:
                throw invalidChar(read());
        }
        read();
        lexState = 'multiLineComment';
    },
    singleLineComment () {
        switch(c){
            case '\n':
            case '\r':
            case '\u2028':
            case '\u2029':
                read();
                lexState = 'default';
                return;
            case undefined:
                read();
                return newToken('eof');
        }
        read();
    },
    value () {
        switch(c){
            case '{':
            case '[':
                return newToken('punctuator', read());
            case 'n':
                read();
                literal('ull');
                return newToken('null', null);
            case 't':
                read();
                literal('rue');
                return newToken('boolean', true);
            case 'f':
                read();
                literal('alse');
                return newToken('boolean', false);
            case '-':
            case '+':
                if (read() === '-') {
                    sign = -1;
                }
                lexState = 'sign';
                return;
            case '.':
                buffer = read();
                lexState = 'decimalPointLeading';
                return;
            case '0':
                buffer = read();
                lexState = 'zero';
                return;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                buffer = read();
                lexState = 'decimalInteger';
                return;
            case 'I':
                read();
                literal('nfinity');
                return newToken('numeric', Infinity);
            case 'N':
                read();
                literal('aN');
                return newToken('numeric', NaN);
            case '"':
            case "'":
                doubleQuote = read() === '"';
                buffer = '';
                lexState = 'string';
                return;
        }
        throw invalidChar(read());
    },
    identifierNameStartEscape () {
        if (c !== 'u') {
            throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch(u){
            case '$':
            case '_':
                break;
            default:
                if (!util.isIdStartChar(u)) {
                    throw invalidIdentifier();
                }
                break;
        }
        buffer += u;
        lexState = 'identifierName';
    },
    identifierName () {
        switch(c){
            case '$':
            case '_':
            case '\u200C':
            case '\u200D':
                buffer += read();
                return;
            case '\\':
                read();
                lexState = 'identifierNameEscape';
                return;
        }
        if (util.isIdContinueChar(c)) {
            buffer += read();
            return;
        }
        return newToken('identifier', buffer);
    },
    identifierNameEscape () {
        if (c !== 'u') {
            throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch(u){
            case '$':
            case '_':
            case '\u200C':
            case '\u200D':
                break;
            default:
                if (!util.isIdContinueChar(u)) {
                    throw invalidIdentifier();
                }
                break;
        }
        buffer += u;
        lexState = 'identifierName';
    },
    sign () {
        switch(c){
            case '.':
                buffer = read();
                lexState = 'decimalPointLeading';
                return;
            case '0':
                buffer = read();
                lexState = 'zero';
                return;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                buffer = read();
                lexState = 'decimalInteger';
                return;
            case 'I':
                read();
                literal('nfinity');
                return newToken('numeric', sign * Infinity);
            case 'N':
                read();
                literal('aN');
                return newToken('numeric', NaN);
        }
        throw invalidChar(read());
    },
    zero () {
        switch(c){
            case '.':
                buffer += read();
                lexState = 'decimalPoint';
                return;
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
            case 'x':
            case 'X':
                buffer += read();
                lexState = 'hexadecimal';
                return;
        }
        return newToken('numeric', sign * 0);
    },
    decimalInteger () {
        switch(c){
            case '.':
                buffer += read();
                lexState = 'decimalPoint';
                return;
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalPointLeading () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return;
        }
        throw invalidChar(read());
    },
    decimalPoint () {
        switch(c){
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalFraction () {
        switch(c){
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalExponent () {
        switch(c){
            case '+':
            case '-':
                buffer += read();
                lexState = 'decimalExponentSign';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return;
        }
        throw invalidChar(read());
    },
    decimalExponentSign () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return;
        }
        throw invalidChar(read());
    },
    decimalExponentInteger () {
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    hexadecimal () {
        if (util.isHexDigit(c)) {
            buffer += read();
            lexState = 'hexadecimalInteger';
            return;
        }
        throw invalidChar(read());
    },
    hexadecimalInteger () {
        if (util.isHexDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    string () {
        switch(c){
            case '\\':
                read();
                buffer += escape();
                return;
            case '"':
                if (doubleQuote) {
                    read();
                    return newToken('string', buffer);
                }
                buffer += read();
                return;
            case "'":
                if (!doubleQuote) {
                    read();
                    return newToken('string', buffer);
                }
                buffer += read();
                return;
            case '\n':
            case '\r':
                throw invalidChar(read());
            case '\u2028':
            case '\u2029':
                separatorChar(c);
                break;
            case undefined:
                throw invalidChar(read());
        }
        buffer += read();
    },
    start () {
        switch(c){
            case '{':
            case '[':
                return newToken('punctuator', read());
        }
        lexState = 'value';
    },
    beforePropertyName () {
        switch(c){
            case '$':
            case '_':
                buffer = read();
                lexState = 'identifierName';
                return;
            case '\\':
                read();
                lexState = 'identifierNameStartEscape';
                return;
            case '}':
                return newToken('punctuator', read());
            case '"':
            case "'":
                doubleQuote = read() === '"';
                lexState = 'string';
                return;
        }
        if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = 'identifierName';
            return;
        }
        throw invalidChar(read());
    },
    afterPropertyName () {
        if (c === ':') {
            return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    beforePropertyValue () {
        lexState = 'value';
    },
    afterPropertyValue () {
        switch(c){
            case ',':
            case '}':
                return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    beforeArrayValue () {
        if (c === ']') {
            return newToken('punctuator', read());
        }
        lexState = 'value';
    },
    afterArrayValue () {
        switch(c){
            case ',':
            case ']':
                return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    end () {
        // This code is unreachable since it's handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken('eof')
        // }
        throw invalidChar(read());
    }
};
function newToken(type, value) {
    return {
        type,
        value,
        line,
        column
    };
}
function literal(s) {
    for (const c of s){
        const p = peek();
        if (p !== c) {
            throw invalidChar(read());
        }
        read();
    }
}
function escape() {
    const c = peek();
    switch(c){
        case 'b':
            read();
            return '\b';
        case 'f':
            read();
            return '\f';
        case 'n':
            read();
            return '\n';
        case 'r':
            read();
            return '\r';
        case 't':
            read();
            return '\t';
        case 'v':
            read();
            return '\v';
        case '0':
            read();
            if (util.isDigit(peek())) {
                throw invalidChar(read());
            }
            return '\0';
        case 'x':
            read();
            return hexEscape();
        case 'u':
            read();
            return unicodeEscape();
        case '\n':
        case '\u2028':
        case '\u2029':
            read();
            return '';
        case '\r':
            read();
            if (peek() === '\n') {
                read();
            }
            return '';
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            throw invalidChar(read());
        case undefined:
            throw invalidChar(read());
    }
    return read();
}
function hexEscape() {
    let buffer = '';
    let c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read());
    }
    buffer += read();
    c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read());
    }
    buffer += read();
    return String.fromCodePoint(parseInt(buffer, 16));
}
function unicodeEscape() {
    let buffer = '';
    let count = 4;
    while(count-- > 0){
        const c = peek();
        if (!util.isHexDigit(c)) {
            throw invalidChar(read());
        }
        buffer += read();
    }
    return String.fromCodePoint(parseInt(buffer, 16));
}
const parseStates = {
    start () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        push();
    },
    beforePropertyName () {
        switch(token.type){
            case 'identifier':
            case 'string':
                key = token.value;
                parseState = 'afterPropertyName';
                return;
            case 'punctuator':
                // This code is unreachable since it's handled by the lexState.
                // if (token.value !== '}') {
                //     throw invalidToken()
                // }
                pop();
                return;
            case 'eof':
                throw invalidEOF();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    afterPropertyName () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator' || token.value !== ':') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        parseState = 'beforePropertyValue';
    },
    beforePropertyValue () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        push();
    },
    beforeArrayValue () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        if (token.type === 'punctuator' && token.value === ']') {
            pop();
            return;
        }
        push();
    },
    afterPropertyValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        switch(token.value){
            case ',':
                parseState = 'beforePropertyName';
                return;
            case '}':
                pop();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    afterArrayValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        switch(token.value){
            case ',':
                parseState = 'beforeArrayValue';
                return;
            case ']':
                pop();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    end () {
    // This code is unreachable since it's handled by the lexState.
    // if (token.type !== 'eof') {
    //     throw invalidToken()
    // }
    }
};
function push() {
    let value;
    switch(token.type){
        case 'punctuator':
            switch(token.value){
                case '{':
                    value = {};
                    break;
                case '[':
                    value = [];
                    break;
            }
            break;
        case 'null':
        case 'boolean':
        case 'numeric':
        case 'string':
            value = token.value;
            break;
    }
    if (root === undefined) {
        root = value;
    } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
            parent.push(value);
        } else {
            Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    if (value !== null && typeof value === 'object') {
        stack.push(value);
        if (Array.isArray(value)) {
            parseState = 'beforeArrayValue';
        } else {
            parseState = 'beforePropertyName';
        }
    } else {
        const current = stack[stack.length - 1];
        if (current == null) {
            parseState = 'end';
        } else if (Array.isArray(current)) {
            parseState = 'afterArrayValue';
        } else {
            parseState = 'afterPropertyValue';
        }
    }
}
function pop() {
    stack.pop();
    const current = stack[stack.length - 1];
    if (current == null) {
        parseState = 'end';
    } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue';
    } else {
        parseState = 'afterPropertyValue';
    }
}
// This code is unreachable.
// function invalidParseState () {
//     return new Error(`JSON5: invalid parse state '${parseState}'`)
// }
// This code is unreachable.
// function invalidLexState (state) {
//     return new Error(`JSON5: invalid lex state '${state}'`)
// }
function invalidChar(c) {
    if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`);
}
function invalidEOF() {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
// This code is unreachable.
// function invalidToken () {
//     if (token.type === 'eof') {
//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
//     }
//     const c = String.fromCodePoint(token.value.codePointAt(0))
//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
// }
function invalidIdentifier() {
    column -= 5;
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c) {
    console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c) {
    const replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
    };
    if (replacements[c]) {
        return replacements[c];
    }
    if (c < ' ') {
        const hexString = c.charCodeAt(0).toString(16);
        return '\\x' + ('00' + hexString).substring(hexString.length);
    }
    return c;
}
function syntaxError(message) {
    const err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err;
}
var stringify = function stringify(value, replacer, space) {
    const stack = [];
    let indent = '';
    let propertyList;
    let replacerFunc;
    let gap = '';
    let quote;
    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
    }
    if (typeof replacer === 'function') {
        replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer){
            let item;
            if (typeof v === 'string') {
                item = v;
            } else if (typeof v === 'number' || v instanceof String || v instanceof Number) {
                item = String(v);
            }
            if (item !== undefined && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
            }
        }
    }
    if (space instanceof Number) {
        space = Number(space);
    } else if (space instanceof String) {
        space = String(space);
    }
    if (typeof space === 'number') {
        if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = '          '.substr(0, space);
        }
    } else if (typeof space === 'string') {
        gap = space.substr(0, 10);
    }
    return serializeProperty('', {
        '': value
    });
    //TURBOPACK unreachable
    ;
    function serializeProperty(key, holder) {
        let value = holder[key];
        if (value != null) {
            if (typeof value.toJSON5 === 'function') {
                value = value.toJSON5(key);
            } else if (typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
        }
        if (replacerFunc) {
            value = replacerFunc.call(holder, key, value);
        }
        if (value instanceof Number) {
            value = Number(value);
        } else if (value instanceof String) {
            value = String(value);
        } else if (value instanceof Boolean) {
            value = value.valueOf();
        }
        switch(value){
            case null:
                return 'null';
            case true:
                return 'true';
            case false:
                return 'false';
        }
        if (typeof value === 'string') {
            return quoteString(value, false);
        }
        if (typeof value === 'number') {
            return String(value);
        }
        if (typeof value === 'object') {
            return Array.isArray(value) ? serializeArray(value) : serializeObject(value);
        }
        return undefined;
    }
    function quoteString(value) {
        const quotes = {
            "'": 0.1,
            '"': 0.2
        };
        const replacements = {
            "'": "\\'",
            '"': '\\"',
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\v': '\\v',
            '\0': '\\0',
            '\u2028': '\\u2028',
            '\u2029': '\\u2029'
        };
        let product = '';
        for(let i = 0; i < value.length; i++){
            const c = value[i];
            switch(c){
                case "'":
                case '"':
                    quotes[c]++;
                    product += c;
                    continue;
                case '\0':
                    if (util.isDigit(value[i + 1])) {
                        product += '\\x00';
                        continue;
                    }
            }
            if (replacements[c]) {
                product += replacements[c];
                continue;
            }
            if (c < ' ') {
                let hexString = c.charCodeAt(0).toString(16);
                product += '\\x' + ('00' + hexString).substring(hexString.length);
                continue;
            }
            product += c;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b)=>quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
    }
    function serializeObject(value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5');
        }
        stack.push(value);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value);
        let partial = [];
        for (const key of keys){
            const propertyString = serializeProperty(key, value);
            if (propertyString !== undefined) {
                let member = serializeKey(key) + ':';
                if (gap !== '') {
                    member += ' ';
                }
                member += propertyString;
                partial.push(member);
            }
        }
        let final;
        if (partial.length === 0) {
            final = '{}';
        } else {
            let properties;
            if (gap === '') {
                properties = partial.join(',');
                final = '{' + properties + '}';
            } else {
                let separator = ',\n' + indent;
                properties = partial.join(separator);
                final = '{\n' + indent + properties + ',\n' + stepback + '}';
            }
        }
        stack.pop();
        indent = stepback;
        return final;
    }
    function serializeKey(key) {
        if (key.length === 0) {
            return quoteString(key, true);
        }
        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
            return quoteString(key, true);
        }
        for(let i = firstChar.length; i < key.length; i++){
            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
                return quoteString(key, true);
            }
        }
        return key;
    }
    function serializeArray(value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5');
        }
        stack.push(value);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for(let i = 0; i < value.length; i++){
            const propertyString = serializeProperty(String(i), value);
            partial.push(propertyString !== undefined ? propertyString : 'null');
        }
        let final;
        if (partial.length === 0) {
            final = '[]';
        } else {
            if (gap === '') {
                let properties = partial.join(',');
                final = '[' + properties + ']';
            } else {
                let separator = ',\n' + indent;
                let properties = partial.join(separator);
                final = '[\n' + indent + properties + ',\n' + stepback + ']';
            }
        }
        stack.pop();
        indent = stepback;
        return final;
    }
};
const JSON5 = {
    parse,
    stringify
};
var lib = JSON5;
const __TURBOPACK__default__export__ = lib;
}),
"[project]/node_modules/loader-utils/lib/parseQuery.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const JSON5 = __turbopack_context__.r("[project]/node_modules/json5/dist/index.mjs [app-route] (ecmascript)");
const specialValues = {
    null: null,
    true: true,
    false: false
};
function parseQuery(query) {
    if (query.substr(0, 1) !== '?') {
        throw new Error("A valid query string passed to parseQuery should begin with '?'");
    }
    query = query.substr(1);
    if (!query) {
        return {};
    }
    if (query.substr(0, 1) === '{' && query.substr(-1) === '}') {
        return JSON5.parse(query);
    }
    const queryArgs = query.split(/[,&]/g);
    const result = Object.create(null);
    queryArgs.forEach((arg)=>{
        const idx = arg.indexOf('=');
        if (idx >= 0) {
            let name = arg.substr(0, idx);
            let value = decodeURIComponent(arg.substr(idx + 1));
            // eslint-disable-next-line no-prototype-builtins
            if (specialValues.hasOwnProperty(value)) {
                value = specialValues[value];
            }
            if (name.substr(-2) === '[]') {
                name = decodeURIComponent(name.substr(0, name.length - 2));
                if (!Array.isArray(result[name])) {
                    result[name] = [];
                }
                result[name].push(value);
            } else {
                name = decodeURIComponent(name);
                result[name] = value;
            }
        } else {
            if (arg.substr(0, 1) === '-') {
                result[decodeURIComponent(arg.substr(1))] = false;
            } else if (arg.substr(0, 1) === '+') {
                result[decodeURIComponent(arg.substr(1))] = true;
            } else {
                result[decodeURIComponent(arg)] = true;
            }
        }
    });
    return result;
}
module.exports = parseQuery;
}),
"[project]/node_modules/loader-utils/lib/getOptions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parseQuery = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/parseQuery.js [app-route] (ecmascript)");
function getOptions(loaderContext) {
    const query = loaderContext.query;
    if (typeof query === 'string' && query !== '') {
        return parseQuery(loaderContext.query);
    }
    if (!query || typeof query !== 'object') {
        // Not object-like queries are not supported.
        return {};
    }
    return query;
}
module.exports = getOptions;
}),
"[project]/node_modules/loader-utils/lib/stringifyRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const matchRelativePath = /^\.\.?[/\\]/;
function isAbsolutePath(str) {
    return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);
}
function isRelativePath(str) {
    return matchRelativePath.test(str);
}
function stringifyRequest(loaderContext, request) {
    const splitted = request.split('!');
    const context = loaderContext.context || loaderContext.options && loaderContext.options.context;
    return JSON.stringify(splitted.map((part)=>{
        // First, separate singlePath from query, because the query might contain paths again
        const splittedPart = part.match(/^(.*?)(\?.*)/);
        const query = splittedPart ? splittedPart[2] : '';
        let singlePath = splittedPart ? splittedPart[1] : part;
        if (isAbsolutePath(singlePath) && context) {
            singlePath = path.relative(context, singlePath);
            if (isAbsolutePath(singlePath)) {
                // If singlePath still matches an absolute path, singlePath was on a different drive than context.
                // In this case, we leave the path platform-specific without replacing any separators.
                // @see https://github.com/webpack/loader-utils/pull/14
                return singlePath + query;
            }
            if (isRelativePath(singlePath) === false) {
                // Ensure that the relative path starts at least with ./ otherwise it would be a request into the modules directory (like node_modules).
                singlePath = './' + singlePath;
            }
        }
        return singlePath.replace(/\\/g, '/') + query;
    }).join('!'));
}
module.exports = stringifyRequest;
}),
"[project]/node_modules/loader-utils/lib/getRemainingRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function getRemainingRequest(loaderContext) {
    if (loaderContext.remainingRequest) {
        return loaderContext.remainingRequest;
    }
    const request = loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((obj)=>obj.request).concat([
        loaderContext.resource
    ]);
    return request.join('!');
}
module.exports = getRemainingRequest;
}),
"[project]/node_modules/loader-utils/lib/getCurrentRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function getCurrentRequest(loaderContext) {
    if (loaderContext.currentRequest) {
        return loaderContext.currentRequest;
    }
    const request = loaderContext.loaders.slice(loaderContext.loaderIndex).map((obj)=>obj.request).concat([
        loaderContext.resource
    ]);
    return request.join('!');
}
module.exports = getCurrentRequest;
}),
"[project]/node_modules/loader-utils/lib/isUrlRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
function isUrlRequest(url, root) {
    // An URL is not an request if
    // 1. It's an absolute url and it is not `windows` path like `C:\dir\file`
    if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !path.win32.isAbsolute(url)) {
        return false;
    }
    // 2. It's a protocol-relative
    if (/^\/\//.test(url)) {
        return false;
    }
    // 3. It's some kind of url for a template
    if (/^[{}[\]#*;,'$%&(=?`^<>]/.test(url)) {
        return false;
    }
    // 4. It's also not an request if root isn't set and it's a root-relative url
    if ((root === undefined || root === false) && /^\//.test(url)) {
        return false;
    }
    return true;
}
module.exports = isUrlRequest;
}),
"[project]/node_modules/loader-utils/lib/urlToRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// we can't use path.win32.isAbsolute because it also matches paths starting with a forward slash
const matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
function urlToRequest(url, root) {
    // Do not rewrite an empty url
    if (url === '') {
        return '';
    }
    const moduleRequestRegex = /^[^?]*~/;
    let request;
    if (matchNativeWin32Path.test(url)) {
        // absolute windows path, keep it
        request = url;
    } else if (root !== undefined && root !== false && /^\//.test(url)) {
        // if root is set and the url is root-relative
        switch(typeof root){
            // 1. root is a string: root is prefixed to the url
            case 'string':
                // special case: `~` roots convert to module request
                if (moduleRequestRegex.test(root)) {
                    request = root.replace(/([^~/])$/, '$1/') + url.slice(1);
                } else {
                    request = root + url;
                }
                break;
            // 2. root is `true`: absolute paths are allowed
            //    *nix only, windows-style absolute paths are always allowed as they doesn't start with a `/`
            case 'boolean':
                request = url;
                break;
            default:
                throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url + ', root = ' + root + '.');
        }
    } else if (/^\.\.?\//.test(url)) {
        // A relative url stays
        request = url;
    } else {
        // every other url is threaded like a relative url
        request = './' + url;
    }
    // A `~` makes the url an module
    if (moduleRequestRegex.test(request)) {
        request = request.replace(moduleRequestRegex, '');
    }
    return request;
}
module.exports = urlToRequest;
}),
"[project]/node_modules/loader-utils/lib/parseString.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function parseString(str) {
    try {
        if (str[0] === '"') {
            return JSON.parse(str);
        }
        if (str[0] === "'" && str.substr(str.length - 1) === "'") {
            return parseString(str.replace(/\\.|"/g, (x)=>x === '"' ? '\\"' : x).replace(/^'|'$/g, '"'));
        }
        return JSON.parse('"' + str + '"');
    } catch (e) {
        return str;
    }
}
module.exports = parseString;
}),
"[project]/node_modules/loader-utils/lib/hash/wasm-hash.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ // 65536 is the size of a wasm memory page
// 64 is the maximum chunk size for every possible wasm hash implementation
// 4 is the maximum number of bytes per char for string encoding (max is utf-8)
// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64
const MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;
class WasmHash {
    /**
   * @param {WebAssembly.Instance} instance wasm instance
   * @param {WebAssembly.Instance[]} instancesPool pool of instances
   * @param {number} chunkSize size of data chunks passed to wasm
   * @param {number} digestSize size of digest returned by wasm
   */ constructor(instance, instancesPool, chunkSize, digestSize){
        const exports = instance.exports;
        exports.init();
        this.exports = exports;
        this.mem = Buffer.from(exports.memory.buffer, 0, 65536);
        this.buffered = 0;
        this.instancesPool = instancesPool;
        this.chunkSize = chunkSize;
        this.digestSize = digestSize;
    }
    reset() {
        this.buffered = 0;
        this.exports.init();
    }
    /**
   * @param {Buffer | string} data data
   * @param {BufferEncoding=} encoding encoding
   * @returns {this} itself
   */ update(data, encoding) {
        if (typeof data === 'string') {
            while(data.length > MAX_SHORT_STRING){
                this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);
                data = data.slice(MAX_SHORT_STRING);
            }
            this._updateWithShortString(data, encoding);
            return this;
        }
        this._updateWithBuffer(data);
        return this;
    }
    /**
   * @param {string} data data
   * @param {BufferEncoding=} encoding encoding
   * @returns {void}
   */ _updateWithShortString(data, encoding) {
        const { exports, buffered, mem, chunkSize } = this;
        let endPos;
        if (data.length < 70) {
            if (!encoding || encoding === 'utf-8' || encoding === 'utf8') {
                endPos = buffered;
                for(let i = 0; i < data.length; i++){
                    const cc = data.charCodeAt(i);
                    if (cc < 0x80) {
                        mem[endPos++] = cc;
                    } else if (cc < 0x800) {
                        mem[endPos] = cc >> 6 | 0xc0;
                        mem[endPos + 1] = cc & 0x3f | 0x80;
                        endPos += 2;
                    } else {
                        // bail-out for weird chars
                        endPos += mem.write(data.slice(i), endPos, encoding);
                        break;
                    }
                }
            } else if (encoding === 'latin1') {
                endPos = buffered;
                for(let i = 0; i < data.length; i++){
                    const cc = data.charCodeAt(i);
                    mem[endPos++] = cc;
                }
            } else {
                endPos = buffered + mem.write(data, buffered, encoding);
            }
        } else {
            endPos = buffered + mem.write(data, buffered, encoding);
        }
        if (endPos < chunkSize) {
            this.buffered = endPos;
        } else {
            const l = endPos & ~(this.chunkSize - 1);
            exports.update(l);
            const newBuffered = endPos - l;
            this.buffered = newBuffered;
            if (newBuffered > 0) {
                mem.copyWithin(0, l, endPos);
            }
        }
    }
    /**
   * @param {Buffer} data data
   * @returns {void}
   */ _updateWithBuffer(data) {
        const { exports, buffered, mem } = this;
        const length = data.length;
        if (buffered + length < this.chunkSize) {
            data.copy(mem, buffered, 0, length);
            this.buffered += length;
        } else {
            const l = buffered + length & ~(this.chunkSize - 1);
            if (l > 65536) {
                let i = 65536 - buffered;
                data.copy(mem, buffered, 0, i);
                exports.update(65536);
                const stop = l - buffered - 65536;
                while(i < stop){
                    data.copy(mem, 0, i, i + 65536);
                    exports.update(65536);
                    i += 65536;
                }
                data.copy(mem, 0, i, l - buffered);
                exports.update(l - buffered - i);
            } else {
                data.copy(mem, buffered, 0, l - buffered);
                exports.update(l);
            }
            const newBuffered = length + buffered - l;
            this.buffered = newBuffered;
            if (newBuffered > 0) {
                data.copy(mem, 0, length - newBuffered, length);
            }
        }
    }
    digest(type) {
        const { exports, buffered, mem, digestSize } = this;
        exports.final(buffered);
        this.instancesPool.push(this);
        const hex = mem.toString('latin1', 0, digestSize);
        if (type === 'hex') {
            return hex;
        }
        if (type === 'binary' || !type) {
            return Buffer.from(hex, 'hex');
        }
        return Buffer.from(hex, 'hex').toString(type);
    }
}
const create = (wasmModule, instancesPool, chunkSize, digestSize)=>{
    if (instancesPool.length > 0) {
        const old = instancesPool.pop();
        old.reset();
        return old;
    } else {
        return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);
    }
};
module.exports = create;
module.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;
}),
"[project]/node_modules/loader-utils/lib/hash/md4.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const create = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/hash/wasm-hash.js [app-route] (ecmascript)");
//#region wasm code: md4 (../../../assembly/hash/md4.asm.ts) --initialMemory 1
const md4 = new WebAssembly.Module(Buffer.from(// 2150 bytes
'AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=', 'base64'));
//#endregion
module.exports = create.bind(null, md4, [], 64, 32);
}),
"[project]/node_modules/loader-utils/lib/hash/BatchedHash.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const MAX_SHORT_STRING = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/hash/wasm-hash.js [app-route] (ecmascript)").MAX_SHORT_STRING;
class BatchedHash {
    constructor(hash){
        this.string = undefined;
        this.encoding = undefined;
        this.hash = hash;
    }
    /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
   * @param {string|Buffer} data data
   * @param {string=} inputEncoding data encoding
   * @returns {this} updated hash
   */ update(data, inputEncoding) {
        if (this.string !== undefined) {
            if (typeof data === 'string' && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) {
                this.string += data;
                return this;
            }
            this.hash.update(this.string, this.encoding);
            this.string = undefined;
        }
        if (typeof data === 'string') {
            if (data.length < MAX_SHORT_STRING && // base64 encoding is not valid since it may contain padding chars
            (!inputEncoding || !inputEncoding.startsWith('ba'))) {
                this.string = data;
                this.encoding = inputEncoding;
            } else {
                this.hash.update(data, inputEncoding);
            }
        } else {
            this.hash.update(data);
        }
        return this;
    }
    /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
   * @param {string=} encoding encoding of the return value
   * @returns {string|Buffer} digest
   */ digest(encoding) {
        if (this.string !== undefined) {
            this.hash.update(this.string, this.encoding);
        }
        return this.hash.digest(encoding);
    }
}
module.exports = BatchedHash;
}),
"[project]/node_modules/loader-utils/lib/getHashDigest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const baseEncodeTables = {
    26: 'abcdefghijklmnopqrstuvwxyz',
    32: '123456789abcdefghjkmnpqrstuvwxyz',
    36: '0123456789abcdefghijklmnopqrstuvwxyz',
    49: 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
    52: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
    58: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
    62: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
    64: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_'
};
function encodeBufferToBase(buffer, base) {
    const encodeTable = baseEncodeTables[base];
    if (!encodeTable) {
        throw new Error('Unknown encoding base' + base);
    }
    const readLength = buffer.length;
    const Big = __turbopack_context__.r("[project]/node_modules/big.js/big.mjs [app-route] (ecmascript)");
    Big.RM = Big.DP = 0;
    let b = new Big(0);
    for(let i = readLength - 1; i >= 0; i--){
        b = b.times(256).plus(buffer[i]);
    }
    let output = '';
    while(b.gt(0)){
        output = encodeTable[b.mod(base)] + output;
        b = b.div(base);
    }
    Big.DP = 20;
    Big.RM = 1;
    return output;
}
let createMd4 = undefined;
let BatchedHash = undefined;
function getHashDigest(buffer, hashType, digestType, maxLength) {
    hashType = hashType || 'md4';
    maxLength = maxLength || 9999;
    let hash;
    try {
        hash = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)").createHash(hashType);
    } catch (error) {
        if (error.code === 'ERR_OSSL_EVP_UNSUPPORTED' && hashType === 'md4') {
            if (createMd4 === undefined) {
                createMd4 = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/hash/md4.js [app-route] (ecmascript)");
                if (BatchedHash === undefined) {
                    BatchedHash = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/hash/BatchedHash.js [app-route] (ecmascript)");
                }
            }
            hash = new BatchedHash(createMd4());
        }
        if (!hash) {
            throw error;
        }
    }
    hash.update(buffer);
    if (digestType === 'base26' || digestType === 'base32' || digestType === 'base36' || digestType === 'base49' || digestType === 'base52' || digestType === 'base58' || digestType === 'base62') {
        return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(0, maxLength);
    } else {
        return hash.digest(digestType || 'hex').substr(0, maxLength);
    }
}
module.exports = getHashDigest;
}),
"[project]/node_modules/loader-utils/lib/interpolateName.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const emojisList = __turbopack_context__.r("[project]/node_modules/emojis-list/index.js [app-route] (ecmascript)");
const getHashDigest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/getHashDigest.js [app-route] (ecmascript)");
const emojiRegex = /[\uD800-\uDFFF]./;
const emojiList = emojisList.filter((emoji)=>emojiRegex.test(emoji));
const emojiCache = {};
function encodeStringToEmoji(content, length) {
    if (emojiCache[content]) {
        return emojiCache[content];
    }
    length = length || 1;
    const emojis = [];
    do {
        if (!emojiList.length) {
            throw new Error('Ran out of emoji');
        }
        const index = Math.floor(Math.random() * emojiList.length);
        emojis.push(emojiList[index]);
        emojiList.splice(index, 1);
    }while (--length > 0)
    const emojiEncoding = emojis.join('');
    emojiCache[content] = emojiEncoding;
    return emojiEncoding;
}
function interpolateName(loaderContext, name, options) {
    let filename;
    const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
    if (typeof name === 'function') {
        filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);
    } else {
        filename = name || '[hash].[ext]';
    }
    const context = options.context;
    const content = options.content;
    const regExp = options.regExp;
    let ext = 'bin';
    let basename = 'file';
    let directory = '';
    let folder = '';
    let query = '';
    if (loaderContext.resourcePath) {
        const parsed = path.parse(loaderContext.resourcePath);
        let resourcePath = loaderContext.resourcePath;
        if (parsed.ext) {
            ext = parsed.ext.substr(1);
        }
        if (parsed.dir) {
            basename = parsed.name;
            resourcePath = parsed.dir + path.sep;
        }
        if (typeof context !== 'undefined') {
            directory = path.relative(context, resourcePath + '_').replace(/\\/g, '/').replace(/\.\.(\/)?/g, '_$1');
            directory = directory.substr(0, directory.length - 1);
        } else {
            directory = resourcePath.replace(/\\/g, '/').replace(/\.\.(\/)?/g, '_$1');
        }
        if (directory.length === 1) {
            directory = '';
        } else if (directory.length > 1) {
            folder = path.basename(directory);
        }
    }
    if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
        query = loaderContext.resourceQuery;
        const hashIdx = query.indexOf('#');
        if (hashIdx >= 0) {
            query = query.substr(0, hashIdx);
        }
    }
    let url = filename;
    if (content) {
        // Match hash template
        url = url// `hash` and `contenthash` are same in `loader-utils` context
        // let's keep `hash` for backward compatibility
        .replace(/\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (all, hashType, digestType, maxLength)=>getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\[emoji(?::(\d+))?\]/gi, (all, length)=>encodeStringToEmoji(content, parseInt(length, 10)));
    }
    url = url.replace(/\[ext\]/gi, ()=>ext).replace(/\[name\]/gi, ()=>basename).replace(/\[path\]/gi, ()=>directory).replace(/\[folder\]/gi, ()=>folder).replace(/\[query\]/gi, ()=>query);
    if (regExp && loaderContext.resourcePath) {
        const match = loaderContext.resourcePath.match(new RegExp(regExp));
        match && match.forEach((matched, i)=>{
            url = url.replace(new RegExp('\\[' + i + '\\]', 'ig'), matched);
        });
    }
    if (typeof loaderContext.options === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {
        url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);
    }
    return url;
}
module.exports = interpolateName;
}),
"[project]/node_modules/loader-utils/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const getOptions = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/getOptions.js [app-route] (ecmascript)");
const parseQuery = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/parseQuery.js [app-route] (ecmascript)");
const stringifyRequest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/stringifyRequest.js [app-route] (ecmascript)");
const getRemainingRequest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/getRemainingRequest.js [app-route] (ecmascript)");
const getCurrentRequest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/getCurrentRequest.js [app-route] (ecmascript)");
const isUrlRequest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/isUrlRequest.js [app-route] (ecmascript)");
const urlToRequest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/urlToRequest.js [app-route] (ecmascript)");
const parseString = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/parseString.js [app-route] (ecmascript)");
const getHashDigest = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/getHashDigest.js [app-route] (ecmascript)");
const interpolateName = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/interpolateName.js [app-route] (ecmascript)");
exports.getOptions = getOptions;
exports.parseQuery = parseQuery;
exports.stringifyRequest = stringifyRequest;
exports.getRemainingRequest = getRemainingRequest;
exports.getCurrentRequest = getCurrentRequest;
exports.isUrlRequest = isUrlRequest;
exports.urlToRequest = urlToRequest;
exports.parseString = parseString;
exports.getHashDigest = getHashDigest;
exports.interpolateName = interpolateName;
}),
"[project]/node_modules/big.js/big.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
 *  big.js v5.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>
 *  https://github.com/MikeMcl/big.js/LICENCE
 */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.
/*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */ __turbopack_context__.s([
    "Big",
    ()=>Big,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var DP = 20, /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */ RM = 1, // The maximum value of DP and Big.DP.
MAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.
MAX_POWER = 1E6, /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */ NE = -7, /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big.
   * (This limit is not enforced or checked.)
   */ PE = 21, /**************************************************************************************************/ // Error messages.
NAME = '[big.js] ', INVALID = NAME + 'Invalid ', INVALID_DP = INVALID + 'decimal places', INVALID_RM = INVALID + 'rounding mode', DIV_BY_ZERO = NAME + 'Division by zero', // The shared prototype object.
P = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
/*
 * Create and return a Big constructor.
 *
 */ function _Big_() {
    /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */ function Big(n) {
        var x = this;
        // Enable constructor usage without new.
        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);
        // Duplicate.
        if (n instanceof Big) {
            x.s = n.s;
            x.e = n.e;
            x.c = n.c.slice();
        } else {
            parse(x, n);
        }
        /*
     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which
     * points to Object.
     */ x.constructor = Big;
    }
    Big.prototype = P;
    Big.DP = DP;
    Big.RM = RM;
    Big.NE = NE;
    Big.PE = PE;
    Big.version = '5.2.2';
    return Big;
}
/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */ function parse(x, n) {
    var e, i, nl;
    // Minus zero?
    if (n === 0 && 1 / n < 0) n = '-0';
    else if (!NUMERIC.test(n += '')) throw Error(INVALID + 'number');
    // Determine sign.
    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;
    // Decimal point?
    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');
    // Exponential form?
    if ((i = n.search(/e/i)) > 0) {
        // Determine exponent.
        if (e < 0) e = i;
        e += +n.slice(i + 1);
        n = n.substring(0, i);
    } else if (e < 0) {
        // Integer.
        e = n.length;
    }
    nl = n.length;
    // Determine leading zeros.
    for(i = 0; i < nl && n.charAt(i) == '0';)++i;
    if (i == nl) {
        // Zero.
        x.c = [
            x.e = 0
        ];
    } else {
        // Determine trailing zeros.
        for(; nl > 0 && n.charAt(--nl) == '0';);
        x.e = e - i - 1;
        x.c = [];
        // Convert string to array of digits without leading/trailing zeros.
        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);
    }
    return x;
}
/*
 * Round Big x to a maximum of dp decimal places using rounding mode rm.
 * Called by stringify, P.div, P.round and P.sqrt.
 *
 * x {Big} The Big to round.
 * dp {number} Integer, 0 to MAX_DP inclusive.
 * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
 * [more] {boolean} Whether the result of division was truncated.
 */ function round(x, dp, rm, more) {
    var xc = x.c, i = x.e + dp + 1;
    if (i < xc.length) {
        if (rm === 1) {
            // xc[i] is the digit after the digit that may be rounded up.
            more = xc[i] >= 5;
        } else if (rm === 2) {
            more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
        } else if (rm === 3) {
            more = more || !!xc[0];
        } else {
            more = false;
            if (rm !== 0) throw Error(INVALID_RM);
        }
        if (i < 1) {
            xc.length = 1;
            if (more) {
                // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                x.e = -dp;
                xc[0] = 1;
            } else {
                // Zero.
                xc[0] = x.e = 0;
            }
        } else {
            // Remove any digits after the required decimal places.
            xc.length = i--;
            // Round up?
            if (more) {
                // Rounding up may mean the previous digit has to be rounded up.
                for(; ++xc[i] > 9;){
                    xc[i] = 0;
                    if (!i--) {
                        ++x.e;
                        xc.unshift(1);
                    }
                }
            }
            // Remove trailing zeros.
            for(i = xc.length; !xc[--i];)xc.pop();
        }
    } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
        throw Error(INVALID_RM);
    }
    return x;
}
/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 *
 * x {Big}
 * id? {number} Caller id.
 *         1 toExponential
 *         2 toFixed
 *         3 toPrecision
 *         4 valueOf
 * n? {number|undefined} Caller's argument.
 * k? {number|undefined}
 */ function stringify(x, id, n, k) {
    var e, s, Big = x.constructor, z = !x.c[0];
    if (n !== UNDEFINED) {
        if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
            throw Error(id == 3 ? INVALID + 'precision' : INVALID_DP);
        }
        x = new Big(x);
        // The index of the digit that may be rounded up.
        n = k - x.e;
        // Round?
        if (x.c.length > ++k) round(x, n, Big.RM);
        // toFixed: recalculate k as x.e may have changed if value rounded up.
        if (id == 2) k = x.e + n + 1;
        // Append zeros?
        for(; x.c.length < k;)x.c.push(0);
    }
    e = x.e;
    s = x.c.join('');
    n = s.length;
    // Exponential notation?
    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {
        s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;
    // Normal notation.
    } else if (e < 0) {
        for(; ++e;)s = '0' + s;
        s = '0.' + s;
    } else if (e > 0) {
        if (++e > n) for(e -= n; e--;)s += '0';
        else if (e < n) s = s.slice(0, e) + '.' + s.slice(e);
    } else if (n > 1) {
        s = s.charAt(0) + '.' + s.slice(1);
    }
    return x.s < 0 && (!z || id == 4) ? '-' + s : s;
}
// Prototype/instance methods
/*
 * Return a new Big whose value is the absolute value of this Big.
 */ P.abs = function() {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
};
/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
*/ P.cmp = function(y) {
    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
    // Either zero?
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;
    // Signs differ?
    if (i != j) return i;
    isneg = i < 0;
    // Compare exponents.
    if (k != l) return k > l ^ isneg ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    // Compare digit by digit.
    for(i = -1; ++i < j;){
        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }
    // Compare lengths.
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */ P.div = function(y) {
    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);
    // Divisor is zero?
    if (!b[0]) throw Error(DIV_BY_ZERO);
    // Dividend is 0? Return +-0.
    if (!a[0]) return new Big(k * 0);
    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1; // number of digits of the result
    q.s = k;
    k = d < 0 ? 0 : d;
    // Create version of divisor with leading zero.
    bz.unshift(0);
    // Add zeros to make remainder as long as divisor.
    for(; rl++ < bl;)r.push(0);
    do {
        // n is how many times the divisor goes into current remainder.
        for(n = 0; n < 10; n++){
            // Compare divisor and remainder.
            if (bl != (rl = r.length)) {
                cmp = bl > rl ? 1 : -1;
            } else {
                for(ri = -1, cmp = 0; ++ri < bl;){
                    if (b[ri] != r[ri]) {
                        cmp = b[ri] > r[ri] ? 1 : -1;
                        break;
                    }
                }
            }
            // If divisor < remainder, subtract divisor from remainder.
            if (cmp < 0) {
                // Remainder can't be more than 1 digit longer than divisor.
                // Equalise lengths using divisor with extra leading zero?
                for(bt = rl == bl ? b : bz; rl;){
                    if (r[--rl] < bt[rl]) {
                        ri = rl;
                        for(; ri && !r[--ri];)r[ri] = 9;
                        --r[ri];
                        r[rl] += 10;
                    }
                    r[rl] -= bt[rl];
                }
                for(; !r[0];)r.shift();
            } else {
                break;
            }
        }
        // Add the digit n to the result array.
        qc[qi++] = cmp ? n : ++n;
        // Update the remainder.
        if (r[0] && cmp) r[rl] = a[ai] || 0;
        else r = [
            a[ai]
        ];
    }while ((ai++ < al || r[0] !== UNDEFINED) && k--)
    // Leading zero? Do not remove if result is simply zero (qi == 1).
    if (!qc[0] && qi != 1) {
        // There can't be more than one zero.
        qc.shift();
        q.e--;
    }
    // Round?
    if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);
    return q;
};
/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */ P.eq = function(y) {
    return !this.cmp(y);
};
/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */ P.gt = function(y) {
    return this.cmp(y) > 0;
};
/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */ P.gte = function(y) {
    return this.cmp(y) > -1;
};
/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */ P.lt = function(y) {
    return this.cmp(y) < 0;
};
/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */ P.lte = function(y) {
    return this.cmp(y) < 1;
};
/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */ P.minus = P.sub = function(y) {
    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;
    // Signs differ?
    if (a != b) {
        y.s = -b;
        return x.plus(y);
    }
    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
    // Either zero?
    if (!xc[0] || !yc[0]) {
        // y is non-zero? x is non-zero? Or both are zero.
        return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);
    }
    // Determine which is the bigger number. Prepend zeros to equalise exponents.
    if (a = xe - ye) {
        if (xlty = a < 0) {
            a = -a;
            t = xc;
        } else {
            ye = xe;
            t = yc;
        }
        t.reverse();
        for(b = a; b--;)t.push(0);
        t.reverse();
    } else {
        // Exponents equal. Check digit by digit.
        j = ((xlty = xc.length < yc.length) ? xc : yc).length;
        for(a = b = 0; b < j; b++){
            if (xc[b] != yc[b]) {
                xlty = xc[b] < yc[b];
                break;
            }
        }
    }
    // x < y? Point xc to the array of the bigger number.
    if (xlty) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
    }
    /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;
    // Subtract yc from xc.
    for(b = i; j > a;){
        if (xc[--j] < yc[j]) {
            for(i = j; i && !xc[--i];)xc[i] = 9;
            --xc[i];
            xc[j] += 10;
        }
        xc[j] -= yc[j];
    }
    // Remove trailing zeros.
    for(; xc[--b] === 0;)xc.pop();
    // Remove leading zeros and adjust exponent accordingly.
    for(; xc[0] === 0;){
        xc.shift();
        --ye;
    }
    if (!xc[0]) {
        // n - n = +0
        y.s = 1;
        // Result must be zero.
        xc = [
            ye = 0
        ];
    }
    y.c = xc;
    y.e = ye;
    return y;
};
/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */ P.mod = function(y) {
    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;
    if (!y.c[0]) throw Error(DIV_BY_ZERO);
    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;
    if (ygtx) return new Big(x);
    a = Big.DP;
    b = Big.RM;
    Big.DP = Big.RM = 0;
    x = x.div(y);
    Big.DP = a;
    Big.RM = b;
    return this.minus(x.times(y));
};
/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */ P.plus = P.add = function(y) {
    var t, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;
    // Signs differ?
    if (a != b) {
        y.s = -b;
        return x.minus(y);
    }
    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
    // Either zero? y is non-zero? x is non-zero? Or both are zero.
    if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);
    xc = xc.slice();
    // Prepend zeros to equalise exponents.
    // Note: reverse faster than unshifts.
    if (a = xe - ye) {
        if (a > 0) {
            ye = xe;
            t = yc;
        } else {
            a = -a;
            t = xc;
        }
        t.reverse();
        for(; a--;)t.push(0);
        t.reverse();
    }
    // Point xc to the longer array.
    if (xc.length - yc.length < 0) {
        t = yc;
        yc = xc;
        xc = t;
    }
    a = yc.length;
    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
    for(b = 0; a; xc[a] %= 10)b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    if (b) {
        xc.unshift(b);
        ++ye;
    }
    // Remove trailing zeros.
    for(a = xc.length; xc[--a] === 0;)xc.pop();
    y.c = xc;
    y.e = ye;
    return y;
};
/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */ P.pow = function(n) {
    var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + 'exponent');
    if (isneg) n = -n;
    for(;;){
        if (n & 1) y = y.times(x);
        n >>= 1;
        if (!n) break;
        x = x.times(x);
    }
    return isneg ? one.div(y) : y;
};
/*
 * Return a new Big whose value is the value of this Big rounded using rounding mode rm
 * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a
 * multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 * If rm is not specified, use Big.RM.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
 */ P.round = function(dp, rm) {
    var Big = this.constructor;
    if (dp === UNDEFINED) dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);
    return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);
};
/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */ P.sqrt = function() {
    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(0.5);
    // Zero?
    if (!x.c[0]) return new Big(x);
    // Negative?
    if (s < 0) throw Error(NAME + 'No square root');
    // Estimate.
    s = Math.sqrt(x + '');
    // Math.sqrt underflow/overflow?
    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
    if (s === 0 || s === 1 / 0) {
        c = x.c.join('');
        if (!(c.length + e & 1)) c += '0';
        s = Math.sqrt(c);
        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
        r = new Big((s == 1 / 0 ? '1e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
    } else {
        r = new Big(s);
    }
    e = r.e + (Big.DP += 4);
    // Newton-Raphson iteration.
    do {
        t = r;
        r = half.times(t.plus(x.div(t)));
    }while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''))
    return round(r, Big.DP -= 4, Big.RM);
};
/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */ P.times = P.mul = function(y) {
    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
    // Determine sign of result.
    y.s = x.s == y.s ? 1 : -1;
    // Return signed 0 if either 0.
    if (!xc[0] || !yc[0]) return new Big(y.s * 0);
    // Initialise exponent of result as x.e + y.e.
    y.e = i + j;
    // If array xc has fewer digits than yc, swap xc and yc, and lengths.
    if (a < b) {
        c = xc;
        xc = yc;
        yc = c;
        j = a;
        a = b;
        b = j;
    }
    // Initialise coefficient array of result with zeros.
    for(c = new Array(j = a + b); j--;)c[j] = 0;
    // Multiply.
    // i is initially xc.length.
    for(i = b; i--;){
        b = 0;
        // a is yc.length.
        for(j = a + i; j > i;){
            // Current sum of products at this digit position, plus carry.
            b = c[j] + yc[i] * xc[j - i - 1] + b;
            c[j--] = b % 10;
            // carry
            b = b / 10 | 0;
        }
        c[j] = (c[j] + b) % 10;
    }
    // Increment result exponent if there is a final carry, otherwise remove leading zero.
    if (b) ++y.e;
    else c.shift();
    // Remove trailing zeros.
    for(i = c.length; !c[--i];)c.pop();
    y.c = c;
    return y;
};
/*
 * Return a string representing the value of this Big in exponential notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 */ P.toExponential = function(dp) {
    return stringify(this, 1, dp, dp);
};
/*
 * Return a string representing the value of this Big in normal notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */ P.toFixed = function(dp) {
    return stringify(this, 2, dp, this.e + dp);
};
/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Integer, 1 to MAX_DP inclusive.
 */ P.toPrecision = function(sd) {
    return stringify(this, 3, sd, sd - 1);
};
/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */ P.toString = function() {
    return stringify(this);
};
/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */ P.valueOf = P.toJSON = function() {
    return stringify(this, 4);
};
var Big = _Big_();
const __TURBOPACK__default__export__ = Big;
}),
"[project]/node_modules/emojis-list/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "#",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "*",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "0",
    "",
    "",
    "1",
    "2",
    "",
    "",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "",
    "",
    ""
];
}),
"[project]/node_modules/schema-utils/dist/keywords/absolutePath.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
/** @typedef {import("ajv").Ajv} Ajv */ /** @typedef {import("ajv").ValidateFunction} ValidateFunction */ /** @typedef {import("../validate").SchemaUtilErrorObject} SchemaUtilErrorObject */ /**
 * @param {string} message
 * @param {object} schema
 * @param {string} data
 * @returns {SchemaUtilErrorObject}
 */ function errorMessage(message, schema, data) {
    return {
        // @ts-ignore
        // eslint-disable-next-line no-undefined
        dataPath: undefined,
        // @ts-ignore
        // eslint-disable-next-line no-undefined
        schemaPath: undefined,
        keyword: "absolutePath",
        params: {
            absolutePath: data
        },
        message,
        parentSchema: schema
    };
}
/**
 * @param {boolean} shouldBeAbsolute
 * @param {object} schema
 * @param {string} data
 * @returns {SchemaUtilErrorObject}
 */ function getErrorFor(shouldBeAbsolute, schema, data) {
    const message = shouldBeAbsolute ? `The provided value ${JSON.stringify(data)} is not an absolute path!` : `A relative path is expected. However, the provided value ${JSON.stringify(data)} is an absolute path!`;
    return errorMessage(message, schema, data);
}
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */ function addAbsolutePathKeyword(ajv) {
    ajv.addKeyword("absolutePath", {
        errors: true,
        type: "string",
        compile (schema, parentSchema) {
            /** @type {ValidateFunction} */ const callback = (data)=>{
                let passes = true;
                const isExclamationMarkPresent = data.includes("!");
                if (isExclamationMarkPresent) {
                    callback.errors = [
                        errorMessage(`The provided value ${JSON.stringify(data)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`, parentSchema, data)
                    ];
                    passes = false;
                } // ?:[A-Za-z]:\\ - Windows absolute path
                // \\\\ - Windows network absolute path
                // \/ - Unix-like OS absolute path
                const isCorrectAbsolutePath = schema === /^(?:[A-Za-z]:(\\|\/)|\\\\|\/)/.test(data);
                if (!isCorrectAbsolutePath) {
                    callback.errors = [
                        getErrorFor(schema, parentSchema, data)
                    ];
                    passes = false;
                }
                return passes;
            };
            callback.errors = [];
            return callback;
        }
    });
    return ajv;
}
var _default = addAbsolutePathKeyword;
exports.default = _default;
}),
"[project]/node_modules/schema-utils/dist/keywords/undefinedAsNull.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
/** @typedef {import("ajv").Ajv} Ajv */ /**
 *
 * @param {Ajv} ajv
 * @param {string} keyword
 * @param {any} definition
 */ function addKeyword(ajv, keyword, definition) {
    let customRuleCode;
    try {
        // @ts-ignore
        // eslint-disable-next-line global-require
        customRuleCode = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv/lib/dotjs/custom.js [app-route] (ecmascript)"); // @ts-ignore
        const { RULES } = ajv;
        let ruleGroup;
        for(let i = 0; i < RULES.length; i++){
            const rg = RULES[i];
            if (typeof rg.type === "undefined") {
                ruleGroup = rg;
                break;
            }
        }
        const rule = {
            keyword,
            definition,
            custom: true,
            code: customRuleCode,
            implements: definition.implements
        };
        ruleGroup.rules.unshift(rule);
        RULES.custom[keyword] = rule;
        RULES.keywords[keyword] = true;
        RULES.all[keyword] = true;
    } catch (e) {}
}
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */ function addUndefinedAsNullKeyword(ajv) {
    // There is workaround for old versions of ajv, where `before` is not implemented
    addKeyword(ajv, "undefinedAsNull", {
        modifying: true,
        /**
     * @param {boolean} kwVal
     * @param {unknown} data
     * @param {any} parentSchema
     * @param {string} dataPath
     * @param {unknown} parentData
     * @param {number | string} parentDataProperty
     * @return {boolean}
     */ validate (kwVal, data, parentSchema, dataPath, parentData, parentDataProperty) {
            if (kwVal && parentSchema && typeof parentSchema.enum !== "undefined" && parentData && typeof parentDataProperty === "number") {
                const idx = /** @type {number} */ parentDataProperty;
                const parentDataRef = /** @type {any[]} */ parentData;
                if (typeof parentDataRef[idx] === "undefined") {
                    parentDataRef[idx] = null;
                }
            }
            return true;
        }
    });
    return ajv;
}
var _default = addUndefinedAsNullKeyword;
exports.default = _default;
}),
"[project]/node_modules/schema-utils/dist/util/Range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @typedef {[number, boolean]} RangeValue
 */ /**
 * @callback RangeValueCallback
 * @param {RangeValue} rangeValue
 * @returns {boolean}
 */ class Range {
    /**
   * @param {"left" | "right"} side
   * @param {boolean} exclusive
   * @returns {">" | ">=" | "<" | "<="}
   */ static getOperator(side, exclusive) {
        if (side === "left") {
            return exclusive ? ">" : ">=";
        }
        return exclusive ? "<" : "<=";
    }
    /**
   * @param {number} value
   * @param {boolean} logic is not logic applied
   * @param {boolean} exclusive is range exclusive
   * @returns {string}
   */ static formatRight(value, logic, exclusive) {
        if (logic === false) {
            return Range.formatLeft(value, !logic, !exclusive);
        }
        return `should be ${Range.getOperator("right", exclusive)} ${value}`;
    }
    /**
   * @param {number} value
   * @param {boolean} logic is not logic applied
   * @param {boolean} exclusive is range exclusive
   * @returns {string}
   */ static formatLeft(value, logic, exclusive) {
        if (logic === false) {
            return Range.formatRight(value, !logic, !exclusive);
        }
        return `should be ${Range.getOperator("left", exclusive)} ${value}`;
    }
    /**
   * @param {number} start left side value
   * @param {number} end right side value
   * @param {boolean} startExclusive is range exclusive from left side
   * @param {boolean} endExclusive is range exclusive from right side
   * @param {boolean} logic is not logic applied
   * @returns {string}
   */ static formatRange(start, end, startExclusive, endExclusive, logic) {
        let result = "should be";
        result += ` ${Range.getOperator(logic ? "left" : "right", logic ? startExclusive : !startExclusive)} ${start} `;
        result += logic ? "and" : "or";
        result += ` ${Range.getOperator(logic ? "right" : "left", logic ? endExclusive : !endExclusive)} ${end}`;
        return result;
    }
    /**
   * @param {Array<RangeValue>} values
   * @param {boolean} logic is not logic applied
   * @return {RangeValue} computed value and it's exclusive flag
   */ static getRangeValue(values, logic) {
        let minMax = logic ? Infinity : -Infinity;
        let j = -1;
        const predicate = logic ? /** @type {RangeValueCallback} */ ([value])=>value <= minMax : /** @type {RangeValueCallback} */ ([value])=>value >= minMax;
        for(let i = 0; i < values.length; i++){
            if (predicate(values[i])) {
                [minMax] = values[i];
                j = i;
            }
        }
        if (j > -1) {
            return values[j];
        }
        return [
            Infinity,
            true
        ];
    }
    constructor(){
        /** @type {Array<RangeValue>} */ this._left = [];
        /** @type {Array<RangeValue>} */ this._right = [];
    }
    /**
   * @param {number} value
   * @param {boolean=} exclusive
   */ left(value, exclusive = false) {
        this._left.push([
            value,
            exclusive
        ]);
    }
    /**
   * @param {number} value
   * @param {boolean=} exclusive
   */ right(value, exclusive = false) {
        this._right.push([
            value,
            exclusive
        ]);
    }
    /**
   * @param {boolean} logic is not logic applied
   * @return {string} "smart" range string representation
   */ format(logic = true) {
        const [start, leftExclusive] = Range.getRangeValue(this._left, logic);
        const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);
        if (!Number.isFinite(start) && !Number.isFinite(end)) {
            return "";
        }
        const realStart = leftExclusive ? start + 1 : start;
        const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6
        if (realStart === realEnd) {
            return `should be ${logic ? "" : "!"}= ${realStart}`;
        } // e.g. 4 < x < 
        if (Number.isFinite(start) && !Number.isFinite(end)) {
            return Range.formatLeft(start, logic, leftExclusive);
        } // e.g.  < x < 4
        if (!Number.isFinite(start) && Number.isFinite(end)) {
            return Range.formatRight(end, logic, rightExclusive);
        }
        return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);
    }
}
module.exports = Range;
}),
"[project]/node_modules/schema-utils/dist/util/hints.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/schema-utils/dist/util/Range.js [app-route] (ecmascript)");
/** @typedef {import("../validate").Schema} Schema */ /**
 * @param {Schema} schema
 * @param {boolean} logic
 * @return {string[]}
 */ module.exports.stringHints = function stringHints(schema, logic) {
    const hints = [];
    let type = "string";
    const currentSchema = {
        ...schema
    };
    if (!logic) {
        const tmpLength = currentSchema.minLength;
        const tmpFormat = currentSchema.formatMinimum;
        const tmpExclusive = currentSchema.formatExclusiveMaximum;
        currentSchema.minLength = currentSchema.maxLength;
        currentSchema.maxLength = tmpLength;
        currentSchema.formatMinimum = currentSchema.formatMaximum;
        currentSchema.formatMaximum = tmpFormat;
        currentSchema.formatExclusiveMaximum = !currentSchema.formatExclusiveMinimum;
        currentSchema.formatExclusiveMinimum = !tmpExclusive;
    }
    if (typeof currentSchema.minLength === "number") {
        if (currentSchema.minLength === 1) {
            type = "non-empty string";
        } else {
            const length = Math.max(currentSchema.minLength - 1, 0);
            hints.push(`should be longer than ${length} character${length > 1 ? "s" : ""}`);
        }
    }
    if (typeof currentSchema.maxLength === "number") {
        if (currentSchema.maxLength === 0) {
            type = "empty string";
        } else {
            const length = currentSchema.maxLength + 1;
            hints.push(`should be shorter than ${length} character${length > 1 ? "s" : ""}`);
        }
    }
    if (currentSchema.pattern) {
        hints.push(`should${logic ? "" : " not"} match pattern ${JSON.stringify(currentSchema.pattern)}`);
    }
    if (currentSchema.format) {
        hints.push(`should${logic ? "" : " not"} match format ${JSON.stringify(currentSchema.format)}`);
    }
    if (currentSchema.formatMinimum) {
        hints.push(`should be ${currentSchema.formatExclusiveMinimum ? ">" : ">="} ${JSON.stringify(currentSchema.formatMinimum)}`);
    }
    if (currentSchema.formatMaximum) {
        hints.push(`should be ${currentSchema.formatExclusiveMaximum ? "<" : "<="} ${JSON.stringify(currentSchema.formatMaximum)}`);
    }
    return [
        type
    ].concat(hints);
};
/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @return {string[]}
 */ module.exports.numberHints = function numberHints(schema, logic) {
    const hints = [
        schema.type === "integer" ? "integer" : "number"
    ];
    const range = new Range();
    if (typeof schema.minimum === "number") {
        range.left(schema.minimum);
    }
    if (typeof schema.exclusiveMinimum === "number") {
        range.left(schema.exclusiveMinimum, true);
    }
    if (typeof schema.maximum === "number") {
        range.right(schema.maximum);
    }
    if (typeof schema.exclusiveMaximum === "number") {
        range.right(schema.exclusiveMaximum, true);
    }
    const rangeFormat = range.format(logic);
    if (rangeFormat) {
        hints.push(rangeFormat);
    }
    if (typeof schema.multipleOf === "number") {
        hints.push(`should${logic ? "" : " not"} be multiple of ${schema.multipleOf}`);
    }
    return hints;
};
}),
"[project]/node_modules/schema-utils/dist/ValidationError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
const { stringHints, numberHints } = __turbopack_context__.r("[project]/node_modules/schema-utils/dist/util/hints.js [app-route] (ecmascript)");
/** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */ /** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */ /** @typedef {import("./validate").Schema} Schema */ /** @typedef {import("./validate").ValidationErrorConfiguration} ValidationErrorConfiguration */ /** @typedef {import("./validate").PostFormatter} PostFormatter */ /** @typedef {import("./validate").SchemaUtilErrorObject} SchemaUtilErrorObject */ /** @enum {number} */ const SPECIFICITY = {
    type: 1,
    not: 1,
    oneOf: 1,
    anyOf: 1,
    if: 1,
    enum: 1,
    const: 1,
    instanceof: 1,
    required: 2,
    pattern: 2,
    patternRequired: 2,
    format: 2,
    formatMinimum: 2,
    formatMaximum: 2,
    minimum: 2,
    exclusiveMinimum: 2,
    maximum: 2,
    exclusiveMaximum: 2,
    multipleOf: 2,
    uniqueItems: 2,
    contains: 2,
    minLength: 2,
    maxLength: 2,
    minItems: 2,
    maxItems: 2,
    minProperties: 2,
    maxProperties: 2,
    dependencies: 2,
    propertyNames: 2,
    additionalItems: 2,
    additionalProperties: 2,
    absolutePath: 2
};
/**
 *
 * @param {Array<SchemaUtilErrorObject>} array
 * @param {(item: SchemaUtilErrorObject) => number} fn
 * @returns {Array<SchemaUtilErrorObject>}
 */ function filterMax(array, fn) {
    const evaluatedMax = array.reduce((max, item)=>Math.max(max, fn(item)), 0);
    return array.filter((item)=>fn(item) === evaluatedMax);
}
/**
 *
 * @param {Array<SchemaUtilErrorObject>} children
 * @returns {Array<SchemaUtilErrorObject>}
 */ function filterChildren(children) {
    let newChildren = children;
    newChildren = filterMax(newChildren, /**
   *
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */ (error)=>error.dataPath ? error.dataPath.length : 0);
    newChildren = filterMax(newChildren, /**
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */ (error)=>SPECIFICITY[/** @type {keyof typeof SPECIFICITY} */ error.keyword] || 2);
    return newChildren;
}
/**
 * Find all children errors
 * @param {Array<SchemaUtilErrorObject>} children
 * @param {Array<string>} schemaPaths
 * @return {number} returns index of first child
 */ function findAllChildren(children, schemaPaths) {
    let i = children.length - 1;
    const predicate = /**
   * @param {string} schemaPath
   * @returns {boolean}
   */ (schemaPath)=>children[i].schemaPath.indexOf(schemaPath) !== 0;
    while(i > -1 && !schemaPaths.every(predicate)){
        if (children[i].keyword === "anyOf" || children[i].keyword === "oneOf") {
            const refs = extractRefs(children[i]);
            const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));
            i = childrenStart - 1;
        } else {
            i -= 1;
        }
    }
    return i + 1;
}
/**
 * Extracts all refs from schema
 * @param {SchemaUtilErrorObject} error
 * @return {Array<string>}
 */ function extractRefs(error) {
    const { schema } = error;
    if (!Array.isArray(schema)) {
        return [];
    }
    return schema.map(({ $ref })=>$ref).filter((s)=>s);
}
/**
 * Groups children by their first level parent (assuming that error is root)
 * @param {Array<SchemaUtilErrorObject>} children
 * @return {Array<SchemaUtilErrorObject>}
 */ function groupChildrenByFirstChild(children) {
    const result = [];
    let i = children.length - 1;
    while(i > 0){
        const child = children[i];
        if (child.keyword === "anyOf" || child.keyword === "oneOf") {
            const refs = extractRefs(child);
            const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));
            if (childrenStart !== i) {
                result.push(Object.assign({}, child, {
                    children: children.slice(childrenStart, i)
                }));
                i = childrenStart;
            } else {
                result.push(child);
            }
        } else {
            result.push(child);
        }
        i -= 1;
    }
    if (i === 0) {
        result.push(children[i]);
    }
    return result.reverse();
}
/**
 * @param {string} str
 * @param {string} prefix
 * @returns {string}
 */ function indent(str, prefix) {
    return str.replace(/\n(?!$)/g, `\n${prefix}`);
}
/**
 * @param {Schema} schema
 * @returns {schema is (Schema & {not: Schema})}
 */ function hasNotInSchema(schema) {
    return !!schema.not;
}
/**
 * @param {Schema} schema
 * @return {Schema}
 */ function findFirstTypedSchema(schema) {
    if (hasNotInSchema(schema)) {
        return findFirstTypedSchema(schema.not);
    }
    return schema;
}
/**
 * @param {Schema} schema
 * @return {boolean}
 */ function canApplyNot(schema) {
    const typedSchema = findFirstTypedSchema(schema);
    return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);
}
/**
 * @param {any} maybeObj
 * @returns {boolean}
 */ function isObject(maybeObj) {
    return typeof maybeObj === "object" && maybeObj !== null;
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeNumber(schema) {
    return schema.type === "number" || typeof schema.minimum !== "undefined" || typeof schema.exclusiveMinimum !== "undefined" || typeof schema.maximum !== "undefined" || typeof schema.exclusiveMaximum !== "undefined" || typeof schema.multipleOf !== "undefined";
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeInteger(schema) {
    return schema.type === "integer" || typeof schema.minimum !== "undefined" || typeof schema.exclusiveMinimum !== "undefined" || typeof schema.maximum !== "undefined" || typeof schema.exclusiveMaximum !== "undefined" || typeof schema.multipleOf !== "undefined";
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeString(schema) {
    return schema.type === "string" || typeof schema.minLength !== "undefined" || typeof schema.maxLength !== "undefined" || typeof schema.pattern !== "undefined" || typeof schema.format !== "undefined" || typeof schema.formatMinimum !== "undefined" || typeof schema.formatMaximum !== "undefined";
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeBoolean(schema) {
    return schema.type === "boolean";
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeArray(schema) {
    return schema.type === "array" || typeof schema.minItems === "number" || typeof schema.maxItems === "number" || typeof schema.uniqueItems !== "undefined" || typeof schema.items !== "undefined" || typeof schema.additionalItems !== "undefined" || typeof schema.contains !== "undefined";
}
/**
 * @param {Schema & {patternRequired?: Array<string>}} schema
 * @returns {boolean}
 */ function likeObject(schema) {
    return schema.type === "object" || typeof schema.minProperties !== "undefined" || typeof schema.maxProperties !== "undefined" || typeof schema.required !== "undefined" || typeof schema.properties !== "undefined" || typeof schema.patternProperties !== "undefined" || typeof schema.additionalProperties !== "undefined" || typeof schema.dependencies !== "undefined" || typeof schema.propertyNames !== "undefined" || typeof schema.patternRequired !== "undefined";
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */ function likeNull(schema) {
    return schema.type === "null";
}
/**
 * @param {string} type
 * @returns {string}
 */ function getArticle(type) {
    if (/^[aeiou]/i.test(type)) {
        return "an";
    }
    return "a";
}
/**
 * @param {Schema=} schema
 * @returns {string}
 */ function getSchemaNonTypes(schema) {
    if (!schema) {
        return "";
    }
    if (!schema.type) {
        if (likeNumber(schema) || likeInteger(schema)) {
            return " | should be any non-number";
        }
        if (likeString(schema)) {
            return " | should be any non-string";
        }
        if (likeArray(schema)) {
            return " | should be any non-array";
        }
        if (likeObject(schema)) {
            return " | should be any non-object";
        }
    }
    return "";
}
/**
 * @param {Array<string>} hints
 * @returns {string}
 */ function formatHints(hints) {
    return hints.length > 0 ? `(${hints.join(", ")})` : "";
}
/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @returns {string[]}
 */ function getHints(schema, logic) {
    if (likeNumber(schema) || likeInteger(schema)) {
        return numberHints(schema, logic);
    } else if (likeString(schema)) {
        return stringHints(schema, logic);
    }
    return [];
}
class ValidationError extends Error {
    /**
   * @param {Array<SchemaUtilErrorObject>} errors
   * @param {Schema} schema
   * @param {ValidationErrorConfiguration} configuration
   */ constructor(errors, schema, configuration = {}){
        super();
        /** @type {string} */ this.name = "ValidationError";
        /** @type {Array<SchemaUtilErrorObject>} */ this.errors = errors;
        /** @type {Schema} */ this.schema = schema;
        let headerNameFromSchema;
        let baseDataPathFromSchema;
        if (schema.title && (!configuration.name || !configuration.baseDataPath)) {
            const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);
            if (splittedTitleFromSchema) {
                if (!configuration.name) {
                    [, headerNameFromSchema] = splittedTitleFromSchema;
                }
                if (!configuration.baseDataPath) {
                    [, , baseDataPathFromSchema] = splittedTitleFromSchema;
                }
            }
        }
        /** @type {string} */ this.headerName = configuration.name || headerNameFromSchema || "Object";
        /** @type {string} */ this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || "configuration";
        /** @type {PostFormatter | null} */ this.postFormatter = configuration.postFormatter || null;
        const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\n`;
        /** @type {string} */ this.message = `${header}${this.formatValidationErrors(errors)}`;
        Error.captureStackTrace(this, this.constructor);
    }
    /**
   * @param {string} path
   * @returns {Schema}
   */ getSchemaPart(path) {
        const newPath = path.split("/");
        let schemaPart = this.schema;
        for(let i = 1; i < newPath.length; i++){
            const inner = schemaPart[/** @type {keyof Schema} */ newPath[i]];
            if (!inner) {
                break;
            }
            schemaPart = inner;
        }
        return schemaPart;
    }
    /**
   * @param {Schema} schema
   * @param {boolean} logic
   * @param {Array<Object>} prevSchemas
   * @returns {string}
   */ formatSchema(schema, logic = true, prevSchemas = []) {
        let newLogic = logic;
        const formatInnerSchema = /**
     *
     * @param {Object} innerSchema
     * @param {boolean=} addSelf
     * @returns {string}
     */ (innerSchema, addSelf)=>{
            if (!addSelf) {
                return this.formatSchema(innerSchema, newLogic, prevSchemas);
            }
            if (prevSchemas.includes(innerSchema)) {
                return "(recursive)";
            }
            return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));
        };
        if (hasNotInSchema(schema) && !likeObject(schema)) {
            if (canApplyNot(schema.not)) {
                newLogic = !logic;
                return formatInnerSchema(schema.not);
            }
            const needApplyLogicHere = !schema.not.not;
            const prefix = logic ? "" : "non ";
            newLogic = !logic;
            return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);
        }
        if (/** @type {Schema & {instanceof: string | Array<string>}} */ schema.instanceof) {
            const { instanceof: value } = /** @type {Schema & {instanceof: string | Array<string>}} */ schema;
            const values = !Array.isArray(value) ? [
                value
            ] : value;
            return values.map(/**
       * @param {string} item
       * @returns {string}
       */ (item)=>item === "Function" ? "function" : item).join(" | ");
        }
        if (schema.enum) {
            const enumValues = /** @type {Array<any>} */ schema.enum.map((item)=>{
                if (item === null && schema.undefinedAsNull) {
                    return `${JSON.stringify(item)} | undefined`;
                }
                return JSON.stringify(item);
            }).join(" | ");
            return `${enumValues}`;
        }
        if (typeof schema.const !== "undefined") {
            return JSON.stringify(schema.const);
        }
        if (schema.oneOf) {
            return /** @type {Array<Schema>} */ schema.oneOf.map((item)=>formatInnerSchema(item, true)).join(" | ");
        }
        if (schema.anyOf) {
            return /** @type {Array<Schema>} */ schema.anyOf.map((item)=>formatInnerSchema(item, true)).join(" | ");
        }
        if (schema.allOf) {
            return /** @type {Array<Schema>} */ schema.allOf.map((item)=>formatInnerSchema(item, true)).join(" & ");
        }
        if (/** @type {JSONSchema7} */ schema.if) {
            const { if: ifValue, then: thenValue, else: elseValue } = /** @type {JSONSchema7} */ schema;
            return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ""}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ""}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ""}`;
        }
        if (schema.$ref) {
            return formatInnerSchema(this.getSchemaPart(schema.$ref), true);
        }
        if (likeNumber(schema) || likeInteger(schema)) {
            const [type, ...hints] = getHints(schema, logic);
            const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ""}`;
            return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;
        }
        if (likeString(schema)) {
            const [type, ...hints] = getHints(schema, logic);
            const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ""}`;
            return logic ? str : str === "string" ? "non-string" : `non-string | ${str}`;
        }
        if (likeBoolean(schema)) {
            return `${logic ? "" : "non-"}boolean`;
        }
        if (likeArray(schema)) {
            // not logic already applied in formatValidationError
            newLogic = true;
            const hints = [];
            if (typeof schema.minItems === "number") {
                hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? "s" : ""}`);
            }
            if (typeof schema.maxItems === "number") {
                hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? "s" : ""}`);
            }
            if (schema.uniqueItems) {
                hints.push("should not have duplicate items");
            }
            const hasAdditionalItems = typeof schema.additionalItems === "undefined" || Boolean(schema.additionalItems);
            let items = "";
            if (schema.items) {
                if (Array.isArray(schema.items) && schema.items.length > 0) {
                    items = `${/** @type {Array<Schema>} */ schema.items.map((item)=>formatInnerSchema(item)).join(", ")}`;
                    if (hasAdditionalItems) {
                        if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {
                            hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);
                        }
                    }
                } else if (schema.items && Object.keys(schema.items).length > 0) {
                    // "additionalItems" is ignored
                    items = `${formatInnerSchema(schema.items)}`;
                } else {
                    // Fallback for empty `items` value
                    items = "any";
                }
            } else {
                // "additionalItems" is ignored
                items = "any";
            }
            if (schema.contains && Object.keys(schema.contains).length > 0) {
                hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);
            }
            return `[${items}${hasAdditionalItems ? ", ..." : ""}]${hints.length > 0 ? ` (${hints.join(", ")})` : ""}`;
        }
        if (likeObject(schema)) {
            // not logic already applied in formatValidationError
            newLogic = true;
            const hints = [];
            if (typeof schema.minProperties === "number") {
                hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? "properties" : "property"}`);
            }
            if (typeof schema.maxProperties === "number") {
                hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? "properties" : "property"}`);
            }
            if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {
                const patternProperties = Object.keys(schema.patternProperties);
                hints.push(`additional property names should match pattern${patternProperties.length > 1 ? "s" : ""} ${patternProperties.map((pattern)=>JSON.stringify(pattern)).join(" | ")}`);
            }
            const properties = schema.properties ? Object.keys(schema.properties) : [];
            const required = schema.required ? schema.required : [];
            const allProperties = [
                ...new Set(/** @type {Array<string>} */ [].concat(required).concat(properties))
            ];
            const objectStructure = allProperties.map((property)=>{
                const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check
                // Maybe we should output type of property (`foo: string`), but it is looks very unreadable
                return `${property}${isRequired ? "" : "?"}`;
            }).concat(typeof schema.additionalProperties === "undefined" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [
                `<key>: ${formatInnerSchema(schema.additionalProperties)}`
            ] : [
                ""
            ] : []).join(", ");
            const { dependencies, propertyNames, patternRequired } = /** @type {Schema & {patternRequired?: Array<string>;}} */ schema;
            if (dependencies) {
                Object.keys(dependencies).forEach((dependencyName)=>{
                    const dependency = dependencies[dependencyName];
                    if (Array.isArray(dependency)) {
                        hints.push(`should have ${dependency.length > 1 ? "properties" : "property"} ${dependency.map((dep)=>`'${dep}'`).join(", ")} when property '${dependencyName}' is present`);
                    } else {
                        hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);
                    }
                });
            }
            if (propertyNames && Object.keys(propertyNames).length > 0) {
                hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);
            }
            if (patternRequired && patternRequired.length > 0) {
                hints.push(`should have property matching pattern ${patternRequired.map(/**
         * @param {string} item
         * @returns {string}
         */ (item)=>JSON.stringify(item))}`);
            }
            return `object {${objectStructure ? ` ${objectStructure} ` : ""}}${hints.length > 0 ? ` (${hints.join(", ")})` : ""}`;
        }
        if (likeNull(schema)) {
            return `${logic ? "" : "non-"}null`;
        }
        if (Array.isArray(schema.type)) {
            // not logic already applied in formatValidationError
            return `${schema.type.join(" | ")}`;
        } // Fallback for unknown keywords
        // not logic already applied in formatValidationError
        /* istanbul ignore next */ return JSON.stringify(schema, null, 2);
    }
    /**
   * @param {Schema=} schemaPart
   * @param {(boolean | Array<string>)=} additionalPath
   * @param {boolean=} needDot
   * @param {boolean=} logic
   * @returns {string}
   */ getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {
        if (!schemaPart) {
            return "";
        }
        if (Array.isArray(additionalPath)) {
            for(let i = 0; i < additionalPath.length; i++){
                /** @type {Schema | undefined} */ const inner = schemaPart[/** @type {keyof Schema} */ additionalPath[i]];
                if (inner) {
                    // eslint-disable-next-line no-param-reassign
                    schemaPart = inner;
                } else {
                    break;
                }
            }
        }
        while(schemaPart.$ref){
            // eslint-disable-next-line no-param-reassign
            schemaPart = this.getSchemaPart(schemaPart.$ref);
        }
        let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? "." : ""}`;
        if (schemaPart.description) {
            schemaText += `\n-> ${schemaPart.description}`;
        }
        if (schemaPart.link) {
            schemaText += `\n-> Read more at ${schemaPart.link}`;
        }
        return schemaText;
    }
    /**
   * @param {Schema=} schemaPart
   * @returns {string}
   */ getSchemaPartDescription(schemaPart) {
        if (!schemaPart) {
            return "";
        }
        while(schemaPart.$ref){
            // eslint-disable-next-line no-param-reassign
            schemaPart = this.getSchemaPart(schemaPart.$ref);
        }
        let schemaText = "";
        if (schemaPart.description) {
            schemaText += `\n-> ${schemaPart.description}`;
        }
        if (schemaPart.link) {
            schemaText += `\n-> Read more at ${schemaPart.link}`;
        }
        return schemaText;
    }
    /**
   * @param {SchemaUtilErrorObject} error
   * @returns {string}
   */ formatValidationError(error) {
        const { keyword, dataPath: errorDataPath } = error;
        const dataPath = `${this.baseDataPath}${errorDataPath}`;
        switch(keyword){
            case "type":
                {
                    const { parentSchema, params } = error; // eslint-disable-next-line default-case
                    switch(/** @type {import("ajv").TypeParams} */ params.type){
                        case "number":
                            return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
                        case "integer":
                            return `${dataPath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;
                        case "string":
                            return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
                        case "boolean":
                            return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
                        case "array":
                            return `${dataPath} should be an array:\n${this.getSchemaPartText(parentSchema)}`;
                        case "object":
                            return `${dataPath} should be an object:\n${this.getSchemaPartText(parentSchema)}`;
                        case "null":
                            return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
                        default:
                            return `${dataPath} should be:\n${this.getSchemaPartText(parentSchema)}`;
                    }
                }
            case "instanceof":
                {
                    const { parentSchema } = error;
                    return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;
                }
            case "pattern":
                {
                    const { params, parentSchema } = error;
                    const { pattern } = /** @type {import("ajv").PatternParams} */ params;
                    return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "format":
                {
                    const { params, parentSchema } = error;
                    const { format } = /** @type {import("ajv").FormatParams} */ params;
                    return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "formatMinimum":
            case "formatMaximum":
                {
                    const { params, parentSchema } = error;
                    const { comparison, limit } = /** @type {import("ajv").ComparisonParams} */ params;
                    return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "minimum":
            case "maximum":
            case "exclusiveMinimum":
            case "exclusiveMaximum":
                {
                    const { parentSchema, params } = error;
                    const { comparison, limit } = /** @type {import("ajv").ComparisonParams} */ params;
                    const [, ...hints] = getHints(/** @type {Schema} */ parentSchema, true);
                    if (hints.length === 0) {
                        hints.push(`should be ${comparison} ${limit}`);
                    }
                    return `${dataPath} ${hints.join(" ")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "multipleOf":
                {
                    const { params, parentSchema } = error;
                    const { multipleOf } = /** @type {import("ajv").MultipleOfParams} */ params;
                    return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "patternRequired":
                {
                    const { params, parentSchema } = error;
                    const { missingPattern } = /** @type {import("ajv").PatternRequiredParams} */ params;
                    return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "minLength":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    if (limit === 1) {
                        return `${dataPath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                    }
                    const length = limit - 1;
                    return `${dataPath} should be longer than ${length} character${length > 1 ? "s" : ""}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "minItems":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    if (limit === 1) {
                        return `${dataPath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                    }
                    return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "minProperties":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    if (limit === 1) {
                        return `${dataPath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                    }
                    return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "maxLength":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    const max = limit + 1;
                    return `${dataPath} should be shorter than ${max} character${max > 1 ? "s" : ""}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "maxItems":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "maxProperties":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "uniqueItems":
                {
                    const { params, parentSchema } = error;
                    const { i } = /** @type {import("ajv").UniqueItemsParams} */ params;
                    return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "additionalItems":
                {
                    const { params, parentSchema } = error;
                    const { limit } = /** @type {import("ajv").LimitParams} */ params;
                    return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\n${this.getSchemaPartText(parentSchema)}`;
                }
            case "contains":
                {
                    const { parentSchema } = error;
                    return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, [
                        "contains"
                    ])} item${getSchemaNonTypes(parentSchema)}.`;
                }
            case "required":
                {
                    const { parentSchema, params } = error;
                    const missingProperty = /** @type {import("ajv").DependenciesParams} */ params.missingProperty.replace(/^\./, "");
                    const hasProperty = parentSchema && Boolean(/** @type {Schema} */ parentSchema.properties && /** @type {Schema} */ parentSchema.properties[missingProperty]);
                    return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\n${this.getSchemaPartText(parentSchema, [
                        "properties",
                        missingProperty
                    ])}` : this.getSchemaPartDescription(parentSchema)}`;
                }
            case "additionalProperties":
                {
                    const { params, parentSchema } = error;
                    const { additionalProperty } = /** @type {import("ajv").AdditionalPropertiesParams} */ params;
                    return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\n${this.getSchemaPartText(parentSchema)}`;
                }
            case "dependencies":
                {
                    const { params, parentSchema } = error;
                    const { property, deps } = /** @type {import("ajv").DependenciesParams} */ params;
                    const dependencies = deps.split(",").map(/**
           * @param {string} dep
           * @returns {string}
           */ (dep)=>`'${dep.trim()}'`).join(", ");
                    return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "propertyNames":
                {
                    const { params, parentSchema, schema } = error;
                    const { propertyName } = /** @type {import("ajv").PropertyNamesParams} */ params;
                    return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;
                }
            case "enum":
                {
                    const { parentSchema } = error;
                    if (parentSchema && /** @type {Schema} */ parentSchema.enum && /** @type {Schema} */ parentSchema.enum.length === 1) {
                        return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;
                    }
                    return `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
                }
            case "const":
                {
                    const { parentSchema } = error;
                    return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;
                }
            case "not":
                {
                    const postfix = likeObject(/** @type {Schema} */ error.parentSchema) ? `\n${this.getSchemaPartText(error.parentSchema)}` : "";
                    const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);
                    if (canApplyNot(error.schema)) {
                        return `${dataPath} should be any ${schemaOutput}${postfix}.`;
                    }
                    const { schema, parentSchema } = error;
                    return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\n${this.getSchemaPartText(parentSchema)}` : ""}`;
                }
            case "oneOf":
            case "anyOf":
                {
                    const { parentSchema, children } = error;
                    if (children && children.length > 0) {
                        if (error.schema.length === 1) {
                            const lastChild = children[children.length - 1];
                            const remainingChildren = children.slice(0, children.length - 1);
                            return this.formatValidationError(Object.assign({}, lastChild, {
                                children: remainingChildren,
                                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)
                            }));
                        }
                        let filteredChildren = filterChildren(children);
                        if (filteredChildren.length === 1) {
                            return this.formatValidationError(filteredChildren[0]);
                        }
                        filteredChildren = groupChildrenByFirstChild(filteredChildren);
                        return `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}\nDetails:\n${filteredChildren.map(/**
             * @param {SchemaUtilErrorObject} nestedError
             * @returns {string}
             */ (nestedError)=>` * ${indent(this.formatValidationError(nestedError), "   ")}`).join("\n")}`;
                    }
                    return `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
                }
            case "if":
                {
                    const { params, parentSchema } = error;
                    const { failingKeyword } = /** @type {import("ajv").IfParams} */ params;
                    return `${dataPath} should match "${failingKeyword}" schema:\n${this.getSchemaPartText(parentSchema, [
                        failingKeyword
                    ])}`;
                }
            case "absolutePath":
                {
                    const { message, parentSchema } = error;
                    return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;
                }
            /* istanbul ignore next */ default:
                {
                    const { message, parentSchema } = error;
                    const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords
                    // Fallback for unknown keywords
                    return `${dataPath} ${message} (${ErrorInJSON}).\n${this.getSchemaPartText(parentSchema, false)}`;
                }
        }
    }
    /**
   * @param {Array<SchemaUtilErrorObject>} errors
   * @returns {string}
   */ formatValidationErrors(errors) {
        return errors.map((error)=>{
            let formattedError = this.formatValidationError(error);
            if (this.postFormatter) {
                formattedError = this.postFormatter(formattedError, error);
            }
            return ` - ${indent(formattedError, "   ")}`;
        }).join("\n");
    }
}
var _default = ValidationError;
exports.default = _default;
}),
"[project]/node_modules/schema-utils/dist/validate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.enableValidation = enableValidation;
exports.disableValidation = disableValidation;
exports.needValidate = needValidate;
Object.defineProperty(exports, "ValidationError", {
    enumerable: true,
    get: function() {
        return _ValidationError.default;
    }
});
var _absolutePath = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/schema-utils/dist/keywords/absolutePath.js [app-route] (ecmascript)"));
var _undefinedAsNull = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/schema-utils/dist/keywords/undefinedAsNull.js [app-route] (ecmascript)"));
var _ValidationError = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/schema-utils/dist/ValidationError.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * @template T
 * @param fn {(function(): any) | undefined}
 * @returns {function(): T}
 */ const memoize = (fn)=>{
    let cache = false;
    /** @type {T} */ let result;
    return ()=>{
        if (cache) {
            return result;
        }
        result = /** @type {function(): any} */ fn();
        cache = true; // Allow to clean up memory for fn
        // and all dependent resources
        // eslint-disable-next-line no-undefined, no-param-reassign
        fn = undefined;
        return result;
    };
};
const getAjv = memoize(()=>{
    // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).
    // eslint-disable-next-line global-require
    const Ajv = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv/lib/ajv.js [app-route] (ecmascript)"); // eslint-disable-next-line global-require
    const ajvKeywords = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/index.js [app-route] (ecmascript)");
    const ajv = new Ajv({
        allErrors: true,
        verbose: true,
        $data: true
    });
    ajvKeywords(ajv, [
        "instanceof",
        "formatMinimum",
        "formatMaximum",
        "patternRequired"
    ]); // Custom keywords
    (0, _absolutePath.default)(ajv);
    (0, _undefinedAsNull.default)(ajv);
    return ajv;
});
/** @typedef {import("json-schema").JSONSchema4} JSONSchema4 */ /** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */ /** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */ /** @typedef {import("ajv").ErrorObject} ErrorObject */ /** @typedef {import("ajv").ValidateFunction} ValidateFunction */ /**
 * @typedef {Object} Extend
 * @property {number=} formatMinimum
 * @property {number=} formatMaximum
 * @property {boolean=} formatExclusiveMinimum
 * @property {boolean=} formatExclusiveMaximum
 * @property {string=} link
 * @property {boolean=} undefinedAsNull
 */ /** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend} Schema */ /** @typedef {ErrorObject & { children?: Array<ErrorObject>}} SchemaUtilErrorObject */ /**
 * @callback PostFormatter
 * @param {string} formattedError
 * @param {SchemaUtilErrorObject} error
 * @returns {string}
 */ /**
 * @typedef {Object} ValidationErrorConfiguration
 * @property {string=} name
 * @property {string=} baseDataPath
 * @property {PostFormatter=} postFormatter
 */ /**
 * @param {SchemaUtilErrorObject} error
 * @param {number} idx
 * @returns {SchemaUtilErrorObject}
 */ function applyPrefix(error, idx) {
    // eslint-disable-next-line no-param-reassign
    error.dataPath = `[${idx}]${error.dataPath}`;
    if (error.children) {
        error.children.forEach((err)=>applyPrefix(err, idx));
    }
    return error;
}
let skipValidation = false; // We use `process.env.SKIP_VALIDATION` because you can have multiple `schema-utils` with different version,
// so we want to disable it globally, `process.env` doesn't supported by browsers, so we have the local `skipValidation` variables
// Enable validation
function enableValidation() {
    skipValidation = false; // Disable validation for any versions
    if ("TURBOPACK compile-time truthy", 1) {
        process.env.SKIP_VALIDATION = "n";
    }
} // Disable validation
function disableValidation() {
    skipValidation = true;
    if ("TURBOPACK compile-time truthy", 1) {
        process.env.SKIP_VALIDATION = "y";
    }
} // Check if we need to confirm
function needValidate() {
    if (skipValidation) {
        return false;
    }
    if (process && process.env && process.env.SKIP_VALIDATION) {
        const value = process.env.SKIP_VALIDATION.trim();
        if (/^(?:y|yes|true|1|on)$/i.test(value)) {
            return false;
        }
        if (/^(?:n|no|false|0|off)$/i.test(value)) {
            return true;
        }
    }
    return true;
}
/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @param {ValidationErrorConfiguration=} configuration
 * @returns {void}
 */ function validate(schema, options, configuration) {
    if (!needValidate()) {
        return;
    }
    let errors = [];
    if (Array.isArray(options)) {
        for(let i = 0; i <= options.length - 1; i++){
            errors.push(...validateObject(schema, options[i]).map((err)=>applyPrefix(err, i)));
        }
    } else {
        errors = validateObject(schema, options);
    }
    if (errors.length > 0) {
        throw new _ValidationError.default(errors, schema, configuration);
    }
}
/** @typedef {WeakMap<Schema, ValidateFunction>} */ const schemaCache = new WeakMap();
/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @returns {Array<SchemaUtilErrorObject>}
 */ function validateObject(schema, options) {
    let compiledSchema = schemaCache.get(schema);
    if (!compiledSchema) {
        compiledSchema = getAjv().compile(schema);
        schemaCache.set(schema, compiledSchema);
    }
    const valid = compiledSchema(options);
    if (valid) return [];
    return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];
}
/**
 * @param {Array<ErrorObject>} errors
 * @returns {Array<SchemaUtilErrorObject>}
 */ function filterErrors(errors) {
    /** @type {Array<SchemaUtilErrorObject>} */ let newErrors = [];
    for (const error of /** @type {Array<SchemaUtilErrorObject>} */ errors){
        const { dataPath } = error;
        /** @type {Array<SchemaUtilErrorObject>} */ let children = [];
        newErrors = newErrors.filter((oldError)=>{
            if (oldError.dataPath.includes(dataPath)) {
                if (oldError.children) {
                    children = children.concat(oldError.children.slice(0));
                } // eslint-disable-next-line no-undefined, no-param-reassign
                oldError.children = undefined;
                children.push(oldError);
                return false;
            }
            return true;
        });
        if (children.length) {
            error.children = children;
        }
        newErrors.push(error);
    }
    return newErrors;
}
}),
"[project]/node_modules/schema-utils/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { validate, ValidationError, enableValidation, disableValidation, needValidate } = __turbopack_context__.r("[project]/node_modules/schema-utils/dist/validate.js [app-route] (ecmascript)");
module.exports = {
    validate,
    ValidationError,
    enableValidation,
    disableValidation,
    needValidate
};
}),
"[project]/node_modules/uri-js/dist/es5/uri.all.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports) : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function(exports1) {
    'use strict';
    function merge() {
        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){
            sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for(var x = 1; x < xl; ++x){
                sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join('');
        } else {
            return sets[0];
        }
    }
    function subexp(str) {
        return "(?:" + str + ")";
    }
    function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
        return str.toUpperCase();
    }
    function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [
            obj
        ] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
        var obj = target;
        if (source) {
            for(var key in source){
                obj[key] = source[key];
            }
        }
        return obj;
    }
    function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), //case-insensitive
        LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), //expanded
        GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", //subset, excludes bidi control characters
        IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", //subset
        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), //relaxed parsing rules
        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), //                           6( h16 ":" ) ls32
        IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), //                      "::" 5( h16 ":" ) ls32
        IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), //[               h16 ] "::" 4( h16 ":" ) ls32
        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), //[ *4( h16 ":" ) h16 ] "::"              ls32
        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), //[ *5( h16 ":" ) h16 ] "::"              h16
        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), //[ *6( h16 ":" ) h16 ] "::"
        IPV6ADDRESS$ = subexp([
            IPV6ADDRESS1$,
            IPV6ADDRESS2$,
            IPV6ADDRESS3$,
            IPV6ADDRESS4$,
            IPV6ADDRESS5$,
            IPV6ADDRESS6$,
            IPV6ADDRESS7$,
            IPV6ADDRESS8$,
            IPV6ADDRESS9$
        ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), //RFC 6874
        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), //RFC 6874
        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), //RFC 6874, with relaxed parsing rules
        IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), //RFC 6874
        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), //simplified
        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified
        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified
        PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;
            try {
                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) {
                return arr;
            } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
            } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
        };
    }();
    var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
            return arr2;
        } else {
            return Array.from(arr);
        }
    };
    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
    /** Bootstring parameters */ var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'
    /** Regular expressions */ var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
    /** Error messages */ var errors = {
        'overflow': 'Overflow: input needs wider integers to process',
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        'invalid-input': 'Invalid input'
    };
    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    /*--------------------------------------------------------------------------*/ /**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */ function error$1(type) {
        throw new RangeError(errors[type]);
    }
    /**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */ function map(array, fn) {
        var result = [];
        var length = array.length;
        while(length--){
            result[length] = fn(array[length]);
        }
        return result;
    }
    /**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */ function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
    }
    /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */ function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while(counter < length){
            var value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // It's a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                    // Low surrogate.
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // It's an unmatched surrogate; only append this code unit, in case the
                    // next code unit is the high surrogate of a surrogate pair.
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */ var ucs2encode = function ucs2encode(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    /**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */ var basicToDigit = function basicToDigit(codePoint) {
        if (codePoint - 0x30 < 0x0A) {
            return codePoint - 0x16;
        }
        if (codePoint - 0x41 < 0x1A) {
            return codePoint - 0x41;
        }
        if (codePoint - 0x61 < 0x1A) {
            return codePoint - 0x61;
        }
        return base;
    };
    /**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */ var digitToBasic = function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    /**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */ var adapt = function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base){
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    /**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */ var decode = function decode(input) {
        // Don't use UCS-2.
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }
        for(var j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error$1('not-basic');
            }
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i;
            for(var w = 1, k = base;; k += base){
                if (index >= inputLength) {
                    error$1('invalid-input');
                }
                var digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error$1('overflow');
                }
                i += digit * w;
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) {
                    break;
                }
                var baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error$1('overflow');
                }
                w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error$1('overflow');
            }
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
    };
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */ var encode = function encode(input) {
        var output = [];
        // Convert the input in UCS-2 to an array of Unicode code points.
        input = ucs2decode(input);
        // Cache the length.
        var inputLength = input.length;
        // Initialize the state.
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        // Handle the basic code points.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _currentValue2 = _step.value;
                if (_currentValue2 < 0x80) {
                    output.push(stringFromCharCode(_currentValue2));
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string with a delimiter unless it's empty.
        if (basicLength) {
            output.push(delimiter);
        }
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;
            try {
                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var currentValue = _step2.value;
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow.
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error$1('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;
            try {
                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                    var _currentValue = _step3.value;
                    if (_currentValue < n && ++delta > maxInt) {
                        error$1('overflow');
                    }
                    if (_currentValue == n) {
                        // Represent delta as a generalized variable-length integer.
                        var q = delta;
                        for(var k = base;; k += base){
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            var qMinusT = q - t;
                            var baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally{
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    };
    /**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */ var toUnicode = function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    };
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */ var toASCII = function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
    };
    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {
        /**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */ 'version': '2.1.0',
        /**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */ 'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
    };
    /**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */ /**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */ var SCHEMES = {};
    function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
    }
    function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while(i < il){
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
            } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                } else {
                    newStr += str.substr(i, 6);
                }
                i += 6;
            } else if (c >= 224) {
                if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                } else {
                    newStr += str.substr(i, 9);
                }
                i += 9;
            } else {
                newStr += str.substr(i, 3);
                i += 3;
            }
        }
        return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
    }
    function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
            return host;
        }
    }
    function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for(var x = 0; x < fieldCount; ++x){
                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
            }
            if (isLastFieldIPv4Address) {
                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
                if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (lastLongest && lastLongest.index + lastLongest.length === index) {
                        lastLongest.length++;
                    } else {
                        acc.push({
                            index: index,
                            length: 1
                        });
                    }
                }
                return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
                return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
                newHost = fields.join(":");
            }
            if (zone) {
                newHost += "%" + zone;
            }
            return newHost;
        } else {
            return host;
        }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) {
                    components.port = matches[5];
                }
            } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) {
                    components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                }
            }
            if (components.host) {
                //normalize IP hosts
                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            //determine reference type
            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
                components.reference = "same-document";
            } else if (components.scheme === undefined) {
                components.reference = "relative";
            } else if (components.fragment === undefined) {
                components.reference = "absolute";
            } else {
                components.reference = "uri";
            }
            //check for reference errors
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //check if scheme can't handle IRIs
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                    }
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
                //normalize encodings
                _normalizeComponentEncoding(components, protocol);
            }
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) {
                schemeHandler.parse(components, options);
            }
        } else {
            components.error = components.error || "URI can not be parsed.";
        }
        return components;
    }
    function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
        }
        if (components.host !== undefined) {
            //normalize IP hosts, add brackets and escape zone separator for IPv6
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
                return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
        var output = [];
        while(input.length){
            if (input.match(RDS1)) {
                input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
                input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
            } else if (input === "." || input === "..") {
                input = "";
            } else {
                var im = input.match(RDS5);
                if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else {
                    throw new Error("Unexpected dot segment condition");
                }
            }
        }
        return output.join("");
    }
    function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
            if (options.reference !== "suffix") {
                uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
                uriTokens.push("/");
            }
        }
        if (components.path !== undefined) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                s = removeDotSegments(s);
            }
            if (authority === undefined) {
                s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
            }
            uriTokens.push(s);
        }
        if (components.query !== undefined) {
            uriTokens.push("?");
            uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
    }
    function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
            base = parse(serialize(base, options), options); //normalize base components
            relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
            } else {
                if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) {
                        target.query = relative.query;
                    } else {
                        target.query = base.query;
                    }
                } else {
                    if (relative.path.charAt(0) === "/") {
                        target.path = removeDotSegments(relative.path);
                    } else {
                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                            target.path = "/" + relative.path;
                        } else if (!base.path) {
                            target.path = relative.path;
                        } else {
                            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                        }
                        target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
            }
            target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
    }
    function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({
            scheme: 'null'
        }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
        if (typeof uri === "string") {
            uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
            uri = parse(serialize(uri, options), options);
        }
        return uri;
    }
    function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
            uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
            uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
        }
        return uriA === uriB;
    }
    function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
            //report missing host
            if (!components.host) {
                components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
        },
        serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            //normalize the default port
            if (components.port === (secure ? 443 : 80) || components.port === "") {
                components.port = undefined;
            }
            //normalize the empty path
            if (!components.path) {
                components.path = "/";
            }
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components;
        }
    };
    var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
    };
    function isSecure(wsComponents) {
        return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    //RFC 6455
    var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse(components, options) {
            var wsComponents = components;
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents);
            //construct resouce name
            wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
            wsComponents.path = undefined;
            wsComponents.query = undefined;
            return wsComponents;
        },
        serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                wsComponents.port = undefined;
            }
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === 'boolean') {
                wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
                wsComponents.secure = undefined;
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split('?'), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                wsComponents.path = path && path !== '/' ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
            }
            //forbid fragment component
            wsComponents.fragment = undefined;
            return wsComponents;
        }
    };
    var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    //RFC 3986
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (("TURBOPACK compile-time truthy", 1) ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "TURBOPACK unreachable") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
    //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
    //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
    //const VCHAR$$ = "[\\x21-\\x7E]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
    //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
    //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
    //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = undefined;
            if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for(var x = 0, xl = hfields.length; x < xl; ++x){
                    var hfield = hfields[x].split("=");
                    switch(hfield[0]){
                        case "to":
                            var toAddrs = hfield[1].split(",");
                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){
                                to.push(toAddrs[_x]);
                            }
                            break;
                        case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;
                        case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;
                        default:
                            unknownHeaders = true;
                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            break;
                    }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = undefined;
            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                    } catch (e) {
                        mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                    }
                } else {
                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                }
                to[_x2] = addr.join("@");
            }
            return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
                for(var x = 0, xl = to.length; x < xl; ++x){
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1);
                    //convert IDN via punycode
                    try {
                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                    } catch (e) {
                        components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                    to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for(var name in headers){
                if (headers[name] !== O[name]) {
                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                }
            }
            if (fields.length) {
                components.query = fields.join("&");
            }
            return components;
        }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    //RFC 2141
    var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) {
                    urnComponents = schemeHandler.parse(urnComponents, options);
                }
            } else {
                urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
                urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
        }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    //RFC 4122
    var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = undefined;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents;
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
        }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports1.SCHEMES = SCHEMES;
    exports1.pctEncChar = pctEncChar;
    exports1.pctDecChars = pctDecChars;
    exports1.parse = parse;
    exports1.removeDotSegments = removeDotSegments;
    exports1.serialize = serialize;
    exports1.resolveComponents = resolveComponents;
    exports1.resolve = resolve;
    exports1.normalize = normalize;
    exports1.equal = equal;
    exports1.escapeComponent = escapeComponent;
    exports1.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=uri.all.js.map
}),
"[project]/node_modules/fast-deep-equal/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}),
"[project]/node_modules/schema-utils/node_modules/json-schema-traverse/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}),
"[project]/node_modules/fast-json-stable-stringify/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }
        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for(i = 0; i < node.length; i++){
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }
        if (node === null) return 'null';
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    }(data);
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/instanceof.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CONSTRUCTORS = {
    Object: Object,
    Array: Array,
    Function: Function,
    Number: Number,
    String: String,
    Date: Date,
    RegExp: RegExp
};
module.exports = function defFunc(ajv) {
    /* istanbul ignore else */ if (typeof Buffer != 'undefined') CONSTRUCTORS.Buffer = Buffer;
    /* istanbul ignore else */ if (typeof Promise != 'undefined') CONSTRUCTORS.Promise = Promise;
    defFunc.definition = {
        compile: function(schema) {
            if (typeof schema == 'string') {
                var Constructor = getConstructor(schema);
                return function(data) {
                    return data instanceof Constructor;
                };
            }
            var constructors = schema.map(getConstructor);
            return function(data) {
                for(var i = 0; i < constructors.length; i++)if (data instanceof constructors[i]) return true;
                return false;
            };
        },
        CONSTRUCTORS: CONSTRUCTORS,
        metaSchema: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                }
            ]
        }
    };
    ajv.addKeyword('instanceof', defFunc.definition);
    return ajv;
    //TURBOPACK unreachable
    ;
    function getConstructor(c) {
        var Constructor = CONSTRUCTORS[c];
        if (Constructor) return Constructor;
        throw new Error('invalid "instanceof" keyword value ' + c);
    }
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'number',
        macro: function(schema, parentSchema) {
            var min = schema[0], max = schema[1], exclusive = parentSchema.exclusiveRange;
            validateRangeSchema(min, max, exclusive);
            return exclusive === true ? {
                exclusiveMinimum: min,
                exclusiveMaximum: max
            } : {
                minimum: min,
                maximum: max
            };
        },
        metaSchema: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: {
                type: 'number'
            }
        }
    };
    ajv.addKeyword('range', defFunc.definition);
    ajv.addKeyword('exclusiveRange');
    return ajv;
    //TURBOPACK unreachable
    ;
    function validateRangeSchema(min, max, exclusive) {
        if (exclusive !== undefined && typeof exclusive != 'boolean') throw new Error('Invalid schema for exclusiveRange keyword, should be boolean');
        if (min > max || exclusive && min == max) throw new Error('There are no numbers in range');
    }
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/regexp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'string',
        inline: function(it, keyword, schema) {
            return getRegExp() + '.test(data' + (it.dataLevel || '') + ')';
            //TURBOPACK unreachable
            ;
            function getRegExp() {
                try {
                    if (typeof schema == 'object') return new RegExp(schema.pattern, schema.flags);
                    var rx = schema.match(/^\/(.*)\/([gimuy]*)$/);
                    if (rx) return new RegExp(rx[1], rx[2]);
                    throw new Error('cannot parse string into RegExp');
                } catch (e) {
                    console.error('regular expression', schema, 'is invalid');
                    throw e;
                }
            }
        },
        metaSchema: {
            type: [
                'string',
                'object'
            ],
            properties: {
                pattern: {
                    type: 'string'
                },
                flags: {
                    type: 'string'
                }
            },
            required: [
                'pattern'
            ],
            additionalProperties: false
        }
    };
    ajv.addKeyword('regexp', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/typeof.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var KNOWN_TYPES = [
    'undefined',
    'string',
    'number',
    'object',
    'function',
    'boolean',
    'symbol'
];
module.exports = function defFunc(ajv) {
    defFunc.definition = {
        inline: function(it, keyword, schema) {
            var data = 'data' + (it.dataLevel || '');
            if (typeof schema == 'string') return 'typeof ' + data + ' == "' + schema + '"';
            schema = 'validate.schema' + it.schemaPath + '.' + keyword;
            return schema + '.indexOf(typeof ' + data + ') >= 0';
        },
        metaSchema: {
            anyOf: [
                {
                    type: 'string',
                    enum: KNOWN_TYPES
                },
                {
                    type: 'array',
                    items: {
                        type: 'string',
                        enum: KNOWN_TYPES
                    }
                }
            ]
        }
    };
    ajv.addKeyword('typeof', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dynamicDefaults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var sequences = {};
var DEFAULTS = {
    timestamp: function() {
        return Date.now();
    },
    datetime: function() {
        return (new Date).toISOString();
    },
    date: function() {
        return (new Date).toISOString().slice(0, 10);
    },
    time: function() {
        return (new Date).toISOString().slice(11);
    },
    random: function() {
        return Math.random();
    },
    randomint: function(args) {
        var limit = args && args.max || 2;
        return function() {
            return Math.floor(Math.random() * limit);
        };
    },
    seq: function(args) {
        var name = args && args.name || '';
        sequences[name] = sequences[name] || 0;
        return function() {
            return sequences[name]++;
        };
    }
};
module.exports = function defFunc(ajv) {
    defFunc.definition = {
        compile: function(schema, parentSchema, it) {
            var funcs = {};
            for(var key in schema){
                var d = schema[key];
                var func = getDefault(typeof d == 'string' ? d : d.func);
                funcs[key] = func.length ? func(d.args) : func;
            }
            return it.opts.useDefaults && !it.compositeRule ? assignDefaults : noop;
            //TURBOPACK unreachable
            ;
            function assignDefaults(data) {
                for(var prop in schema){
                    if (data[prop] === undefined || it.opts.useDefaults == 'empty' && (data[prop] === null || data[prop] === '')) data[prop] = funcs[prop]();
                }
                return true;
            }
            function noop() {
                return true;
            }
        },
        DEFAULTS: DEFAULTS,
        metaSchema: {
            type: 'object',
            additionalProperties: {
                type: [
                    'string',
                    'object'
                ],
                additionalProperties: false,
                required: [
                    'func',
                    'args'
                ],
                properties: {
                    func: {
                        type: 'string'
                    },
                    args: {
                        type: 'object'
                    }
                }
            }
        }
    };
    ajv.addKeyword('dynamicDefaults', defFunc.definition);
    return ajv;
    //TURBOPACK unreachable
    ;
    function getDefault(d) {
        var def = DEFAULTS[d];
        if (def) return def;
        throw new Error('invalid "dynamicDefaults" keyword property value: ' + d);
    }
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/allRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        macro: function(schema, parentSchema) {
            if (!schema) return true;
            var properties = Object.keys(parentSchema.properties);
            if (properties.length == 0) return true;
            return {
                required: properties
            };
        },
        metaSchema: {
            type: 'boolean'
        },
        dependencies: [
            'properties'
        ]
    };
    ajv.addKeyword('allRequired', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/anyRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        macro: function(schema) {
            if (schema.length == 0) return true;
            if (schema.length == 1) return {
                required: schema
            };
            var schemas = schema.map(function(prop) {
                return {
                    required: [
                        prop
                    ]
                };
            });
            return {
                anyOf: schemas
            };
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    };
    ajv.addKeyword('anyRequired', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/oneRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        macro: function(schema) {
            if (schema.length == 0) return true;
            if (schema.length == 1) return {
                required: schema
            };
            var schemas = schema.map(function(prop) {
                return {
                    required: [
                        prop
                    ]
                };
            });
            return {
                oneOf: schemas
            };
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    };
    ajv.addKeyword('oneRequired', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/prohibited.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        macro: function(schema) {
            if (schema.length == 0) return true;
            if (schema.length == 1) return {
                not: {
                    required: schema
                }
            };
            var schemas = schema.map(function(prop) {
                return {
                    required: [
                        prop
                    ]
                };
            });
            return {
                not: {
                    anyOf: schemas
                }
            };
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    };
    ajv.addKeyword('prohibited', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/uniqueItemProperties.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var SCALAR_TYPES = [
    'number',
    'integer',
    'string',
    'boolean',
    'null'
];
module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'array',
        compile: function(keys, parentSchema, it) {
            var equal = it.util.equal;
            var scalar = getScalarKeys(keys, parentSchema);
            return function(data) {
                if (data.length > 1) {
                    for(var k = 0; k < keys.length; k++){
                        var i, key = keys[k];
                        if (scalar[k]) {
                            var hash = {};
                            for(i = data.length; i--;){
                                if (!data[i] || typeof data[i] != 'object') continue;
                                var prop = data[i][key];
                                if (prop && typeof prop == 'object') continue;
                                if (typeof prop == 'string') prop = '"' + prop;
                                if (hash[prop]) return false;
                                hash[prop] = true;
                            }
                        } else {
                            for(i = data.length; i--;){
                                if (!data[i] || typeof data[i] != 'object') continue;
                                for(var j = i; j--;){
                                    if (data[j] && typeof data[j] == 'object' && equal(data[i][key], data[j][key])) return false;
                                }
                            }
                        }
                    }
                }
                return true;
            };
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    };
    ajv.addKeyword('uniqueItemProperties', defFunc.definition);
    return ajv;
};
function getScalarKeys(keys, schema) {
    return keys.map(function(key) {
        var properties = schema.items && schema.items.properties;
        var propType = properties && properties[key] && properties[key].type;
        return Array.isArray(propType) ? propType.indexOf('object') < 0 && propType.indexOf('array') < 0 : SCALAR_TYPES.indexOf(propType) >= 0;
    });
}
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_util.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    metaSchemaRef: metaSchemaRef
};
var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
function metaSchemaRef(ajv) {
    var defaultMeta = ajv._opts.defaultMeta;
    if (typeof defaultMeta == 'string') return {
        $ref: defaultMeta
    };
    if (ajv.getSchema(META_SCHEMA_ID)) return {
        $ref: META_SCHEMA_ID
    };
    console.warn('meta schema not defined');
    return {};
}
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/deepProperties.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_util.js [app-route] (ecmascript)");
module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        macro: function(schema) {
            var schemas = [];
            for(var pointer in schema)schemas.push(getSchema(pointer, schema[pointer]));
            return {
                'allOf': schemas
            };
        },
        metaSchema: {
            type: 'object',
            propertyNames: {
                type: 'string',
                format: 'json-pointer'
            },
            additionalProperties: util.metaSchemaRef(ajv)
        }
    };
    ajv.addKeyword('deepProperties', defFunc.definition);
    return ajv;
};
function getSchema(jsonPointer, schema) {
    var segments = jsonPointer.split('/');
    var rootSchema = {};
    var pointerSchema = rootSchema;
    for(var i = 1; i < segments.length; i++){
        var segment = segments[i];
        var isLast = i == segments.length - 1;
        segment = unescapeJsonPointer(segment);
        var properties = pointerSchema.properties = {};
        var items = undefined;
        if (/[0-9]+/.test(segment)) {
            var count = +segment;
            items = pointerSchema.items = [];
            while(count--)items.push({});
        }
        pointerSchema = isLast ? schema : {};
        properties[segment] = pointerSchema;
        if (items) items.push(pointerSchema);
    }
    return rootSchema;
}
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
}
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/deepRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        inline: function(it, keyword, schema) {
            var expr = '';
            for(var i = 0; i < schema.length; i++){
                if (i) expr += ' && ';
                expr += '(' + getData(schema[i], it.dataLevel) + ' !== undefined)';
            }
            return expr;
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string',
                format: 'json-pointer'
            }
        }
    };
    ajv.addKeyword('deepRequired', defFunc.definition);
    return ajv;
};
function getData(jsonPointer, lvl) {
    var data = 'data' + (lvl || '');
    if (!jsonPointer) return data;
    var expr = data;
    var segments = jsonPointer.split('/');
    for(var i = 1; i < segments.length; i++){
        var segment = segments[i];
        data += getProperty(unescapeJsonPointer(segment));
        expr += ' && ' + data;
    }
    return expr;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var INTEGER = /^[0-9]+$/;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
    return INTEGER.test(key) ? '[' + key + ']' : IDENTIFIER.test(key) ? '.' + key : "['" + key.replace(SINGLE_QUOTE, '\\$&') + "']";
}
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
}
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/_formatLimit.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function generate__formatLimit(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    out += 'var ' + $valid + ' = undefined;';
    if (it.opts.format === false) {
        out += ' ' + $valid + ' = true; ';
        return out;
    }
    var $schemaFormat = it.schema.format, $isDataFormat = it.opts.$data && $schemaFormat.$data, $closingBraces = '';
    if ($isDataFormat) {
        var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr), $format = 'format' + $lvl, $compare = 'compare' + $lvl;
        out += ' var ' + $format + ' = formats[' + $schemaValueFormat + '] , ' + $compare + ' = ' + $format + ' && ' + $format + '.compare;';
    } else {
        var $format = it.formats[$schemaFormat];
        if (!($format && $format.compare)) {
            out += '  ' + $valid + ' = true; ';
            return out;
        }
        var $compare = 'formats' + it.util.getProperty($schemaFormat) + '.compare';
    }
    var $isMax = $keyword == 'formatMaximum', $exclusiveKeyword = 'formatExclusive' + ($isMax ? 'Maximum' : 'Minimum'), $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? '<' : '>', $result = 'result' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
    } else {
        $schemaValue = $schema;
    }
    if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = 'exclusive' + $lvl, $opExpr = 'op' + $lvl, $opStr = '\' + ' + $opExpr + ' + \'';
        out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
        $schemaValueExcl = 'schemaExcl' + $lvl;
        out += ' if (typeof ' + $schemaValueExcl + ' != \'boolean\' && ' + $schemaValueExcl + ' !== undefined) { ' + $valid + ' = false; ';
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_formatExclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
            if (it.opts.messages !== false) {
                out += ' , message: \'' + $exclusiveKeyword + ' should be boolean\' ';
            }
            if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
        } else {
            out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
            } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
            }
        } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' }  ';
        if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
        }
        if ($isData) {
            out += ' if (' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'string\') ' + $valid + ' = false; else { ';
            $closingBraces += '}';
        }
        if ($isDataFormat) {
            out += ' if (!' + $compare + ') ' + $valid + ' = true; else { ';
            $closingBraces += '}';
        }
        out += ' var ' + $result + ' = ' + $compare + '(' + $data + ',  ';
        if ($isData) {
            out += '' + $schemaValue;
        } else {
            out += '' + it.util.toQuotedString($schema);
        }
        out += ' ); if (' + $result + ' === undefined) ' + $valid + ' = false; var ' + $exclusive + ' = ' + $schemaValueExcl + ' === true; if (' + $valid + ' === undefined) { ' + $valid + ' = ' + $exclusive + ' ? ' + $result + ' ' + $op + ' 0 : ' + $result + ' ' + $op + '= 0; } if (!' + $valid + ') var op' + $lvl + ' = ' + $exclusive + ' ? \'' + $op + '\' : \'' + $op + '=\';';
    } else {
        var $exclusive = $schemaExcl === true, $opStr = $op;
        if (!$exclusive) $opStr += '=';
        var $opExpr = '\'' + $opStr + '\'';
        if ($isData) {
            out += ' if (' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'string\') ' + $valid + ' = false; else { ';
            $closingBraces += '}';
        }
        if ($isDataFormat) {
            out += ' if (!' + $compare + ') ' + $valid + ' = true; else { ';
            $closingBraces += '}';
        }
        out += ' var ' + $result + ' = ' + $compare + '(' + $data + ',  ';
        if ($isData) {
            out += '' + $schemaValue;
        } else {
            out += '' + it.util.toQuotedString($schema);
        }
        out += ' ); if (' + $result + ' === undefined) ' + $valid + ' = false; if (' + $valid + ' === undefined) ' + $valid + ' = ' + $result + ' ' + $op;
        if (!$exclusive) {
            out += '=';
        }
        out += ' 0;';
    }
    out += '' + $closingBraces + 'if (!' + $valid + ') { ';
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_formatLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { comparison: ' + $opExpr + ', limit:  ';
        if ($isData) {
            out += '' + $schemaValue;
        } else {
            out += '' + it.util.toQuotedString($schema);
        }
        out += ' , exclusive: ' + $exclusive + ' } ';
        if (it.opts.messages !== false) {
            out += ' , message: \'should be ' + $opStr + ' "';
            if ($isData) {
                out += '\' + ' + $schemaValue + ' + \'';
            } else {
                out += '' + it.util.escapeQuotes($schema);
            }
            out += '"\' ';
        }
        if (it.opts.verbose) {
            out += ' , schema:  ';
            if ($isData) {
                out += 'validate.schema' + $schemaPath;
            } else {
                out += '' + it.util.toQuotedString($schema);
            }
            out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
    } else {
        out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
        } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
        }
    } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '}';
    return out;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_formatLimit.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var DATE_TIME_SEPARATOR = /t|\s/i;
var COMPARE_FORMATS = {
    date: compareDate,
    time: compareTime,
    'date-time': compareDateTime
};
var $dataMetaSchema = {
    type: 'object',
    required: [
        '$data'
    ],
    properties: {
        $data: {
            type: 'string',
            anyOf: [
                {
                    format: 'relative-json-pointer'
                },
                {
                    format: 'json-pointer'
                }
            ]
        }
    },
    additionalProperties: false
};
module.exports = function(minMax) {
    var keyword = 'format' + minMax;
    return function defFunc(ajv) {
        defFunc.definition = {
            type: 'string',
            inline: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/_formatLimit.js [app-route] (ecmascript)"),
            statements: true,
            errors: 'full',
            dependencies: [
                'format'
            ],
            metaSchema: {
                anyOf: [
                    {
                        type: 'string'
                    },
                    $dataMetaSchema
                ]
            }
        };
        ajv.addKeyword(keyword, defFunc.definition);
        ajv.addKeyword('formatExclusive' + minMax, {
            dependencies: [
                'format' + minMax
            ],
            metaSchema: {
                anyOf: [
                    {
                        type: 'boolean'
                    },
                    $dataMetaSchema
                ]
            }
        });
        extendFormats(ajv);
        return ajv;
    };
};
function extendFormats(ajv) {
    var formats = ajv._formats;
    for(var name in COMPARE_FORMATS){
        var format = formats[name];
        // the last condition is needed if it's RegExp from another window
        if (typeof format != 'object' || format instanceof RegExp || !format.validate) format = formats[name] = {
            validate: format
        };
        if (!format.compare) format.compare = COMPARE_FORMATS[name];
    }
}
function compareDate(d1, d2) {
    if (!(d1 && d2)) return;
    if (d1 > d2) return 1;
    if (d1 < d2) return -1;
    if (d1 === d2) return 0;
}
function compareTime(t1, t2) {
    if (!(t1 && t2)) return;
    t1 = t1.match(TIME);
    t2 = t2.match(TIME);
    if (!(t1 && t2)) return;
    t1 = t1[1] + t1[2] + t1[3] + (t1[4] || '');
    t2 = t2[1] + t2[2] + t2[3] + (t2[4] || '');
    if (t1 > t2) return 1;
    if (t1 < t2) return -1;
    if (t1 === t2) return 0;
}
function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2)) return;
    dt1 = dt1.split(DATE_TIME_SEPARATOR);
    dt2 = dt2.split(DATE_TIME_SEPARATOR);
    var res = compareDate(dt1[0], dt2[0]);
    if (res === undefined) return;
    return res || compareTime(dt1[1], dt2[1]);
}
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/formatMinimum.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_formatLimit.js [app-route] (ecmascript)")('Minimum');
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/formatMaximum.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_formatLimit.js [app-route] (ecmascript)")('Maximum');
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/patternRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function generate_patternRequired(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $key = 'key' + $lvl, $idx = 'idx' + $lvl, $matched = 'patternMatched' + $lvl, $dataProperties = 'dataProperties' + $lvl, $closingBraces = '', $ownProperties = it.opts.ownProperties;
    out += 'var ' + $valid + ' = true;';
    if ($ownProperties) {
        out += ' var ' + $dataProperties + ' = undefined;';
    }
    var arr1 = $schema;
    if (arr1) {
        var $pProperty, i1 = -1, l1 = arr1.length - 1;
        while(i1 < l1){
            $pProperty = arr1[i1 += 1];
            out += ' var ' + $matched + ' = false;  ';
            if ($ownProperties) {
                out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
            } else {
                out += ' for (var ' + $key + ' in ' + $data + ') { ';
            }
            out += ' ' + $matched + ' = ' + it.usePattern($pProperty) + '.test(' + $key + '); if (' + $matched + ') break; } ';
            var $missingPattern = it.util.escapeQuotes($pProperty);
            out += ' if (!' + $matched + ') { ' + $valid + ' = false;  var err =   '; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'patternRequired' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingPattern: \'' + $missingPattern + '\' } ';
                if (it.opts.messages !== false) {
                    out += ' , message: \'should have property matching pattern \\\'' + $missingPattern + '\\\'\' ';
                }
                if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
            } else {
                out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ';
            if ($breakOnError) {
                $closingBraces += '}';
                out += ' else { ';
            }
        }
    }
    out += '' + $closingBraces;
    return out;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/patternRequired.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    defFunc.definition = {
        type: 'object',
        inline: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/patternRequired.js [app-route] (ecmascript)"),
        statements: true,
        errors: 'full',
        metaSchema: {
            type: 'array',
            items: {
                type: 'string',
                format: 'regex'
            },
            uniqueItems: true
        }
    };
    ajv.addKeyword('patternRequired', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/switch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function generate_switch(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $ifPassed = 'ifPassed' + it.level, $currentBaseId = $it.baseId, $shouldContinue;
    out += 'var ' + $ifPassed + ';';
    var arr1 = $schema;
    if (arr1) {
        var $sch, $caseIndex = -1, l1 = arr1.length - 1;
        while($caseIndex < l1){
            $sch = arr1[$caseIndex += 1];
            if ($caseIndex && !$shouldContinue) {
                out += ' if (!' + $ifPassed + ') { ';
                $closingBraces += '}';
            }
            if ($sch.if && (it.opts.strictKeywords ? typeof $sch.if == 'object' && Object.keys($sch.if).length > 0 : it.util.schemaHasRules($sch.if, it.RULES.all))) {
                out += ' var ' + $errs + ' = errors;   ';
                var $wasComposite = it.compositeRule;
                it.compositeRule = $it.compositeRule = true;
                $it.createErrors = false;
                $it.schema = $sch.if;
                $it.schemaPath = $schemaPath + '[' + $caseIndex + '].if';
                $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/if';
                out += '  ' + it.validate($it) + ' ';
                $it.baseId = $currentBaseId;
                $it.createErrors = true;
                it.compositeRule = $it.compositeRule = $wasComposite;
                out += ' ' + $ifPassed + ' = ' + $nextValid + '; if (' + $ifPassed + ') {  ';
                if (typeof $sch.then == 'boolean') {
                    if ($sch.then === false) {
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = ''; /* istanbul ignore else */ 
                        if (it.createErrors !== false) {
                            out += ' { keyword: \'' + 'switch' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { caseIndex: ' + $caseIndex + ' } ';
                            if (it.opts.messages !== false) {
                                out += ' , message: \'should pass "switch" keyword validation\' ';
                            }
                            if (it.opts.verbose) {
                                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                            }
                            out += ' } ';
                        } else {
                            out += ' {} ';
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                            /* istanbul ignore if */ if (it.async) {
                                out += ' throw new ValidationError([' + __err + ']); ';
                            } else {
                                out += ' validate.errors = [' + __err + ']; return false; ';
                            }
                        } else {
                            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        }
                    }
                    out += ' var ' + $nextValid + ' = ' + $sch.then + '; ';
                } else {
                    $it.schema = $sch.then;
                    $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
                    $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
                    out += '  ' + it.validate($it) + ' ';
                    $it.baseId = $currentBaseId;
                }
                out += '  } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } } ';
            } else {
                out += ' ' + $ifPassed + ' = true;  ';
                if (typeof $sch.then == 'boolean') {
                    if ($sch.then === false) {
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = ''; /* istanbul ignore else */ 
                        if (it.createErrors !== false) {
                            out += ' { keyword: \'' + 'switch' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { caseIndex: ' + $caseIndex + ' } ';
                            if (it.opts.messages !== false) {
                                out += ' , message: \'should pass "switch" keyword validation\' ';
                            }
                            if (it.opts.verbose) {
                                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                            }
                            out += ' } ';
                        } else {
                            out += ' {} ';
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                            /* istanbul ignore if */ if (it.async) {
                                out += ' throw new ValidationError([' + __err + ']); ';
                            } else {
                                out += ' validate.errors = [' + __err + ']; return false; ';
                            }
                        } else {
                            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        }
                    }
                    out += ' var ' + $nextValid + ' = ' + $sch.then + '; ';
                } else {
                    $it.schema = $sch.then;
                    $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
                    $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
                    out += '  ' + it.validate($it) + ' ';
                    $it.baseId = $currentBaseId;
                }
            }
            $shouldContinue = $sch.continue;
        }
    }
    out += '' + $closingBraces + 'var ' + $valid + ' = ' + $nextValid + ';';
    return out;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/switch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_util.js [app-route] (ecmascript)");
module.exports = function defFunc(ajv) {
    if (ajv.RULES.keywords.switch && ajv.RULES.keywords.if) return;
    var metaSchemaRef = util.metaSchemaRef(ajv);
    defFunc.definition = {
        inline: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dotjs/switch.js [app-route] (ecmascript)"),
        statements: true,
        errors: 'full',
        metaSchema: {
            type: 'array',
            items: {
                required: [
                    'then'
                ],
                properties: {
                    'if': metaSchemaRef,
                    'then': {
                        anyOf: [
                            {
                                type: 'boolean'
                            },
                            metaSchemaRef
                        ]
                    },
                    'continue': {
                        type: 'boolean'
                    }
                },
                additionalProperties: false,
                dependencies: {
                    'continue': [
                        'if'
                    ]
                }
            }
        }
    };
    ajv.addKeyword('switch', defFunc.definition);
    return ajv;
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/select.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/_util.js [app-route] (ecmascript)");
module.exports = function defFunc(ajv) {
    if (!ajv._opts.$data) {
        console.warn('keyword select requires $data option');
        return ajv;
    }
    var metaSchemaRef = util.metaSchemaRef(ajv);
    var compiledCaseSchemas = [];
    defFunc.definition = {
        validate: function v(schema, data, parentSchema) {
            if (parentSchema.selectCases === undefined) throw new Error('keyword "selectCases" is absent');
            var compiled = getCompiledSchemas(parentSchema, false);
            var validate = compiled.cases[schema];
            if (validate === undefined) validate = compiled.default;
            if (typeof validate == 'boolean') return validate;
            var valid = validate(data);
            if (!valid) v.errors = validate.errors;
            return valid;
        },
        $data: true,
        metaSchema: {
            type: [
                'string',
                'number',
                'boolean',
                'null'
            ]
        }
    };
    ajv.addKeyword('select', defFunc.definition);
    ajv.addKeyword('selectCases', {
        compile: function(schemas, parentSchema) {
            var compiled = getCompiledSchemas(parentSchema);
            for(var value in schemas)compiled.cases[value] = compileOrBoolean(schemas[value]);
            return function() {
                return true;
            };
        },
        valid: true,
        metaSchema: {
            type: 'object',
            additionalProperties: metaSchemaRef
        }
    });
    ajv.addKeyword('selectDefault', {
        compile: function(schema, parentSchema) {
            var compiled = getCompiledSchemas(parentSchema);
            compiled.default = compileOrBoolean(schema);
            return function() {
                return true;
            };
        },
        valid: true,
        metaSchema: metaSchemaRef
    });
    return ajv;
    //TURBOPACK unreachable
    ;
    function getCompiledSchemas(parentSchema, create) {
        var compiled;
        compiledCaseSchemas.some(function(c) {
            if (c.parentSchema === parentSchema) {
                compiled = c;
                return true;
            }
        });
        if (!compiled && create !== false) {
            compiled = {
                parentSchema: parentSchema,
                cases: {},
                default: true
            };
            compiledCaseSchemas.push(compiled);
        }
        return compiled;
    }
    function compileOrBoolean(schema) {
        return typeof schema == 'boolean' ? schema : ajv.compile(schema);
    }
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/transform.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function defFunc(ajv) {
    var transform = {
        trimLeft: function(value) {
            return value.replace(/^[\s]+/, '');
        },
        trimRight: function(value) {
            return value.replace(/[\s]+$/, '');
        },
        trim: function(value) {
            return value.trim();
        },
        toLowerCase: function(value) {
            return value.toLowerCase();
        },
        toUpperCase: function(value) {
            return value.toUpperCase();
        },
        toEnumCase: function(value, cfg) {
            return cfg.hash[makeHashTableKey(value)] || value;
        }
    };
    defFunc.definition = {
        type: 'string',
        errors: false,
        modifying: true,
        valid: true,
        compile: function(schema, parentSchema) {
            var cfg;
            if (schema.indexOf('toEnumCase') !== -1) {
                // build hash table to enum values
                cfg = {
                    hash: {}
                };
                // requires `enum` in schema
                if (!parentSchema.enum) throw new Error('Missing enum. To use `transform:["toEnumCase"]`, `enum:[...]` is required.');
                for(var i = parentSchema.enum.length; i--; i){
                    var v = parentSchema.enum[i];
                    if (typeof v !== 'string') continue;
                    var k = makeHashTableKey(v);
                    // requires all `enum` values have unique keys
                    if (cfg.hash[k]) throw new Error('Invalid enum uniqueness. To use `transform:["toEnumCase"]`, all values must be unique when case insensitive.');
                    cfg.hash[k] = v;
                }
            }
            return function(data, dataPath, object, key) {
                // skip if value only
                if (!object) return;
                // apply transform in order provided
                for(var j = 0, l = schema.length; j < l; j++)data = transform[schema[j]](data, cfg);
                object[key] = data;
            };
        },
        metaSchema: {
            type: 'array',
            items: {
                type: 'string',
                enum: [
                    'trimLeft',
                    'trimRight',
                    'trim',
                    'toLowerCase',
                    'toUpperCase',
                    'toEnumCase'
                ]
            }
        }
    };
    ajv.addKeyword('transform', defFunc.definition);
    return ajv;
    //TURBOPACK unreachable
    ;
    function makeHashTableKey(value) {
        return value.toLowerCase();
    }
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    'instanceof': __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/instanceof.js [app-route] (ecmascript)"),
    range: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/range.js [app-route] (ecmascript)"),
    regexp: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/regexp.js [app-route] (ecmascript)"),
    'typeof': __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/typeof.js [app-route] (ecmascript)"),
    dynamicDefaults: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/dynamicDefaults.js [app-route] (ecmascript)"),
    allRequired: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/allRequired.js [app-route] (ecmascript)"),
    anyRequired: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/anyRequired.js [app-route] (ecmascript)"),
    oneRequired: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/oneRequired.js [app-route] (ecmascript)"),
    prohibited: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/prohibited.js [app-route] (ecmascript)"),
    uniqueItemProperties: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/uniqueItemProperties.js [app-route] (ecmascript)"),
    deepProperties: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/deepProperties.js [app-route] (ecmascript)"),
    deepRequired: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/deepRequired.js [app-route] (ecmascript)"),
    formatMinimum: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/formatMinimum.js [app-route] (ecmascript)"),
    formatMaximum: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/formatMaximum.js [app-route] (ecmascript)"),
    patternRequired: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/patternRequired.js [app-route] (ecmascript)"),
    'switch': __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/switch.js [app-route] (ecmascript)"),
    select: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/select.js [app-route] (ecmascript)"),
    transform: __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/transform.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/schema-utils/node_modules/ajv-keywords/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var KEYWORDS = __turbopack_context__.r("[project]/node_modules/schema-utils/node_modules/ajv-keywords/keywords/index.js [app-route] (ecmascript)");
module.exports = defineKeywords;
/**
 * Defines one or several keywords in ajv instance
 * @param  {Ajv} ajv validator instance
 * @param  {String|Array<String>|undefined} keyword keyword(s) to define
 * @return {Ajv} ajv instance (for chaining)
 */ function defineKeywords(ajv, keyword) {
    if (Array.isArray(keyword)) {
        for(var i = 0; i < keyword.length; i++)get(keyword[i])(ajv);
        return ajv;
    }
    if (keyword) {
        get(keyword)(ajv);
        return ajv;
    }
    for(keyword in KEYWORDS)get(keyword)(ajv);
    return ajv;
}
defineKeywords.get = get;
function get(keyword) {
    var defFunc = KEYWORDS[keyword];
    if (!defFunc) throw new Error('Unknown keyword ' + keyword);
    return defFunc;
}
}),
"[project]/node_modules/semver/internal/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
};
}),
"[project]/node_modules/semver/internal/debug.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
module.exports = debug;
}),
"[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-route] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-route] (ecmascript)");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const safeSrc = exports.safeSrc = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        '\\s',
        1
    ],
    [
        '\\d',
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.
createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)');
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
}),
"[project]/node_modules/semver/internal/parse-options.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== 'object') {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;
}),
"[project]/node_modules/semver/internal/identifiers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    if (typeof a === 'number' && typeof b === 'number') {
        return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};
}),
"[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-route] (ecmascript)");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-route] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)");
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-route] (ecmascript)");
const { compareIdentifiers } = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-route] (ecmascript)");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split('.').map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        if (this.major < other.major) {
            return -1;
        }
        if (this.major > other.major) {
            return 1;
        }
        if (this.minor < other.minor) {
            return -1;
        }
        if (this.minor > other.minor) {
            return 1;
        }
        if (this.patch < other.patch) {
            return -1;
        }
        if (this.patch > other.patch) {
            return 1;
        }
        return 0;
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug('build compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
            if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
            }
            // Avoid an invalid semver results
            if (identifier) {
                const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier) {
                    throw new Error(`invalid identifier: ${identifier}`);
                }
            }
        }
        switch(release){
            case 'premajor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'preminor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'prepatch':
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc('patch', identifier, identifierBase);
                this.inc('pre', identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case 'prerelease':
                if (this.prerelease.length === 0) {
                    this.inc('patch', identifier, identifierBase);
                }
                this.inc('pre', identifier, identifierBase);
                break;
            case 'release':
                if (this.prerelease.length === 0) {
                    throw new Error(`version ${this.raw} is not a prerelease`);
                }
                this.prerelease.length = 0;
                break;
            case 'major':
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'minor':
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'patch':
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case 'pre':
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === 'number') {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier already exists');
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
        }
        return this;
    }
}
module.exports = SemVer;
}),
"[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;
}),
"[project]/node_modules/semver/functions/valid.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;
}),
"[project]/node_modules/semver/functions/clean.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
};
module.exports = clean;
}),
"[project]/node_modules/semver/functions/inc.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;
}),
"[project]/node_modules/semver/functions/diff.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
        return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
            return 'major';
        }
        // If the main part has no difference
        if (lowVersion.compareMain(highVersion) === 0) {
            if (lowVersion.minor && !lowVersion.patch) {
                return 'minor';
            }
            return 'patch';
        }
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? 'pre' : '';
    if (v1.major !== v2.major) {
        return prefix + 'major';
    }
    if (v1.minor !== v2.minor) {
        return prefix + 'minor';
    }
    if (v1.patch !== v2.patch) {
        return prefix + 'patch';
    }
    // high and low are preleases
    return 'prerelease';
};
module.exports = diff;
}),
"[project]/node_modules/semver/functions/major.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;
}),
"[project]/node_modules/semver/functions/minor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;
}),
"[project]/node_modules/semver/functions/patch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;
}),
"[project]/node_modules/semver/functions/prerelease.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;
}),
"[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;
}),
"[project]/node_modules/semver/functions/rcompare.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;
}),
"[project]/node_modules/semver/functions/compare-loose.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;
}),
"[project]/node_modules/semver/functions/compare-build.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;
}),
"[project]/node_modules/semver/functions/sort.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-route] (ecmascript)");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;
}),
"[project]/node_modules/semver/functions/rsort.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-route] (ecmascript)");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;
}),
"[project]/node_modules/semver/functions/gt.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;
}),
"[project]/node_modules/semver/functions/lt.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;
}),
"[project]/node_modules/semver/functions/eq.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;
}),
"[project]/node_modules/semver/functions/neq.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;
}),
"[project]/node_modules/semver/functions/gte.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;
}),
"[project]/node_modules/semver/functions/lte.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;
}),
"[project]/node_modules/semver/functions/cmp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-route] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-route] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-route] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-route] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-route] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-route] (ecmascript)");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case '===':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a === b;
        case '!==':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a !== b;
        case '':
        case '=':
        case '==':
            return eq(a, b, loose);
        case '!=':
            return neq(a, b, loose);
        case '>':
            return gt(a, b, loose);
        case '>=':
            return gte(a, b, loose);
        case '<':
            return lt(a, b, loose);
        case '<=':
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;
}),
"[project]/node_modules/semver/functions/coerce.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)");
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === 'number') {
        version = String(version);
    }
    if (typeof version !== 'string') {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    const major = match[2];
    const minor = match[3] || '0';
    const patch = match[4] || '0';
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;
}),
"[project]/node_modules/semver/internal/lrucache.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) {
            return undefined;
        } else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;
}),
"[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        // First, split on ||
        this.set = this.raw.split('||')// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = '';
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) {
                    this.formatted += '||';
                }
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) {
                        this.formatted += ' ';
                    }
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug('loose invalid filter', comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug('range list', rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __turbopack_context__.r("[project]/node_modules/semver/internal/lrucache.js [app-route] (ecmascript)");
const cache = new LRU();
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-route] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-route] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-route] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-route] (ecmascript)");
const isNullSet = (c)=>c.value === '<0.0.0-0';
const isAny = (c)=>c.value === '';
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    comp = comp.replace(re[t.BUILD], '');
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === 'x' || id === '*';
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
};
const replaceCaret = (comp, options)=>{
    debug('caret', comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === '0') {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug('no pr');
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug('caret return', ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
            gtlt = '';
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
            if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                ret = '<0.0.0-0';
            } else {
                // nothing is forbidden
                ret = '*';
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = '>=';
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<';
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === '<') {
                pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
};
const replaceGTE0 = (comp, options)=>{
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) {
            from = '';
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
            to = '';
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};
}),
"[project]/node_modules/semver/classes/comparator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
            this.operator = '';
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
            if (this.value === '') {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
            if (comp.value === '') {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-route] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-route] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-route] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
}),
"[project]/node_modules/semver/functions/satisfies.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;
}),
"[project]/node_modules/semver/ranges/to-comparators.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
module.exports = toComparators;
}),
"[project]/node_modules/semver/ranges/max-satisfying.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;
}),
"[project]/node_modules/semver/ranges/min-satisfying.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;
}),
"[project]/node_modules/semver/ranges/min-version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-route] (ecmascript)");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer('0.0.0');
    if (range.test(minver)) {
        return minver;
    }
    minver = new SemVer('0.0.0-0');
    if (range.test(minver)) {
        return minver;
    }
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case '>':
                    if (compver.prerelease.length === 0) {
                        compver.patch++;
                    } else {
                        compver.prerelease.push(0);
                    }
                    compver.raw = compver.format();
                /* fallthrough */ case '':
                case '>=':
                    if (!setMin || gt(compver, setMin)) {
                        setMin = compver;
                    }
                    break;
                case '<':
                case '<=':
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
        }
    }
    if (minver && range.test(minver)) {
        return minver;
    }
    return null;
};
module.exports = minVersion;
}),
"[project]/node_modules/semver/ranges/valid.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*';
    } catch (er) {
        return null;
    }
};
module.exports = validRange;
}),
"[project]/node_modules/semver/ranges/outside.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-route] (ecmascript)");
const { ANY } = Comparator;
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-route] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-route] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-route] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-route] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-route] (ecmascript)");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case '>':
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = '>';
            ecomp = '>=';
            break;
        case '<':
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = '<';
            ecomp = '<=';
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
        return false;
    }
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) {
                comparator = new Comparator('>=0.0.0');
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
            }
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
            return false;
        }
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
        }
    }
    return true;
};
module.exports = outside;
}),
"[project]/node_modules/semver/ranges/gtr.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Determine if version is greater than all the versions possible in the range.
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-route] (ecmascript)");
const gtr = (version, range, options)=>outside(version, range, '>', options);
module.exports = gtr;
}),
"[project]/node_modules/semver/ranges/ltr.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-route] (ecmascript)");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, '<', options);
module.exports = ltr;
}),
"[project]/node_modules/semver/ranges/intersects.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;
}),
"[project]/node_modules/semver/ranges/simplify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-route] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) {
                first = version;
            }
        } else {
            if (prev) {
                set.push([
                    first,
                    prev
                ]);
            }
            prev = null;
            first = null;
        }
    }
    if (first) {
        set.push([
            first,
            null
        ]);
    }
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) {
            ranges.push(min);
        } else if (!max && min === v[0]) {
            ranges.push('*');
        } else if (!max) {
            ranges.push(`>=${min}`);
        } else if (min === v[0]) {
            ranges.push(`<=${max}`);
        } else {
            ranges.push(`${min} - ${max}`);
        }
    }
    const simplified = ranges.join(' || ');
    const original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};
}),
"[project]/node_modules/semver/ranges/subset.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-route] (ecmascript)");
const { ANY } = Comparator;
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-route] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) {
        return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
                continue OUTER;
            }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
            return false;
        }
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator('>=0.0.0-0')
];
const minimumVersion = [
    new Comparator('>=0.0.0')
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) {
        return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
        } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
        } else {
            sub = minimumVersion;
        }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
            return true;
        } else {
            dom = minimumVersion;
        }
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === '>' || c.operator === '>=') {
            gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
            lt = lowerLT(lt, c, options);
        } else {
            eqSet.add(c.semver);
        }
    }
    if (eqSet.size > 1) {
        return null;
    }
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
            return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
            return null;
        }
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) {
            return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
            return null;
        }
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) {
                return false;
            }
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
    }
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                    needDomGTPre = false;
                }
            }
            if (c.operator === '>' || c.operator === '>=') {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) {
                    return false;
                }
            } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
                return false;
            }
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                    needDomLTPre = false;
                }
            }
            if (c.operator === '<' || c.operator === '<=') {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) {
                    return false;
                }
            } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
                return false;
            }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
        }
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
    }
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
        return false;
    }
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};
module.exports = subset;
}),
"[project]/node_modules/semver/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// just pre-load all the stuff that index.js lazily exports
const internalRe = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-route] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-route] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-route] (ecmascript)");
const identifiers = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-route] (ecmascript)");
const valid = __turbopack_context__.r("[project]/node_modules/semver/functions/valid.js [app-route] (ecmascript)");
const clean = __turbopack_context__.r("[project]/node_modules/semver/functions/clean.js [app-route] (ecmascript)");
const inc = __turbopack_context__.r("[project]/node_modules/semver/functions/inc.js [app-route] (ecmascript)");
const diff = __turbopack_context__.r("[project]/node_modules/semver/functions/diff.js [app-route] (ecmascript)");
const major = __turbopack_context__.r("[project]/node_modules/semver/functions/major.js [app-route] (ecmascript)");
const minor = __turbopack_context__.r("[project]/node_modules/semver/functions/minor.js [app-route] (ecmascript)");
const patch = __turbopack_context__.r("[project]/node_modules/semver/functions/patch.js [app-route] (ecmascript)");
const prerelease = __turbopack_context__.r("[project]/node_modules/semver/functions/prerelease.js [app-route] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-route] (ecmascript)");
const rcompare = __turbopack_context__.r("[project]/node_modules/semver/functions/rcompare.js [app-route] (ecmascript)");
const compareLoose = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-loose.js [app-route] (ecmascript)");
const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-route] (ecmascript)");
const sort = __turbopack_context__.r("[project]/node_modules/semver/functions/sort.js [app-route] (ecmascript)");
const rsort = __turbopack_context__.r("[project]/node_modules/semver/functions/rsort.js [app-route] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-route] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-route] (ecmascript)");
const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-route] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-route] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-route] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-route] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-route] (ecmascript)");
const coerce = __turbopack_context__.r("[project]/node_modules/semver/functions/coerce.js [app-route] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-route] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-route] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-route] (ecmascript)");
const toComparators = __turbopack_context__.r("[project]/node_modules/semver/ranges/to-comparators.js [app-route] (ecmascript)");
const maxSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/max-satisfying.js [app-route] (ecmascript)");
const minSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-satisfying.js [app-route] (ecmascript)");
const minVersion = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-version.js [app-route] (ecmascript)");
const validRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/valid.js [app-route] (ecmascript)");
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-route] (ecmascript)");
const gtr = __turbopack_context__.r("[project]/node_modules/semver/ranges/gtr.js [app-route] (ecmascript)");
const ltr = __turbopack_context__.r("[project]/node_modules/semver/ranges/ltr.js [app-route] (ecmascript)");
const intersects = __turbopack_context__.r("[project]/node_modules/semver/ranges/intersects.js [app-route] (ecmascript)");
const simplifyRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/simplify.js [app-route] (ecmascript)");
const subset = __turbopack_context__.r("[project]/node_modules/semver/ranges/subset.js [app-route] (ecmascript)");
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};
}),
"[project]/node_modules/css-loader/dist/CssSyntaxError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
class CssSyntaxError extends Error {
    constructor(error){
        super(error);
        const { reason, line, column, file } = error;
        this.name = "CssSyntaxError"; // Based on https://github.com/postcss/postcss/blob/master/lib/css-syntax-error.es6#L132
        // We don't need `plugin` and `file` properties.
        this.message = `${this.name}\n\n`;
        if (typeof line !== "undefined") {
            this.message += `(${line}:${column}) `;
        }
        this.message += file ? `${file} ` : "<css input> ";
        this.message += `${reason}`;
        const code = error.showSourceCode();
        if (code) {
            this.message += `\n\n${code}\n`;
        } // We don't need stack https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md#31-dont-show-js-stack-for-csssyntaxerror
        this.stack = false;
    }
}
exports.default = CssSyntaxError;
}),
"[project]/node_modules/css-loader/dist/Warning.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
class Warning extends Error {
    constructor(warning){
        super(warning);
        const { text, line, column } = warning;
        this.name = "Warning"; // Based on https://github.com/postcss/postcss/blob/master/lib/warning.es6#L74
        // We don't need `plugin` properties.
        this.message = `${this.name}\n\n`;
        if (typeof line !== "undefined") {
            this.message += `(${line}:${column}) `;
        }
        this.message += `${text}`; // We don't need stack https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md#31-dont-show-js-stack-for-csssyntaxerror
        this.stack = false;
    }
}
exports.default = Warning;
}),
"[project]/node_modules/css-loader/dist/options.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"additionalProperties\":false,\"properties\":{\"url\":{\"description\":\"Enables/Disables 'url'/'image-set' functions handling (https://github.com/webpack-contrib/css-loader#url).\",\"anyOf\":[{\"type\":\"boolean\"},{\"instanceof\":\"Function\"}]},\"import\":{\"description\":\"Enables/Disables '@import' at-rules handling (https://github.com/webpack-contrib/css-loader#import).\",\"anyOf\":[{\"type\":\"boolean\"},{\"instanceof\":\"Function\"}]},\"modules\":{\"description\":\"Enables/Disables CSS Modules and their configuration (https://github.com/webpack-contrib/css-loader#modules).\",\"anyOf\":[{\"type\":\"boolean\"},{\"enum\":[\"local\",\"global\",\"pure\"]},{\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"compileType\":{\"description\":\"Controls the extent to which css-loader will process module code (https://github.com/webpack-contrib/css-loader#type)\",\"enum\":[\"module\",\"icss\"]},\"auto\":{\"description\":\"Allows auto enable CSS modules based on filename (https://github.com/webpack-contrib/css-loader#auto).\",\"anyOf\":[{\"instanceof\":\"RegExp\"},{\"instanceof\":\"Function\"},{\"type\":\"boolean\"}]},\"mode\":{\"description\":\"Setup `mode` option (https://github.com/webpack-contrib/css-loader#mode).\",\"anyOf\":[{\"enum\":[\"local\",\"global\",\"pure\"]},{\"instanceof\":\"Function\"}]},\"localIdentName\":{\"description\":\"Allows to configure the generated local ident name (https://github.com/webpack-contrib/css-loader#localidentname).\",\"type\":\"string\",\"minLength\":1},\"localIdentContext\":{\"description\":\"Allows to redefine basic loader context for local ident name (https://github.com/webpack-contrib/css-loader#localidentcontext).\",\"type\":\"string\",\"minLength\":1},\"localIdentHashPrefix\":{\"description\":\"Allows to add custom hash to generate more unique classes (https://github.com/webpack-contrib/css-loader#localidenthashprefix).\",\"type\":\"string\",\"minLength\":1},\"localIdentRegExp\":{\"description\":\"Allows to specify custom RegExp for local ident name (https://github.com/webpack-contrib/css-loader#localidentregexp).\",\"anyOf\":[{\"type\":\"string\",\"minLength\":1},{\"instanceof\":\"RegExp\"}]},\"getLocalIdent\":{\"description\":\"Allows to specify a function to generate the classname (https://github.com/webpack-contrib/css-loader#getlocalident).\",\"instanceof\":\"Function\"},\"namedExport\":{\"description\":\"Enables/disables ES modules named export for locals (https://github.com/webpack-contrib/css-loader#namedexport).\",\"type\":\"boolean\"},\"exportGlobals\":{\"description\":\"Allows to export names from global class or id, so you can use that as local name (https://github.com/webpack-contrib/css-loader#exportglobals).\",\"type\":\"boolean\"},\"exportLocalsConvention\":{\"description\":\"Style of exported classnames (https://github.com/webpack-contrib/css-loader#localsconvention).\",\"enum\":[\"asIs\",\"camelCase\",\"camelCaseOnly\",\"dashes\",\"dashesOnly\"]},\"exportOnlyLocals\":{\"description\":\"Export only locals (https://github.com/webpack-contrib/css-loader#exportonlylocals).\",\"type\":\"boolean\"}}}]},\"sourceMap\":{\"description\":\"Enables/Disables generation of source maps (https://github.com/webpack-contrib/css-loader#sourcemap).\",\"type\":\"boolean\"},\"importLoaders\":{\"description\":\"Enables/Disables or setups number of loaders applied before CSS loader (https://github.com/webpack-contrib/css-loader#importloaders).\",\"anyOf\":[{\"type\":\"boolean\"},{\"type\":\"string\"},{\"type\":\"integer\"}]},\"esModule\":{\"description\":\"Use the ES modules syntax (https://github.com/webpack-contrib/css-loader#esmodule).\",\"type\":\"boolean\"}},\"type\":\"object\"}"));}),
"[project]/node_modules/css-loader/dist/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeOptions = normalizeOptions;
exports.shouldUseModulesPlugins = shouldUseModulesPlugins;
exports.shouldUseImportPlugin = shouldUseImportPlugin;
exports.shouldUseURLPlugin = shouldUseURLPlugin;
exports.shouldUseIcssPlugin = shouldUseIcssPlugin;
exports.normalizeUrl = normalizeUrl;
exports.requestify = requestify;
exports.getFilter = getFilter;
exports.getModulesOptions = getModulesOptions;
exports.getModulesPlugins = getModulesPlugins;
exports.normalizeSourceMap = normalizeSourceMap;
exports.getPreRequester = getPreRequester;
exports.getImportCode = getImportCode;
exports.getModuleCode = getModuleCode;
exports.getExportCode = getExportCode;
exports.resolveRequests = resolveRequests;
exports.isUrlRequestable = isUrlRequestable;
exports.sort = sort;
exports.combineRequests = combineRequests;
exports.camelCase = camelCase;
exports.WEBPACK_IGNORE_COMMENT_REGEXP = void 0;
var _url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var _path = _interopRequireDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var _loaderUtils = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/index.js [app-route] (ecmascript)");
var _postcssModulesValues = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-modules-values/src/index.js [app-route] (ecmascript)"));
var _postcssModulesLocalByDefault = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-modules-local-by-default/src/index.js [app-route] (ecmascript)"));
var _postcssModulesExtractImports = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-modules-extract-imports/src/index.js [app-route] (ecmascript)"));
var _postcssModulesScope = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-modules-scope/src/index.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ const WEBPACK_IGNORE_COMMENT_REGEXP = /webpackIgnore:(\s+)?(true|false)/; // eslint-disable-next-line no-useless-escape
exports.WEBPACK_IGNORE_COMMENT_REGEXP = WEBPACK_IGNORE_COMMENT_REGEXP;
const regexSingleEscape = /[ -,.\/:-@[\]\^`{-~]/;
const regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
const preserveCamelCase = (string)=>{
    let result = string;
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for(let i = 0; i < result.length; i++){
        const character = result[i];
        if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
            result = `${result.slice(0, i)}-${result.slice(i)}`;
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i += 1;
        } else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
            result = `${result.slice(0, i - 1)}-${result.slice(i - 1)}`;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
        } else {
            isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
    }
    return result;
};
function camelCase(input) {
    let result = input.trim();
    if (result.length === 0) {
        return "";
    }
    if (result.length === 1) {
        return result.toLowerCase();
    }
    const hasUpperCase = result !== result.toLowerCase();
    if (hasUpperCase) {
        result = preserveCamelCase(result);
    }
    return result.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1)=>p1.toUpperCase()).replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, (m)=>m.toUpperCase());
}
function escape(string) {
    let output = "";
    let counter = 0;
    while(counter < string.length){
        // eslint-disable-next-line no-plusplus
        const character = string.charAt(counter++);
        let value; // eslint-disable-next-line no-control-regex
        if (/[\t\n\f\r\x0B]/.test(character)) {
            const codePoint = character.charCodeAt();
            value = `\\${codePoint.toString(16).toUpperCase()} `;
        } else if (character === "\\" || regexSingleEscape.test(character)) {
            value = `\\${character}`;
        } else {
            value = character;
        }
        output += value;
    }
    const firstChar = string.charAt(0);
    if (/^-[-\d]/.test(output)) {
        output = `\\-${output.slice(1)}`;
    } else if (/\d/.test(firstChar)) {
        output = `\\3${firstChar} ${output.slice(1)}`;
    } // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
    // since theyre redundant. Note that this is only possible if the escape
    // sequence isnt preceded by an odd number of backslashes.
    output = output.replace(regexExcessiveSpaces, ($0, $1, $2)=>{
        if ($1 && $1.length % 2) {
            // Its not safe to remove the space, so dont.
            return $0;
        } // Strip the space.
        return ($1 || "") + $2;
    });
    return output;
}
function gobbleHex(str) {
    const lower = str.toLowerCase();
    let hex = "";
    let spaceTerminated = false; // eslint-disable-next-line no-undefined
    for(let i = 0; i < 6 && lower[i] !== undefined; i++){
        const code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]
        const valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point
        spaceTerminated = code === 32;
        if (!valid) {
            break;
        }
        hex += lower[i];
    }
    if (hex.length === 0) {
        // eslint-disable-next-line no-undefined
        return undefined;
    }
    const codePoint = parseInt(hex, 16);
    const isSurrogate = codePoint >= 0xd800 && codePoint <= 0xdfff; // Add special case for
    // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point
    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10ffff) {
        return [
            "\uFFFD",
            hex.length + (spaceTerminated ? 1 : 0)
        ];
    }
    return [
        String.fromCodePoint(codePoint),
        hex.length + (spaceTerminated ? 1 : 0)
    ];
}
const CONTAINS_ESCAPE = /\\/;
function unescape(str) {
    const needToProcess = CONTAINS_ESCAPE.test(str);
    if (!needToProcess) {
        return str;
    }
    let ret = "";
    for(let i = 0; i < str.length; i++){
        if (str[i] === "\\") {
            const gobbled = gobbleHex(str.slice(i + 1, i + 7)); // eslint-disable-next-line no-undefined
            if (gobbled !== undefined) {
                ret += gobbled[0];
                i += gobbled[1]; // eslint-disable-next-line no-continue
                continue;
            } // Retain a pair of \\ if double escaped `\\\\`
            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e
            if (str[i + 1] === "\\") {
                ret += "\\";
                i += 1; // eslint-disable-next-line no-continue
                continue;
            } // if \\ is at the end of the string retain it
            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb
            if (str.length === i + 1) {
                ret += str[i];
            } // eslint-disable-next-line no-continue
            continue;
        }
        ret += str[i];
    }
    return ret;
}
function normalizePath(file) {
    return _path.default.sep === "\\" ? file.replace(/\\/g, "/") : file;
} // eslint-disable-next-line no-control-regex
const filenameReservedRegex = /[<>:"/\\|?*]/g; // eslint-disable-next-line no-control-regex
const reControlChars = /[\u0000-\u001f\u0080-\u009f]/g;
function escapeLocalIdent(localident) {
    // TODO simplify in the next major release
    return escape(localident // For `[hash]` placeholder
    .replace(/^((-?[0-9])|--)/, "_$1").replace(filenameReservedRegex, "-").replace(reControlChars, "-").replace(/\./g, "-"));
}
function defaultGetLocalIdent(loaderContext, localIdentName, localName, options) {
    let relativeMatchResource = ""; // eslint-disable-next-line no-underscore-dangle
    if (loaderContext._module && loaderContext._module.matchResource) {
        relativeMatchResource = `${normalizePath(_path.default.relative(options.context, loaderContext._module.matchResource))}\x00`;
    }
    const relativeResourcePath = normalizePath(_path.default.relative(options.context, loaderContext.resourcePath)); // eslint-disable-next-line no-param-reassign
    options.content = `${options.hashPrefix}${relativeMatchResource}${relativeResourcePath}\x00${localName}`;
    return (0, _loaderUtils.interpolateName)(loaderContext, localIdentName, options);
}
const NATIVE_WIN32_PATH = /^[A-Z]:[/\\]|^\\\\/i;
function normalizeUrl(url, isStringValue) {
    let normalizedUrl = url.replace(/^( |\t\n|\r\n|\r|\f)*/g, "").replace(/( |\t\n|\r\n|\r|\f)*$/g, "");
    if (isStringValue && /\\(\n|\r\n|\r|\f)/.test(normalizedUrl)) {
        normalizedUrl = normalizedUrl.replace(/\\(\n|\r\n|\r|\f)/g, "");
    }
    if (NATIVE_WIN32_PATH.test(url)) {
        try {
            normalizedUrl = decodeURI(normalizedUrl);
        } catch (error) {}
        return normalizedUrl;
    }
    normalizedUrl = unescape(normalizedUrl);
    try {
        normalizedUrl = decodeURI(normalizedUrl);
    } catch (error) {}
    return normalizedUrl;
}
function requestify(url, rootContext) {
    if (/^file:/i.test(url)) {
        return (0, _url.fileURLToPath)(url);
    }
    return url.charAt(0) === "/" ? (0, _loaderUtils.urlToRequest)(url, rootContext) : (0, _loaderUtils.urlToRequest)(url);
}
function getFilter(filter, resourcePath) {
    return (...args)=>{
        if (typeof filter === "function") {
            return filter(...args, resourcePath);
        }
        return true;
    };
}
function getValidLocalName(localName, exportLocalsConvention) {
    if (exportLocalsConvention === "dashesOnly") {
        return dashesCamelCase(localName);
    }
    return camelCase(localName);
}
const moduleRegExp = /\.module(s)?\.\w+$/i;
const icssRegExp = /\.icss\.\w+$/i;
function getModulesOptions(rawOptions, loaderContext) {
    const resourcePath = loaderContext._module && loaderContext._module.matchResource || loaderContext.resourcePath;
    let isIcss;
    if (typeof rawOptions.modules === "undefined") {
        const isModules = moduleRegExp.test(resourcePath);
        if (!isModules) {
            isIcss = icssRegExp.test(resourcePath);
        }
        if (!isModules && !isIcss) {
            return false;
        }
    } else if (typeof rawOptions.modules === "boolean" && rawOptions.modules === false) {
        return false;
    }
    let modulesOptions = {
        compileType: isIcss ? "icss" : "module",
        auto: true,
        mode: "local",
        exportGlobals: false,
        localIdentName: "[hash:base64]",
        localIdentContext: loaderContext.rootContext,
        localIdentHashPrefix: "",
        // eslint-disable-next-line no-undefined
        localIdentRegExp: undefined,
        // eslint-disable-next-line no-undefined
        getLocalIdent: undefined,
        namedExport: false,
        exportLocalsConvention: "asIs",
        exportOnlyLocals: false
    };
    if (typeof rawOptions.modules === "boolean" || typeof rawOptions.modules === "string") {
        modulesOptions.mode = typeof rawOptions.modules === "string" ? rawOptions.modules : "local";
    } else {
        if (rawOptions.modules) {
            if (typeof rawOptions.modules.auto === "boolean") {
                const isModules = rawOptions.modules.auto && moduleRegExp.test(resourcePath);
                if (!isModules) {
                    return false;
                }
            } else if (rawOptions.modules.auto instanceof RegExp) {
                const isModules = rawOptions.modules.auto.test(resourcePath);
                if (!isModules) {
                    return false;
                }
            } else if (typeof rawOptions.modules.auto === "function") {
                const isModule = rawOptions.modules.auto(resourcePath);
                if (!isModule) {
                    return false;
                }
            }
            if (rawOptions.modules.namedExport === true && typeof rawOptions.modules.exportLocalsConvention === "undefined") {
                modulesOptions.exportLocalsConvention = "camelCaseOnly";
            }
        }
        modulesOptions = {
            ...modulesOptions,
            ...rawOptions.modules || {}
        };
    }
    if (typeof modulesOptions.mode === "function") {
        modulesOptions.mode = modulesOptions.mode(loaderContext.resourcePath);
    }
    if (modulesOptions.namedExport === true) {
        if (rawOptions.esModule === false) {
            throw new Error('The "modules.namedExport" option requires the "esModules" option to be enabled');
        }
        if (modulesOptions.exportLocalsConvention !== "camelCaseOnly" && modulesOptions.exportLocalsConvention !== "dashesOnly") {
            throw new Error('The "modules.namedExport" option requires the "modules.exportLocalsConvention" option to be "camelCaseOnly" or "dashesOnly"');
        }
    }
    if (/\[emoji(?::(\d+))?\]/i.test(modulesOptions.localIdentName)) {
        loaderContext.emitWarning("Emoji is deprecated and will be removed in next major release.");
    }
    return modulesOptions;
}
function normalizeOptions(rawOptions, loaderContext) {
    const modulesOptions = getModulesOptions(rawOptions, loaderContext);
    return {
        url: typeof rawOptions.url === "undefined" ? true : rawOptions.url,
        import: typeof rawOptions.import === "undefined" ? true : rawOptions.import,
        modules: modulesOptions,
        sourceMap: typeof rawOptions.sourceMap === "boolean" ? rawOptions.sourceMap : loaderContext.sourceMap,
        importLoaders: typeof rawOptions.importLoaders === "string" ? parseInt(rawOptions.importLoaders, 10) : rawOptions.importLoaders,
        esModule: typeof rawOptions.esModule === "undefined" ? true : rawOptions.esModule
    };
}
function shouldUseImportPlugin(options) {
    if (options.modules.exportOnlyLocals) {
        return false;
    }
    if (typeof options.import === "boolean") {
        return options.import;
    }
    return true;
}
function shouldUseURLPlugin(options) {
    if (options.modules.exportOnlyLocals) {
        return false;
    }
    if (typeof options.url === "boolean") {
        return options.url;
    }
    return true;
}
function shouldUseModulesPlugins(options) {
    return options.modules.compileType === "module";
}
function shouldUseIcssPlugin(options) {
    return options.icss === true || Boolean(options.modules);
}
function getModulesPlugins(options, loaderContext) {
    const { mode, getLocalIdent, localIdentName, localIdentContext, localIdentHashPrefix, localIdentRegExp } = options.modules;
    let plugins = [];
    try {
        plugins = [
            _postcssModulesValues.default,
            (0, _postcssModulesLocalByDefault.default)({
                mode
            }),
            (0, _postcssModulesExtractImports.default)(),
            (0, _postcssModulesScope.default)({
                generateScopedName (exportName) {
                    let localIdent;
                    if (typeof getLocalIdent !== "undefined") {
                        localIdent = getLocalIdent(loaderContext, localIdentName, unescape(exportName), {
                            context: localIdentContext,
                            hashPrefix: localIdentHashPrefix,
                            regExp: localIdentRegExp
                        });
                    } // A null/undefined value signals that we should invoke the default
                    // getLocalIdent method.
                    if (typeof localIdent === "undefined" || localIdent === null) {
                        localIdent = defaultGetLocalIdent(loaderContext, localIdentName, unescape(exportName), {
                            context: localIdentContext,
                            hashPrefix: localIdentHashPrefix,
                            regExp: localIdentRegExp
                        });
                        return escapeLocalIdent(localIdent).replace(/\\\[local\\]/gi, exportName);
                    }
                    return escapeLocalIdent(localIdent);
                },
                exportGlobals: options.modules.exportGlobals
            })
        ];
    } catch (error) {
        loaderContext.emitError(error);
    }
    return plugins;
}
const IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\]|^\\\\/i;
const ABSOLUTE_SCHEME = /^[a-z0-9+\-.]+:/i;
function getURLType(source) {
    if (source[0] === "/") {
        if (source[1] === "/") {
            return "scheme-relative";
        }
        return "path-absolute";
    }
    if (IS_NATIVE_WIN32_PATH.test(source)) {
        return "path-absolute";
    }
    return ABSOLUTE_SCHEME.test(source) ? "absolute" : "path-relative";
}
function normalizeSourceMap(map, resourcePath) {
    let newMap = map; // Some loader emit source map as string
    // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.
    if (typeof newMap === "string") {
        newMap = JSON.parse(newMap);
    }
    delete newMap.file;
    const { sourceRoot } = newMap;
    delete newMap.sourceRoot;
    if (newMap.sources) {
        // Source maps should use forward slash because it is URLs (https://github.com/mozilla/source-map/issues/91)
        // We should normalize path because previous loaders like `sass-loader` using backslash when generate source map
        newMap.sources = newMap.sources.map((source)=>{
            // Non-standard syntax from `postcss`
            if (source.indexOf("<") === 0) {
                return source;
            }
            const sourceType = getURLType(source); // Do no touch `scheme-relative` and `absolute` URLs
            if (sourceType === "path-relative" || sourceType === "path-absolute") {
                const absoluteSource = sourceType === "path-relative" && sourceRoot ? _path.default.resolve(sourceRoot, normalizePath(source)) : normalizePath(source);
                return _path.default.relative(_path.default.dirname(resourcePath), absoluteSource);
            }
            return source;
        });
    }
    return newMap;
}
function getPreRequester({ loaders, loaderIndex }) {
    const cache = Object.create(null);
    return (number)=>{
        if (cache[number]) {
            return cache[number];
        }
        if (number === false) {
            cache[number] = "";
        } else {
            const loadersRequest = loaders.slice(loaderIndex, loaderIndex + 1 + (typeof number !== "number" ? 0 : number)).map((x)=>x.request).join("!");
            cache[number] = `-!${loadersRequest}!`;
        }
        return cache[number];
    };
}
function getImportCode(imports, options) {
    let code = "";
    for (const item of imports){
        const { importName, url, icss } = item;
        if (options.esModule) {
            if (icss && options.modules.namedExport) {
                code += `import ${options.modules.exportOnlyLocals ? "" : `${importName}, `}* as ${importName}_NAMED___ from ${url};\n`;
            } else {
                code += `import ${importName} from ${url};\n`;
            }
        } else {
            code += `var ${importName} = require(${url});\n`;
        }
    }
    return code ? `// Imports\n${code}` : "";
}
function normalizeSourceMapForRuntime(map, loaderContext) {
    const resultMap = map ? map.toJSON() : null;
    if (resultMap) {
        delete resultMap.file;
        resultMap.sourceRoot = "";
        resultMap.sources = resultMap.sources.map((source)=>{
            // Non-standard syntax from `postcss`
            if (source.indexOf("<") === 0) {
                return source;
            }
            const sourceType = getURLType(source);
            if (sourceType !== "path-relative") {
                return source;
            }
            const resourceDirname = _path.default.dirname(loaderContext.resourcePath);
            const absoluteSource = _path.default.resolve(resourceDirname, source);
            const contextifyPath = normalizePath(_path.default.relative(loaderContext.rootContext, absoluteSource));
            return `webpack://./${contextifyPath}`;
        });
    }
    return JSON.stringify(resultMap);
}
function getModuleCode(result, api, replacements, options, loaderContext) {
    if (options.modules.exportOnlyLocals === true) {
        return "";
    }
    const sourceMapValue = options.sourceMap ? `,${normalizeSourceMapForRuntime(result.map, loaderContext)}` : "";
    let code = JSON.stringify(result.css);
    let beforeCode = `var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(${options.sourceMap ? "___CSS_LOADER_API_SOURCEMAP_IMPORT___" : "function(i){return i[1]}"});\n`;
    for (const item of api){
        const { url, media, dedupe } = item;
        beforeCode += url ? `___CSS_LOADER_EXPORT___.push([module.id, ${JSON.stringify(`@import url(${url});`)}${media ? `, ${JSON.stringify(media)}` : ""}]);\n` : `___CSS_LOADER_EXPORT___.i(${item.importName}${media ? `, ${JSON.stringify(media)}` : dedupe ? ', ""' : ""}${dedupe ? ", true" : ""});\n`;
    }
    for (const item of replacements){
        const { replacementName, importName, localName } = item;
        if (localName) {
            code = code.replace(new RegExp(replacementName, "g"), ()=>options.modules.namedExport ? `" + ${importName}_NAMED___[${JSON.stringify(getValidLocalName(localName, options.modules.exportLocalsConvention))}] + "` : `" + ${importName}.locals[${JSON.stringify(localName)}] + "`);
        } else {
            const { hash, needQuotes } = item;
            const getUrlOptions = [].concat(hash ? [
                `hash: ${JSON.stringify(hash)}`
            ] : []).concat(needQuotes ? "needQuotes: true" : []);
            const preparedOptions = getUrlOptions.length > 0 ? `, { ${getUrlOptions.join(", ")} }` : "";
            beforeCode += `var ${replacementName} = ___CSS_LOADER_GET_URL_IMPORT___(${importName}${preparedOptions});\n`;
            code = code.replace(new RegExp(replacementName, "g"), ()=>`" + ${replacementName} + "`);
        }
    }
    return `${beforeCode}// Module\n___CSS_LOADER_EXPORT___.push([module.id, ${code}, ""${sourceMapValue}]);\n`;
}
function dashesCamelCase(str) {
    return str.replace(/-+(\w)/g, (match, firstLetter)=>firstLetter.toUpperCase());
}
function getExportCode(exports1, replacements, needToUseIcssPlugin, options) {
    let code = "// Exports\n";
    if (!needToUseIcssPlugin) {
        code += `${options.esModule ? "export default" : "module.exports ="} ___CSS_LOADER_EXPORT___;\n`;
        return code;
    }
    let localsCode = "";
    const addExportToLocalsCode = (name, value)=>{
        if (options.modules.namedExport) {
            localsCode += `export var ${name} = ${JSON.stringify(value)};\n`;
        } else {
            if (localsCode) {
                localsCode += `,\n`;
            }
            localsCode += `\t${JSON.stringify(name)}: ${JSON.stringify(value)}`;
        }
    };
    for (const { name, value } of exports1){
        switch(options.modules.exportLocalsConvention){
            case "camelCase":
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = camelCase(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case "camelCaseOnly":
                {
                    addExportToLocalsCode(camelCase(name), value);
                    break;
                }
            case "dashes":
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = dashesCamelCase(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case "dashesOnly":
                {
                    addExportToLocalsCode(dashesCamelCase(name), value);
                    break;
                }
            case "asIs":
            default:
                addExportToLocalsCode(name, value);
                break;
        }
    }
    for (const item of replacements){
        const { replacementName, localName } = item;
        if (localName) {
            const { importName } = item;
            localsCode = localsCode.replace(new RegExp(replacementName, "g"), ()=>{
                if (options.modules.namedExport) {
                    return `" + ${importName}_NAMED___[${JSON.stringify(getValidLocalName(localName, options.modules.exportLocalsConvention))}] + "`;
                } else if (options.modules.exportOnlyLocals) {
                    return `" + ${importName}[${JSON.stringify(localName)}] + "`;
                }
                return `" + ${importName}.locals[${JSON.stringify(localName)}] + "`;
            });
        } else {
            localsCode = localsCode.replace(new RegExp(replacementName, "g"), ()=>`" + ${replacementName} + "`);
        }
    }
    if (options.modules.exportOnlyLocals) {
        code += options.modules.namedExport ? localsCode : `${options.esModule ? "export default" : "module.exports ="} {\n${localsCode}\n};\n`;
        return code;
    }
    code += options.modules.namedExport ? localsCode : `___CSS_LOADER_EXPORT___.locals = {${localsCode ? `\n${localsCode}\n` : ""}};\n`;
    code += `${options.esModule ? "export default" : "module.exports ="} ___CSS_LOADER_EXPORT___;\n`;
    return code;
}
async function resolveRequests(resolve, context, possibleRequests) {
    return resolve(context, possibleRequests[0]).then((result)=>result).catch((error)=>{
        const [, ...tailPossibleRequests] = possibleRequests;
        if (tailPossibleRequests.length === 0) {
            throw error;
        }
        return resolveRequests(resolve, context, tailPossibleRequests);
    });
}
function isUrlRequestable(url) {
    // Protocol-relative URLs
    if (/^\/\//.test(url)) {
        return false;
    } // `file:` protocol
    if (/^file:/i.test(url)) {
        return true;
    } // Absolute URLs
    if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !NATIVE_WIN32_PATH.test(url)) {
        return false;
    } // `#` URLs
    if (/^#/.test(url)) {
        return false;
    }
    return true;
}
function sort(a, b) {
    return a.index - b.index;
}
function combineRequests(preRequest, url) {
    const idx = url.indexOf("!=!");
    return idx !== -1 ? url.slice(0, idx + 3) + preRequest + url.slice(idx + 3) : preRequest + url;
}
}),
"[project]/node_modules/css-loader/dist/plugins/postcss-import-parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _postcssValueParser = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/css-loader/dist/utils.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parseNode(atRule, key) {
    // Convert only top-level @import
    if (atRule.parent.type !== "root") {
        return;
    }
    if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {
        const lastCommentIndex = atRule.raws.afterName.lastIndexOf("/*");
        const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched && matched[2] === "true") {
            return;
        }
    }
    const prevNode = atRule.prev();
    if (prevNode && prevNode.type === "comment") {
        const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched && matched[2] === "true") {
            return;
        }
    } // Nodes do not exists - `@import url('http://') :root {}`
    if (atRule.nodes) {
        const error = new Error("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.");
        error.node = atRule;
        throw error;
    }
    const { nodes: paramsNodes } = (0, _postcssValueParser.default)(atRule[key]); // No nodes - `@import ;`
    // Invalid type - `@import foo-bar;`
    if (paramsNodes.length === 0 || paramsNodes[0].type !== "string" && paramsNodes[0].type !== "function") {
        const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
        error.node = atRule;
        throw error;
    }
    let isStringValue;
    let url;
    if (paramsNodes[0].type === "string") {
        isStringValue = true;
        url = paramsNodes[0].value;
    } else {
        // Invalid function - `@import nourl(test.css);`
        if (paramsNodes[0].value.toLowerCase() !== "url") {
            const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
            error.node = atRule;
            throw error;
        }
        isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === "string";
        url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);
    }
    url = (0, _utils.normalizeUrl)(url, isStringValue);
    const isRequestable = (0, _utils.isUrlRequestable)(url);
    let prefix;
    if (isRequestable) {
        const queryParts = url.split("!");
        if (queryParts.length > 1) {
            url = queryParts.pop();
            prefix = queryParts.join("!");
        }
    } // Empty url - `@import "";` or `@import url();`
    if (url.trim().length === 0) {
        const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
        error.node = atRule;
        throw error;
    }
    const mediaNodes = paramsNodes.slice(1);
    let media;
    if (mediaNodes.length > 0) {
        media = _postcssValueParser.default.stringify(mediaNodes).trim().toLowerCase();
    } // eslint-disable-next-line consistent-return
    return {
        atRule,
        prefix,
        url,
        media,
        isRequestable
    };
}
const plugin = (options = {})=>{
    return {
        postcssPlugin: "postcss-import-parser",
        prepare (result) {
            const parsedAtRules = [];
            return {
                AtRule: {
                    import (atRule) {
                        let parsedAtRule;
                        try {
                            parsedAtRule = parseNode(atRule, "params", result);
                        } catch (error) {
                            result.warn(error.message, {
                                node: error.node
                            });
                        }
                        if (!parsedAtRule) {
                            return;
                        }
                        parsedAtRules.push(parsedAtRule);
                    }
                },
                async OnceExit () {
                    if (parsedAtRules.length === 0) {
                        return;
                    }
                    const resolvedAtRules = await Promise.all(parsedAtRules.map(async (parsedAtRule)=>{
                        const { atRule, isRequestable, prefix, url, media } = parsedAtRule;
                        if (options.filter) {
                            const needKeep = await options.filter(url, media);
                            if (!needKeep) {
                                return;
                            }
                        }
                        if (isRequestable) {
                            const request = (0, _utils.requestify)(url, options.rootContext);
                            const { resolver, context } = options;
                            const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                                ...new Set([
                                    request,
                                    url
                                ])
                            ]);
                            if (!resolvedUrl) {
                                return;
                            }
                            atRule.remove(); // eslint-disable-next-line consistent-return
                            return {
                                url: resolvedUrl,
                                media,
                                prefix,
                                isRequestable
                            };
                        }
                        atRule.remove(); // eslint-disable-next-line consistent-return
                        return {
                            url,
                            media,
                            prefix,
                            isRequestable
                        };
                    }));
                    const urlToNameMap = new Map();
                    for(let index = 0; index <= resolvedAtRules.length - 1; index++){
                        const resolvedAtRule = resolvedAtRules[index];
                        if (!resolvedAtRule) {
                            continue;
                        }
                        const { url, isRequestable, media } = resolvedAtRule;
                        if (!isRequestable) {
                            options.api.push({
                                url,
                                media,
                                index
                            }); // eslint-disable-next-line no-continue
                            continue;
                        }
                        const { prefix } = resolvedAtRule;
                        const newUrl = prefix ? `${prefix}!${url}` : url;
                        let importName = urlToNameMap.get(newUrl);
                        if (!importName) {
                            importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;
                            urlToNameMap.set(newUrl, importName);
                            options.imports.push({
                                importName,
                                url: options.urlHandler(newUrl),
                                index
                            });
                        }
                        options.api.push({
                            importName,
                            media,
                            index
                        });
                    }
                }
            };
        }
    };
};
plugin.postcss = true;
var _default = plugin;
exports.default = _default;
}),
"[project]/node_modules/css-loader/dist/plugins/postcss-icss-parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _icssUtils = __turbopack_context__.r("[project]/node_modules/icss-utils/src/index.js [app-route] (ecmascript)");
var _utils = __turbopack_context__.r("[project]/node_modules/css-loader/dist/utils.js [app-route] (ecmascript)");
const plugin = (options = {})=>{
    return {
        postcssPlugin: "postcss-icss-parser",
        async OnceExit (root) {
            const importReplacements = Object.create(null);
            const { icssImports, icssExports } = (0, _icssUtils.extractICSS)(root);
            const imports = new Map();
            const tasks = []; // eslint-disable-next-line guard-for-in
            for(const url in icssImports){
                const tokens = icssImports[url];
                if (Object.keys(tokens).length === 0) {
                    continue;
                }
                let normalizedUrl = url;
                let prefix = "";
                const queryParts = normalizedUrl.split("!");
                if (queryParts.length > 1) {
                    normalizedUrl = queryParts.pop();
                    prefix = queryParts.join("!");
                }
                const request = (0, _utils.requestify)((0, _utils.normalizeUrl)(normalizedUrl, true), options.rootContext);
                const doResolve = async ()=>{
                    const { resolver, context } = options;
                    const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                        ...new Set([
                            normalizedUrl,
                            request
                        ])
                    ]);
                    if (!resolvedUrl) {
                        return;
                    } // eslint-disable-next-line consistent-return
                    return {
                        url: resolvedUrl,
                        prefix,
                        tokens
                    };
                };
                tasks.push(doResolve());
            }
            const results = await Promise.all(tasks);
            for(let index = 0; index <= results.length - 1; index++){
                const item = results[index];
                if (!item) {
                    continue;
                }
                const newUrl = item.prefix ? `${item.prefix}!${item.url}` : item.url;
                const importKey = newUrl;
                let importName = imports.get(importKey);
                if (!importName) {
                    importName = `___CSS_LOADER_ICSS_IMPORT_${imports.size}___`;
                    imports.set(importKey, importName);
                    options.imports.push({
                        importName,
                        url: options.urlHandler(newUrl),
                        icss: true,
                        index
                    });
                    options.api.push({
                        importName,
                        dedupe: true,
                        index
                    });
                }
                for (const [replacementIndex, token] of Object.keys(item.tokens).entries()){
                    const replacementName = `___CSS_LOADER_ICSS_IMPORT_${index}_REPLACEMENT_${replacementIndex}___`;
                    const localName = item.tokens[token];
                    importReplacements[token] = replacementName;
                    options.replacements.push({
                        replacementName,
                        importName,
                        localName
                    });
                }
            }
            if (Object.keys(importReplacements).length > 0) {
                (0, _icssUtils.replaceSymbols)(root, importReplacements);
            }
            for (const name of Object.keys(icssExports)){
                const value = (0, _icssUtils.replaceValueSymbols)(icssExports[name], importReplacements);
                options.exports.push({
                    name,
                    value
                });
            }
        }
    };
};
plugin.postcss = true;
var _default = plugin;
exports.default = _default;
}),
"[project]/node_modules/css-loader/dist/runtime/getUrl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(url, options) {
    if (!options) {
        // eslint-disable-next-line no-param-reassign
        options = {};
    } // eslint-disable-next-line no-underscore-dangle, no-param-reassign
    url = url && url.__esModule ? url.default : url;
    if (typeof url !== "string") {
        return url;
    } // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        // eslint-disable-next-line no-param-reassign
        url = url.slice(1, -1);
    }
    if (options.hash) {
        // eslint-disable-next-line no-param-reassign
        url += options.hash;
    } // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url) || options.needQuotes) {
        return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
    }
    return url;
};
}),
"[project]/node_modules/css-loader/dist/plugins/postcss-url-parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _postcssValueParser = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/css-loader/dist/utils.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const isUrlFunc = /url/i;
const isImageSetFunc = /^(?:-webkit-)?image-set$/i;
const needParseDeclaration = /(?:url|(?:-webkit-)?image-set)\(/i;
function getNodeFromUrlFunc(node) {
    return node.nodes && node.nodes[0];
}
function getWebpackIgnoreCommentValue(index, nodes, inBetween) {
    if (index === 0 && typeof inBetween !== "undefined") {
        return inBetween;
    }
    let prevValueNode = nodes[index - 1];
    if (!prevValueNode) {
        // eslint-disable-next-line consistent-return
        return;
    }
    if (prevValueNode.type === "space") {
        if (!nodes[index - 2]) {
            // eslint-disable-next-line consistent-return
            return;
        }
        prevValueNode = nodes[index - 2];
    }
    if (prevValueNode.type !== "comment") {
        // eslint-disable-next-line consistent-return
        return;
    }
    const matched = prevValueNode.value.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
    return matched && matched[2] === "true";
}
function shouldHandleURL(url, declaration, result) {
    if (url.length === 0) {
        result.warn(`Unable to find uri in '${declaration.toString()}'`, {
            node: declaration
        });
        return false;
    }
    if (!(0, _utils.isUrlRequestable)(url)) {
        return false;
    }
    return true;
}
function parseDeclaration(declaration, key, result) {
    if (!needParseDeclaration.test(declaration[key])) {
        return;
    }
    const parsed = (0, _postcssValueParser.default)(declaration.raws && declaration.raws.value && declaration.raws.value.raw ? declaration.raws.value.raw : declaration[key]);
    let inBetween;
    if (declaration.raws && declaration.raws.between) {
        const lastCommentIndex = declaration.raws.between.lastIndexOf("/*");
        const matched = declaration.raws.between.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched) {
            inBetween = matched[2] === "true";
        }
    }
    let isIgnoreOnDeclaration = false;
    const prevNode = declaration.prev();
    if (prevNode && prevNode.type === "comment") {
        const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched) {
            isIgnoreOnDeclaration = matched[2] === "true";
        }
    }
    let needIgnore;
    const parsedURLs = [];
    parsed.walk((valueNode, index, valueNodes)=>{
        if (valueNode.type !== "function") {
            return;
        }
        if (isUrlFunc.test(valueNode.value)) {
            needIgnore = getWebpackIgnoreCommentValue(index, valueNodes, inBetween);
            if (isIgnoreOnDeclaration && typeof needIgnore === "undefined" || needIgnore) {
                if (needIgnore) {
                    // eslint-disable-next-line no-undefined
                    needIgnore = undefined;
                }
                return;
            }
            const { nodes } = valueNode;
            const isStringValue = nodes.length !== 0 && nodes[0].type === "string";
            let url = isStringValue ? nodes[0].value : _postcssValueParser.default.stringify(nodes);
            url = (0, _utils.normalizeUrl)(url, isStringValue); // Do not traverse inside `url`
            if (!shouldHandleURL(url, declaration, result)) {
                // eslint-disable-next-line consistent-return
                return false;
            }
            const queryParts = url.split("!");
            let prefix;
            if (queryParts.length > 1) {
                url = queryParts.pop();
                prefix = queryParts.join("!");
            }
            parsedURLs.push({
                declaration,
                parsed,
                node: getNodeFromUrlFunc(valueNode),
                prefix,
                url,
                needQuotes: false
            }); // eslint-disable-next-line consistent-return
            return false;
        } else if (isImageSetFunc.test(valueNode.value)) {
            for (const [innerIndex, nNode] of valueNode.nodes.entries()){
                const { type, value } = nNode;
                if (type === "function" && isUrlFunc.test(value)) {
                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);
                    if (isIgnoreOnDeclaration && typeof needIgnore === "undefined" || needIgnore) {
                        if (needIgnore) {
                            // eslint-disable-next-line no-undefined
                            needIgnore = undefined;
                        } // eslint-disable-next-line no-continue
                        continue;
                    }
                    const { nodes } = nNode;
                    const isStringValue = nodes.length !== 0 && nodes[0].type === "string";
                    let url = isStringValue ? nodes[0].value : _postcssValueParser.default.stringify(nodes);
                    url = (0, _utils.normalizeUrl)(url, isStringValue); // Do not traverse inside `url`
                    if (!shouldHandleURL(url, declaration, result)) {
                        // eslint-disable-next-line consistent-return
                        return false;
                    }
                    const queryParts = url.split("!");
                    let prefix;
                    if (queryParts.length > 1) {
                        url = queryParts.pop();
                        prefix = queryParts.join("!");
                    }
                    parsedURLs.push({
                        declaration,
                        parsed,
                        node: getNodeFromUrlFunc(nNode),
                        prefix,
                        url,
                        needQuotes: false
                    });
                } else if (type === "string") {
                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);
                    if (isIgnoreOnDeclaration && typeof needIgnore === "undefined" || needIgnore) {
                        if (needIgnore) {
                            // eslint-disable-next-line no-undefined
                            needIgnore = undefined;
                        } // eslint-disable-next-line no-continue
                        continue;
                    }
                    let url = (0, _utils.normalizeUrl)(value, true); // Do not traverse inside `url`
                    if (!shouldHandleURL(url, declaration, result)) {
                        // eslint-disable-next-line consistent-return
                        return false;
                    }
                    const queryParts = url.split("!");
                    let prefix;
                    if (queryParts.length > 1) {
                        url = queryParts.pop();
                        prefix = queryParts.join("!");
                    }
                    parsedURLs.push({
                        declaration,
                        parsed,
                        node: nNode,
                        prefix,
                        url,
                        needQuotes: true
                    });
                }
            } // Do not traverse inside `image-set`
            // eslint-disable-next-line consistent-return
            return false;
        }
    }); // eslint-disable-next-line consistent-return
    return parsedURLs;
}
const plugin = (options = {})=>{
    return {
        postcssPlugin: "postcss-url-parser",
        prepare (result) {
            const parsedDeclarations = [];
            return {
                Declaration (declaration) {
                    const parsedURL = parseDeclaration(declaration, "value", result);
                    if (!parsedURL) {
                        return;
                    }
                    parsedDeclarations.push(...parsedURL);
                },
                async OnceExit () {
                    if (parsedDeclarations.length === 0) {
                        return;
                    }
                    const resolvedDeclarations = await Promise.all(parsedDeclarations.map(async (parsedDeclaration)=>{
                        const { url } = parsedDeclaration;
                        if (options.filter) {
                            const needKeep = await options.filter(url);
                            if (!needKeep) {
                                return;
                            }
                        }
                        const splittedUrl = url.split(/(\?)?#/);
                        const [pathname, query, hashOrQuery] = splittedUrl;
                        let hash = query ? "?" : "";
                        hash += hashOrQuery ? `#${hashOrQuery}` : "";
                        const request = (0, _utils.requestify)(pathname, options.rootContext);
                        const { resolver, context } = options;
                        const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                            ...new Set([
                                request,
                                url
                            ])
                        ]);
                        if (!resolvedUrl) {
                            return;
                        } // eslint-disable-next-line consistent-return
                        return {
                            ...parsedDeclaration,
                            url: resolvedUrl,
                            hash
                        };
                    }));
                    const urlToNameMap = new Map();
                    const urlToReplacementMap = new Map();
                    let hasUrlImportHelper = false;
                    for(let index = 0; index <= resolvedDeclarations.length - 1; index++){
                        const item = resolvedDeclarations[index];
                        if (!item) {
                            continue;
                        }
                        if (!hasUrlImportHelper) {
                            options.imports.push({
                                importName: "___CSS_LOADER_GET_URL_IMPORT___",
                                url: options.urlHandler("[project]/node_modules/css-loader/dist/runtime/getUrl.js [app-route] (ecmascript)"),
                                index: -1
                            });
                            hasUrlImportHelper = true;
                        }
                        const { url, prefix } = item;
                        const newUrl = prefix ? `${prefix}!${url}` : url;
                        let importName = urlToNameMap.get(newUrl);
                        if (!importName) {
                            importName = `___CSS_LOADER_URL_IMPORT_${urlToNameMap.size}___`;
                            urlToNameMap.set(newUrl, importName);
                            options.imports.push({
                                importName,
                                url: options.urlHandler(newUrl),
                                index
                            });
                        }
                        const { hash, needQuotes } = item;
                        const replacementKey = JSON.stringify({
                            newUrl,
                            hash,
                            needQuotes
                        });
                        let replacementName = urlToReplacementMap.get(replacementKey);
                        if (!replacementName) {
                            replacementName = `___CSS_LOADER_URL_REPLACEMENT_${urlToReplacementMap.size}___`;
                            urlToReplacementMap.set(replacementKey, replacementName);
                            options.replacements.push({
                                replacementName,
                                importName,
                                hash,
                                needQuotes
                            });
                        } // eslint-disable-next-line no-param-reassign
                        item.node.type = "word"; // eslint-disable-next-line no-param-reassign
                        item.node.value = replacementName; // eslint-disable-next-line no-param-reassign
                        item.declaration.value = item.parsed.toString();
                    }
                }
            };
        }
    };
};
plugin.postcss = true;
var _default = plugin;
exports.default = _default;
}),
"[project]/node_modules/css-loader/dist/plugins/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "importParser", {
    enumerable: true,
    get: function() {
        return _postcssImportParser.default;
    }
});
Object.defineProperty(exports, "icssParser", {
    enumerable: true,
    get: function() {
        return _postcssIcssParser.default;
    }
});
Object.defineProperty(exports, "urlParser", {
    enumerable: true,
    get: function() {
        return _postcssUrlParser.default;
    }
});
var _postcssImportParser = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/plugins/postcss-import-parser.js [app-route] (ecmascript)"));
var _postcssIcssParser = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/plugins/postcss-icss-parser.js [app-route] (ecmascript)"));
var _postcssUrlParser = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/plugins/postcss-url-parser.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
}),
"[project]/node_modules/css-loader/dist/runtime/api.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ // css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function(cssWithMappingToString) {
    var list = []; // return the list of modules as css string
    list.toString = function toString() {
        return this.map(function(item) {
            var content = cssWithMappingToString(item);
            if (item[2]) {
                return "@media ".concat(item[2], " {").concat(content, "}");
            }
            return content;
        }).join("");
    }; // import a list of modules into the list
    // eslint-disable-next-line func-names
    list.i = function(modules, mediaQuery, dedupe) {
        if (typeof modules === "string") {
            // eslint-disable-next-line no-param-reassign
            modules = [
                [
                    null,
                    modules,
                    ""
                ]
            ];
        }
        var alreadyImportedModules = {};
        if (dedupe) {
            for(var i = 0; i < this.length; i++){
                // eslint-disable-next-line prefer-destructuring
                var id = this[i][0];
                if (id != null) {
                    alreadyImportedModules[id] = true;
                }
            }
        }
        for(var _i = 0; _i < modules.length; _i++){
            var item = [].concat(modules[_i]);
            if (dedupe && alreadyImportedModules[item[0]]) {
                continue;
            }
            if (mediaQuery) {
                if (!item[2]) {
                    item[2] = mediaQuery;
                } else {
                    item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
                }
            }
            list.push(item);
        }
    };
    return list;
};
}),
"[project]/node_modules/css-loader/dist/runtime/cssWithMappingToString.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
module.exports = function cssWithMappingToString(item) {
    var _item = _slicedToArray(item, 4), content = _item[1], cssMapping = _item[3];
    if (!cssMapping) {
        return content;
    }
    if (typeof btoa === "function") {
        // eslint-disable-next-line no-undef
        var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
        var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
        var sourceMapping = "/*# ".concat(data, " */");
        var sourceURLs = cssMapping.sources.map(function(source) {
            return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
        });
        return [
            content
        ].concat(sourceURLs).concat([
            sourceMapping
        ]).join("\n");
    }
    return [
        content
    ].join("\n");
};
}),
"[project]/node_modules/css-loader/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = loader;
var _loaderUtils = __turbopack_context__.r("[project]/node_modules/loader-utils/lib/index.js [app-route] (ecmascript)");
var _postcss = _interopRequireDefault(__turbopack_context__.r("[externals]/postcss [external] (postcss, cjs)"));
var _package = _interopRequireDefault(__turbopack_context__.r("[externals]/postcss/package.json [external] (postcss/package.json, cjs)"));
var _schemaUtils = __turbopack_context__.r("[project]/node_modules/schema-utils/dist/index.js [app-route] (ecmascript)");
var _semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
var _CssSyntaxError = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/CssSyntaxError.js [app-route] (ecmascript)"));
var _Warning = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/Warning.js [app-route] (ecmascript)"));
var _options = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/css-loader/dist/options.json (json)"));
var _plugins = __turbopack_context__.r("[project]/node_modules/css-loader/dist/plugins/index.js [app-route] (ecmascript)");
var _utils = __turbopack_context__.r("[project]/node_modules/css-loader/dist/utils.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ async function loader(content, map, meta) {
    const rawOptions = (0, _loaderUtils.getOptions)(this);
    (0, _schemaUtils.validate)(_options.default, rawOptions, {
        name: "CSS Loader",
        baseDataPath: "options"
    });
    const plugins = [];
    const callback = this.async();
    let options;
    try {
        options = (0, _utils.normalizeOptions)(rawOptions, this);
    } catch (error) {
        callback(error);
        return;
    }
    const replacements = [];
    const exports1 = [];
    if ((0, _utils.shouldUseModulesPlugins)(options)) {
        plugins.push(...(0, _utils.getModulesPlugins)(options, this));
    }
    const importPluginImports = [];
    const importPluginApi = [];
    if ((0, _utils.shouldUseImportPlugin)(options)) {
        const resolver = this.getResolve({
            conditionNames: [
                "style"
            ],
            extensions: [
                ".css"
            ],
            mainFields: [
                "css",
                "style",
                "main",
                "..."
            ],
            mainFiles: [
                "index",
                "..."
            ]
        });
        plugins.push((0, _plugins.importParser)({
            imports: importPluginImports,
            api: importPluginApi,
            context: this.context,
            rootContext: this.rootContext,
            filter: (0, _utils.getFilter)(options.import, this.resourcePath),
            resolver,
            urlHandler: (url)=>(0, _loaderUtils.stringifyRequest)(this, (0, _utils.combineRequests)((0, _utils.getPreRequester)(this)(options.importLoaders), url))
        }));
    }
    const urlPluginImports = [];
    if ((0, _utils.shouldUseURLPlugin)(options)) {
        const urlResolver = this.getResolve({
            conditionNames: [
                "asset"
            ],
            mainFields: [
                "asset"
            ],
            mainFiles: [],
            extensions: []
        });
        plugins.push((0, _plugins.urlParser)({
            imports: urlPluginImports,
            replacements,
            context: this.context,
            rootContext: this.rootContext,
            filter: (0, _utils.getFilter)(options.url, this.resourcePath),
            resolver: urlResolver,
            urlHandler: (url)=>(0, _loaderUtils.stringifyRequest)(this, url)
        }));
    }
    const icssPluginImports = [];
    const icssPluginApi = [];
    const needToUseIcssPlugin = (0, _utils.shouldUseIcssPlugin)(options);
    if (needToUseIcssPlugin) {
        const icssResolver = this.getResolve({
            conditionNames: [
                "style"
            ],
            extensions: [],
            mainFields: [
                "css",
                "style",
                "main",
                "..."
            ],
            mainFiles: [
                "index",
                "..."
            ]
        });
        plugins.push((0, _plugins.icssParser)({
            imports: icssPluginImports,
            api: icssPluginApi,
            replacements,
            exports: exports1,
            context: this.context,
            rootContext: this.rootContext,
            resolver: icssResolver,
            urlHandler: (url)=>(0, _loaderUtils.stringifyRequest)(this, (0, _utils.combineRequests)((0, _utils.getPreRequester)(this)(options.importLoaders), url))
        }));
    } // Reuse CSS AST (PostCSS AST e.g 'postcss-loader') to avoid reparsing
    if (meta) {
        const { ast } = meta;
        if (ast && ast.type === "postcss" && (0, _semver.satisfies)(ast.version, `^${_package.default.version}`)) {
            // eslint-disable-next-line no-param-reassign
            content = ast.root;
        }
    }
    const { resourcePath } = this;
    let result;
    try {
        result = await (0, _postcss.default)(plugins).process(content, {
            hideNothingWarning: true,
            from: resourcePath,
            to: resourcePath,
            map: options.sourceMap ? {
                prev: map ? (0, _utils.normalizeSourceMap)(map, resourcePath) : null,
                inline: false,
                annotation: false
            } : false
        });
    } catch (error) {
        if (error.file) {
            this.addDependency(error.file);
        }
        callback(error.name === "CssSyntaxError" ? new _CssSyntaxError.default(error) : error);
        return;
    }
    for (const warning of result.warnings()){
        this.emitWarning(new _Warning.default(warning));
    }
    const imports = [].concat(icssPluginImports.sort(_utils.sort)).concat(importPluginImports.sort(_utils.sort)).concat(urlPluginImports.sort(_utils.sort));
    const api = [].concat(importPluginApi.sort(_utils.sort)).concat(icssPluginApi.sort(_utils.sort));
    if (options.modules.exportOnlyLocals !== true) {
        imports.unshift({
            importName: "___CSS_LOADER_API_IMPORT___",
            url: (0, _loaderUtils.stringifyRequest)(this, "[project]/node_modules/css-loader/dist/runtime/api.js [app-route] (ecmascript)")
        });
        if (options.sourceMap) {
            imports.unshift({
                importName: "___CSS_LOADER_API_SOURCEMAP_IMPORT___",
                url: (0, _loaderUtils.stringifyRequest)(this, "[project]/node_modules/css-loader/dist/runtime/cssWithMappingToString.js [app-route] (ecmascript)")
            });
        }
    }
    const importCode = (0, _utils.getImportCode)(imports, options);
    const moduleCode = (0, _utils.getModuleCode)(result, api, replacements, options, this);
    const exportCode = (0, _utils.getExportCode)(exports1, replacements, needToUseIcssPlugin, options);
    callback(null, `${importCode}${moduleCode}${exportCode}`);
}
}),
"[project]/node_modules/css-loader/dist/cjs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const loader = __turbopack_context__.r("[project]/node_modules/css-loader/dist/index.js [app-route] (ecmascript)");
module.exports = loader.default;
}),
"[project]/node_modules/postcss-value-parser/lib/unit.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code >= 48 && code <= 57) {
        return true;
    }
    return false;
}
// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
        return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
        pos++;
    }
    while(pos < length){
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
            break;
        }
        pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
    };
};
}),
"[project]/node_modules/postcss-value-parser/lib/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;
module.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [
        {
            nodes: tokens
        }
    ];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while(pos < max){
        // Whitespaces
        if (code <= 32) {
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
                after = token;
            } else if (prev && prev.type === "div") {
                prev.after = token;
                prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                before = token;
            } else {
                tokens.push({
                    type: "space",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        // Quotes
        } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
                type: "string",
                sourceIndex: pos,
                quote: quote
            };
            do {
                escape = false;
                next = value.indexOf(quote, next + 1);
                if (~next) {
                    escapePos = next;
                    while(value.charCodeAt(escapePos - 1) === backslash){
                        escapePos -= 1;
                        escape = !escape;
                    }
                } else {
                    value += quote;
                    next = value.length - 1;
                    token.unclosed = true;
                }
            }while (escape)
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);
        // Comments
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
                type: "comment",
                sourceIndex: pos,
                sourceEndIndex: next + 2
            };
            if (next === -1) {
                token.unclosed = true;
                next = value.length;
                token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value.charCodeAt(pos);
        // Operation within calc
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
                type: "word",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token
            });
            pos += 1;
            code = value.charCodeAt(pos);
        // Dividers
        } else if (code === slash || code === comma || code === colon) {
            token = value[pos];
            tokens.push({
                type: "div",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token,
                before: before,
                after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
        // Open parentheses
        } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            parenthesesOpenPos = pos;
            token = {
                type: "function",
                sourceIndex: pos - name.length,
                value: name,
                before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                next -= 1;
                do {
                    escape = false;
                    next = value.indexOf(")", next + 1);
                    if (~next) {
                        escapePos = next;
                        while(value.charCodeAt(escapePos - 1) === backslash){
                            escapePos -= 1;
                            escape = !escape;
                        }
                    } else {
                        value += ")";
                        next = value.length - 1;
                        token.unclosed = true;
                    }
                }while (escape)
                // Whitespaces before closed
                whitespacePos = next;
                do {
                    whitespacePos -= 1;
                    code = value.charCodeAt(whitespacePos);
                }while (code <= 32)
                if (parenthesesOpenPos < whitespacePos) {
                    if (pos !== whitespacePos + 1) {
                        token.nodes = [
                            {
                                type: "word",
                                sourceIndex: pos,
                                sourceEndIndex: whitespacePos + 1,
                                value: value.slice(pos, whitespacePos + 1)
                            }
                        ];
                    } else {
                        token.nodes = [];
                    }
                    if (token.unclosed && whitespacePos + 1 !== next) {
                        token.after = "";
                        token.nodes.push({
                            type: "space",
                            sourceIndex: whitespacePos + 1,
                            sourceEndIndex: next,
                            value: value.slice(whitespacePos + 1, next)
                        });
                    } else {
                        token.after = value.slice(whitespacePos + 1, next);
                        token.sourceEndIndex = next;
                    }
                } else {
                    token.after = "";
                    token.nodes = [];
                }
                pos = next + 1;
                token.sourceEndIndex = token.unclosed ? next : pos;
                code = value.charCodeAt(pos);
                tokens.push(token);
            } else {
                balanced += 1;
                token.after = "";
                token.sourceEndIndex = pos + 1;
                tokens.push(token);
                stack.push(token);
                tokens = token.nodes = [];
                parent = token;
            }
            name = "";
        // Close parentheses
        } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
        // Words
        } else {
            next = pos;
            do {
                if (code === backslash) {
                    next += 1;
                }
                next += 1;
                code = value.charCodeAt(next);
            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced))
            token = value.slice(pos, next);
            if (openParentheses === code) {
                name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                tokens.push({
                    type: "unicode-range",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            } else {
                tokens.push({
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        }
    }
    for(pos = stack.length - 1; pos; pos -= 1){
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
};
}),
"[project]/node_modules/postcss-value-parser/lib/walk.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for(i = 0, max = nodes.length; i < max; i += 1){
        node = nodes[i];
        if (!bubble) {
            result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
        }
        if (bubble) {
            cb(node, i, nodes);
        }
    }
};
}),
"[project]/node_modules/postcss-value-parser/lib/stringify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
        return customResult;
    } else if (type === "word" || type === "space") {
        return value;
    } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
            return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
}
function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
        result = "";
        for(i = nodes.length - 1; ~i; i -= 1){
            result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
    }
    return stringifyNode(nodes, custom);
}
module.exports = stringify;
}),
"[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var parse = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/parse.js [app-route] (ecmascript)");
var walk = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/walk.js [app-route] (ecmascript)");
var stringify = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/stringify.js [app-route] (ecmascript)");
function ValueParser(value) {
    if (this instanceof ValueParser) {
        this.nodes = parse(value);
        return this;
    }
    return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
};
ValueParser.unit = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/unit.js [app-route] (ecmascript)");
ValueParser.walk = walk;
ValueParser.stringify = stringify;
module.exports = ValueParser;
}),
"[project]/node_modules/icss-utils/src/replaceValueSymbols.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const matchValueName = /[$]?[\w-]+/g;
const replaceValueSymbols = (value, replacements)=>{
    let matches;
    while(matches = matchValueName.exec(value)){
        const replacement = replacements[matches[0]];
        if (replacement) {
            value = value.slice(0, matches.index) + replacement + value.slice(matchValueName.lastIndex);
            matchValueName.lastIndex -= matches[0].length - replacement.length;
        }
    }
    return value;
};
module.exports = replaceValueSymbols;
}),
"[project]/node_modules/icss-utils/src/replaceSymbols.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const replaceValueSymbols = __turbopack_context__.r("[project]/node_modules/icss-utils/src/replaceValueSymbols.js [app-route] (ecmascript)");
const replaceSymbols = (css, replacements)=>{
    css.walk((node)=>{
        if (node.type === "decl" && node.value) {
            node.value = replaceValueSymbols(node.value.toString(), replacements);
        } else if (node.type === "rule" && node.selector) {
            node.selector = replaceValueSymbols(node.selector.toString(), replacements);
        } else if (node.type === "atrule" && node.params) {
            node.params = replaceValueSymbols(node.params.toString(), replacements);
        }
    });
};
module.exports = replaceSymbols;
}),
"[project]/node_modules/icss-utils/src/extractICSS.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
const balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
const getDeclsObject = (rule)=>{
    const object = {};
    rule.walkDecls((decl)=>{
        const before = decl.raws.before ? decl.raws.before.trim() : "";
        object[before + decl.prop] = decl.value;
    });
    return object;
};
/**
 *
 * @param {string} css
 * @param {boolean} removeRules
 * @param {'auto' | 'rule' | 'at-rule'} mode
 */ const extractICSS = (css, removeRules = true, mode = "auto")=>{
    const icssImports = {};
    const icssExports = {};
    function addImports(node, path) {
        const unquoted = path.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(icssImports[unquoted] || {}, getDeclsObject(node));
        if (removeRules) {
            node.remove();
        }
    }
    function addExports(node) {
        Object.assign(icssExports, getDeclsObject(node));
        if (removeRules) {
            node.remove();
        }
    }
    css.each((node)=>{
        if (node.type === "rule" && mode !== "at-rule") {
            if (node.selector.slice(0, 7) === ":import") {
                const matches = importPattern.exec(node.selector);
                if (matches) {
                    addImports(node, matches[1]);
                }
            }
            if (node.selector === ":export") {
                addExports(node);
            }
        }
        if (node.type === "atrule" && mode !== "rule") {
            if (node.name === "icss-import") {
                const matches = balancedQuotes.exec(node.params);
                if (matches) {
                    addImports(node, matches[1]);
                }
            }
            if (node.name === "icss-export") {
                addExports(node);
            }
        }
    });
    return {
        icssImports,
        icssExports
    };
};
module.exports = extractICSS;
}),
"[project]/node_modules/icss-utils/src/createICSSRules.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const createImports = (imports, postcss, mode = "rule")=>{
    return Object.keys(imports).map((path)=>{
        const aliases = imports[path];
        const declarations = Object.keys(aliases).map((key)=>postcss.decl({
                prop: key,
                value: aliases[key],
                raws: {
                    before: "\n  "
                }
            }));
        const hasDeclarations = declarations.length > 0;
        const rule = mode === "rule" ? postcss.rule({
            selector: `:import('${path}')`,
            raws: {
                after: hasDeclarations ? "\n" : ""
            }
        }) : postcss.atRule({
            name: "icss-import",
            params: `'${path}'`,
            raws: {
                after: hasDeclarations ? "\n" : ""
            }
        });
        if (hasDeclarations) {
            rule.append(declarations);
        }
        return rule;
    });
};
const createExports = (exports, postcss, mode = "rule")=>{
    const declarations = Object.keys(exports).map((key)=>postcss.decl({
            prop: key,
            value: exports[key],
            raws: {
                before: "\n  "
            }
        }));
    if (declarations.length === 0) {
        return [];
    }
    const rule = mode === "rule" ? postcss.rule({
        selector: `:export`,
        raws: {
            after: "\n"
        }
    }) : postcss.atRule({
        name: "icss-export",
        raws: {
            after: "\n"
        }
    });
    rule.append(declarations);
    return [
        rule
    ];
};
const createICSSRules = (imports, exports, postcss, mode)=>[
        ...createImports(imports, postcss, mode),
        ...createExports(exports, postcss, mode)
    ];
module.exports = createICSSRules;
}),
"[project]/node_modules/icss-utils/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const replaceValueSymbols = __turbopack_context__.r("[project]/node_modules/icss-utils/src/replaceValueSymbols.js [app-route] (ecmascript)");
const replaceSymbols = __turbopack_context__.r("[project]/node_modules/icss-utils/src/replaceSymbols.js [app-route] (ecmascript)");
const extractICSS = __turbopack_context__.r("[project]/node_modules/icss-utils/src/extractICSS.js [app-route] (ecmascript)");
const createICSSRules = __turbopack_context__.r("[project]/node_modules/icss-utils/src/createICSSRules.js [app-route] (ecmascript)");
module.exports = {
    replaceValueSymbols,
    replaceSymbols,
    extractICSS,
    createICSSRules
};
}),
"[project]/node_modules/postcss-modules-values/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ICSSUtils = __turbopack_context__.r("[project]/node_modules/icss-utils/src/index.js [app-route] (ecmascript)");
const matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
const matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
const matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
module.exports = (options)=>{
    let importIndex = 0;
    const createImportedName = options && options.createImportedName || ((importName /*, path*/ )=>`i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
    return {
        postcssPlugin: "postcss-modules-values",
        prepare (result) {
            const importAliases = [];
            const definitions = {};
            return {
                Once (root, postcss) {
                    root.walkAtRules(/value/i, (atRule)=>{
                        const matches = atRule.params.match(matchImports);
                        if (matches) {
                            let [, /*match*/ aliases, path] = matches;
                            // We can use constants for path names
                            if (definitions[path]) {
                                path = definitions[path];
                            }
                            const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias)=>{
                                const tokens = matchImport.exec(alias);
                                if (tokens) {
                                    const [, /*match*/ theirName, myName = theirName] = tokens;
                                    const importedName = createImportedName(myName);
                                    definitions[myName] = importedName;
                                    return {
                                        theirName,
                                        importedName
                                    };
                                } else {
                                    throw new Error(`@import statement "${alias}" is invalid!`);
                                }
                            });
                            importAliases.push({
                                path,
                                imports
                            });
                            atRule.remove();
                            return;
                        }
                        if (atRule.params.indexOf("@value") !== -1) {
                            result.warn("Invalid value definition: " + atRule.params);
                        }
                        let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);
                        const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                        if (normalizedValue.length === 0) {
                            result.warn("Invalid value definition: " + atRule.params);
                            atRule.remove();
                            return;
                        }
                        let isOnlySpace = /^\s+$/.test(normalizedValue);
                        if (!isOnlySpace) {
                            value = value.trim();
                        }
                        // Add to the definitions, knowing that values can refer to each other
                        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);
                        atRule.remove();
                    });
                    /* If we have no definitions, don't continue */ if (!Object.keys(definitions).length) {
                        return;
                    }
                    /* Perform replacements */ ICSSUtils.replaceSymbols(root, definitions);
                    /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */ const exportDeclarations = Object.keys(definitions).map((key)=>postcss.decl({
                            value: definitions[key],
                            prop: key,
                            raws: {
                                before: "\n  "
                            }
                        }));
                    /* Add export rules if any */ if (exportDeclarations.length > 0) {
                        const exportRule = postcss.rule({
                            selector: ":export",
                            raws: {
                                after: "\n"
                            }
                        });
                        exportRule.append(exportDeclarations);
                        root.prepend(exportRule);
                    }
                    /* Add import rules */ importAliases.reverse().forEach(({ path, imports })=>{
                        const importRule = postcss.rule({
                            selector: `:import(${path})`,
                            raws: {
                                after: "\n"
                            }
                        });
                        imports.forEach(({ theirName, importedName })=>{
                            importRule.append({
                                value: theirName,
                                prop: importedName,
                                raws: {
                                    before: "\n  "
                                }
                            });
                        });
                        root.prepend(importRule);
                    });
                }
            };
        }
    };
};
module.exports.postcss = true;
}),
"[project]/node_modules/cssesc/cssesc.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*! https://mths.be/cssesc v3.0.0 by @mathias */ var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
    if (!options) {
        return defaults;
    }
    var result = {};
    for(var key in defaults){
        // `if (defaults.hasOwnProperty(key) {  }` is not needed here, since
        // only recognized option names are used.
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
    }
    return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
    options = merge(options, cssesc.options);
    if (options.quotes != 'single' && options.quotes != 'double') {
        options.quotes = 'single';
    }
    var quote = options.quotes == 'double' ? '"' : '\'';
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = '';
    var counter = 0;
    var length = string.length;
    while(counter < length){
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        // If its not a printable ASCII character
        if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
                // Its a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                    // next character is low surrogate
                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
                } else {
                    // Its an unmatched surrogate; only append this code unit, in case
                    // the next code unit is the high surrogate of a surrogate pair.
                    counter--;
                }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        } else {
            if (options.escapeEverything) {
                if (regexAnySingleEscape.test(character)) {
                    value = '\\' + character;
                } else {
                    value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
                }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
                value = '\\' + character;
            } else {
                value = character;
            }
        }
        output += value;
    }
    if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
        } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
        }
    }
    // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
    // since theyre redundant. Note that this is only possible if the escape
    // sequence isnt preceded by an odd number of backslashes.
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
            // Its not safe to remove the space, so dont.
            return $0;
        }
        // Strip the space.
        return ($1 || '') + $2;
    });
    if (!isIdentifier && options.wrap) {
        return quote + output + quote;
    }
    return output;
};
// Expose default options (so they can be overridden globally).
cssesc.options = {
    'escapeEverything': false,
    'isIdentifier': false,
    'quotes': 'single',
    'wrap': false
};
cssesc.version = '3.0.0';
module.exports = cssesc;
}),
"[project]/node_modules/util-deprecate/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").deprecate;
}),
"[project]/node_modules/postcss-modules-local-by-default/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const selectorParser = __turbopack_context__.r("[project]/node_modules/postcss-modules-local-by-default/node_modules/postcss-selector-parser/dist/index.js [app-route] (ecmascript)");
const valueParser = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)");
const { extractICSS } = __turbopack_context__.r("[project]/node_modules/icss-utils/src/index.js [app-route] (ecmascript)");
const IGNORE_FILE_MARKER = "cssmodules-pure-no-check";
const IGNORE_NEXT_LINE_MARKER = "cssmodules-pure-ignore";
const isSpacing = (node)=>node.type === "combinator" && node.value === " ";
const isPureCheckDisabled = (root)=>{
    for (const node of root.nodes){
        if (node.type !== "comment") {
            return false;
        }
        if (node.text.trim().startsWith(IGNORE_FILE_MARKER)) {
            return true;
        }
    }
    return false;
};
function getIgnoreComment(node) {
    if (!node.parent) {
        return;
    }
    const indexInParent = node.parent.index(node);
    for(let i = indexInParent - 1; i >= 0; i--){
        const prevNode = node.parent.nodes[i];
        if (prevNode.type === "comment") {
            if (prevNode.text.trimStart().startsWith(IGNORE_NEXT_LINE_MARKER)) {
                return prevNode;
            }
        } else {
            break;
        }
    }
}
function normalizeNodeArray(nodes) {
    const array = [];
    nodes.forEach((x)=>{
        if (Array.isArray(x)) {
            normalizeNodeArray(x).forEach((item)=>{
                array.push(item);
            });
        } else if (x) {
            array.push(x);
        }
    });
    if (array.length > 0 && isSpacing(array[array.length - 1])) {
        array.pop();
    }
    return array;
}
const isPureSelectorSymbol = Symbol("is-pure-selector");
function localizeNode(rule, mode, localAliasMap) {
    const transform = (node, context)=>{
        if (context.ignoreNextSpacing && !isSpacing(node)) {
            throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
        }
        if (context.enforceNoSpacing && isSpacing(node)) {
            throw new Error("Missing whitespace before " + context.enforceNoSpacing);
        }
        let newNodes;
        switch(node.type){
            case "root":
                {
                    let resultingGlobal;
                    context.hasPureGlobals = false;
                    newNodes = node.nodes.map((n)=>{
                        const nContext = {
                            global: context.global,
                            lastWasSpacing: true,
                            hasLocals: false,
                            explicit: false
                        };
                        n = transform(n, nContext);
                        if (typeof resultingGlobal === "undefined") {
                            resultingGlobal = nContext.global;
                        } else if (resultingGlobal !== nContext.global) {
                            throw new Error('Inconsistent rule global/local result in rule "' + node + '" (multiple selectors must result in the same mode for the rule)');
                        }
                        if (!nContext.hasLocals) {
                            context.hasPureGlobals = true;
                        }
                        return n;
                    });
                    context.global = resultingGlobal;
                    node.nodes = normalizeNodeArray(newNodes);
                    break;
                }
            case "selector":
                {
                    newNodes = node.map((childNode)=>transform(childNode, context));
                    node = node.clone();
                    node.nodes = normalizeNodeArray(newNodes);
                    break;
                }
            case "combinator":
                {
                    if (isSpacing(node)) {
                        if (context.ignoreNextSpacing) {
                            context.ignoreNextSpacing = false;
                            context.lastWasSpacing = false;
                            context.enforceNoSpacing = false;
                            return null;
                        }
                        context.lastWasSpacing = true;
                        return node;
                    }
                    break;
                }
            case "pseudo":
                {
                    let childContext;
                    const isNested = !!node.length;
                    const isScoped = node.value === ":local" || node.value === ":global";
                    const isImportExport = node.value === ":import" || node.value === ":export";
                    if (isImportExport) {
                        context.hasLocals = true;
                    // :local(.foo)
                    } else if (isNested) {
                        if (isScoped) {
                            if (node.nodes.length === 0) {
                                throw new Error(`${node.value}() can't be empty`);
                            }
                            if (context.inside) {
                                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
                            }
                            childContext = {
                                global: node.value === ":global",
                                inside: node.value,
                                hasLocals: false,
                                explicit: true
                            };
                            newNodes = node.map((childNode)=>transform(childNode, childContext)).reduce((acc, next)=>acc.concat(next.nodes), []);
                            if (newNodes.length) {
                                const { before, after } = node.spaces;
                                const first = newNodes[0];
                                const last = newNodes[newNodes.length - 1];
                                first.spaces = {
                                    before,
                                    after: first.spaces.after
                                };
                                last.spaces = {
                                    before: last.spaces.before,
                                    after
                                };
                            }
                            node = newNodes;
                            break;
                        } else {
                            childContext = {
                                global: context.global,
                                inside: context.inside,
                                lastWasSpacing: true,
                                hasLocals: false,
                                explicit: context.explicit
                            };
                            newNodes = node.map((childNode)=>{
                                const newContext = {
                                    ...childContext,
                                    enforceNoSpacing: false
                                };
                                const result = transform(childNode, newContext);
                                childContext.global = newContext.global;
                                childContext.hasLocals = newContext.hasLocals;
                                return result;
                            });
                            node = node.clone();
                            node.nodes = normalizeNodeArray(newNodes);
                            if (childContext.hasLocals) {
                                context.hasLocals = true;
                            }
                        }
                        break;
                    //:local .foo .bar
                    } else if (isScoped) {
                        if (context.inside) {
                            throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
                        }
                        const addBackSpacing = !!node.spaces.before;
                        context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;
                        context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;
                        context.global = node.value === ":global";
                        context.explicit = true;
                        // because this node has spacing that is lost when we remove it
                        // we make up for it by adding an extra combinator in since adding
                        // spacing on the parent selector doesn't work
                        return addBackSpacing ? selectorParser.combinator({
                            value: " "
                        }) : null;
                    }
                    break;
                }
            case "id":
            case "class":
                {
                    if (!node.value) {
                        throw new Error("Invalid class or id selector syntax");
                    }
                    if (context.global) {
                        break;
                    }
                    const isImportedValue = localAliasMap.has(node.value);
                    const isImportedWithExplicitScope = isImportedValue && context.explicit;
                    if (!isImportedValue || isImportedWithExplicitScope) {
                        const innerNode = node.clone();
                        innerNode.spaces = {
                            before: "",
                            after: ""
                        };
                        node = selectorParser.pseudo({
                            value: ":local",
                            nodes: [
                                innerNode
                            ],
                            spaces: node.spaces
                        });
                        context.hasLocals = true;
                    }
                    break;
                }
            case "nesting":
                {
                    if (node.value === "&") {
                        context.hasLocals = rule.parent[isPureSelectorSymbol];
                    }
                }
        }
        context.lastWasSpacing = false;
        context.ignoreNextSpacing = false;
        context.enforceNoSpacing = false;
        return node;
    };
    const rootContext = {
        global: mode === "global",
        hasPureGlobals: false
    };
    rootContext.selector = selectorParser((root)=>{
        transform(root, rootContext);
    }).processSync(rule, {
        updateSelector: false,
        lossless: true
    });
    return rootContext;
}
function localizeDeclNode(node, context) {
    switch(node.type){
        case "word":
            if (context.localizeNextItem) {
                if (!context.localAliasMap.has(node.value)) {
                    node.value = ":local(" + node.value + ")";
                    context.localizeNextItem = false;
                }
            }
            break;
        case "function":
            if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === "url") {
                node.nodes.map((nestedNode)=>{
                    if (nestedNode.type !== "string" && nestedNode.type !== "word") {
                        return;
                    }
                    let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);
                    switch(nestedNode.type){
                        case "string":
                            if (nestedNode.quote === "'") {
                                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                            }
                            if (nestedNode.quote === '"') {
                                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                            }
                            break;
                        case "word":
                            newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                            break;
                    }
                    nestedNode.value = newUrl;
                });
            }
            break;
    }
    return node;
}
// `none` is special value, other is global values
const specialKeywords = [
    "none",
    "inherit",
    "initial",
    "revert",
    "revert-layer",
    "unset"
];
function localizeDeclarationValues(localize, declaration, context) {
    const valueNodes = valueParser(declaration.value);
    valueNodes.walk((node, index, nodes)=>{
        if (node.type === "function" && (node.value.toLowerCase() === "var" || node.value.toLowerCase() === "env")) {
            return false;
        }
        if (node.type === "word" && specialKeywords.includes(node.value.toLowerCase())) {
            return;
        }
        const subContext = {
            options: context.options,
            global: context.global,
            localizeNextItem: localize && !context.global,
            localAliasMap: context.localAliasMap
        };
        nodes[index] = localizeDeclNode(node, subContext);
    });
    declaration.value = valueNodes.toString();
}
// letter
// An uppercase letter or a lowercase letter.
//
// ident-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
//
// ident code point
// An ident-start code point, a digit, or U+002D HYPHEN-MINUS (-).
// We don't validate `hex digits`, because we don't need it, it is work of linters.
const validIdent = /^-?([a-z\u0080-\uFFFF_]|(\\[^\r\n\f])|-(?![0-9]))((\\[^\r\n\f])|[a-z\u0080-\uFFFF_0-9-])*$/i;
/*
    The spec defines some keywords that you can use to describe properties such as the timing
    function. These are still valid animation names, so as long as there is a property that accepts
    a keyword, it is given priority. Only when all the properties that can take a keyword are
    exhausted can the animation name be set to the keyword. I.e.

    animation: infinite infinite;

    The animation will repeat an infinite number of times from the first argument, and will have an
    animation name of infinite from the second.
    */ const animationKeywords = {
    // animation-direction
    $normal: 1,
    $reverse: 1,
    $alternate: 1,
    "$alternate-reverse": 1,
    // animation-fill-mode
    $forwards: 1,
    $backwards: 1,
    $both: 1,
    // animation-iteration-count
    $infinite: 1,
    // animation-play-state
    $paused: 1,
    $running: 1,
    // animation-timing-function
    $ease: 1,
    "$ease-in": 1,
    "$ease-out": 1,
    "$ease-in-out": 1,
    $linear: 1,
    "$step-end": 1,
    "$step-start": 1,
    // Special
    $none: Infinity,
    // Global values
    $initial: Infinity,
    $inherit: Infinity,
    $unset: Infinity,
    $revert: Infinity,
    "$revert-layer": Infinity
};
function localizeDeclaration(declaration, context) {
    const isAnimation = /animation(-name)?$/i.test(declaration.prop);
    if (isAnimation) {
        let parsedAnimationKeywords = {};
        const valueNodes = valueParser(declaration.value).walk((node)=>{
            // If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh.
            if (node.type === "div") {
                parsedAnimationKeywords = {};
                return;
            } else if (node.type === "function" && node.value.toLowerCase() === "local" && node.nodes.length === 1) {
                node.type = "word";
                node.value = node.nodes[0].value;
                return localizeDeclNode(node, {
                    options: context.options,
                    global: context.global,
                    localizeNextItem: true,
                    localAliasMap: context.localAliasMap
                });
            } else if (node.type === "function") {
                // replace `animation: global(example)` with `animation-name: example`
                if (node.value.toLowerCase() === "global" && node.nodes.length === 1) {
                    node.type = "word";
                    node.value = node.nodes[0].value;
                }
                // Do not handle nested functions
                return false;
            } else if (node.type !== "word") {
                return;
            }
            const value = node.type === "word" ? node.value.toLowerCase() : null;
            let shouldParseAnimationName = false;
            if (value && validIdent.test(value)) {
                if ("$" + value in animationKeywords) {
                    parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
                    shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
                } else {
                    shouldParseAnimationName = true;
                }
            }
            return localizeDeclNode(node, {
                options: context.options,
                global: context.global,
                localizeNextItem: shouldParseAnimationName && !context.global,
                localAliasMap: context.localAliasMap
            });
        });
        declaration.value = valueNodes.toString();
        return;
    }
    if (/url\(/i.test(declaration.value)) {
        return localizeDeclarationValues(false, declaration, context);
    }
}
const isPureSelector = (context, rule)=>{
    if (!rule.parent || rule.type === "root") {
        return !context.hasPureGlobals;
    }
    if (rule.type === "rule" && rule[isPureSelectorSymbol]) {
        return rule[isPureSelectorSymbol] || isPureSelector(context, rule.parent);
    }
    return !context.hasPureGlobals || isPureSelector(context, rule.parent);
};
const isNodeWithoutDeclarations = (rule)=>{
    if (rule.nodes.length > 0) {
        return !rule.nodes.every((item)=>item.type === "rule" || item.type === "atrule" && !isNodeWithoutDeclarations(item));
    }
    return true;
};
module.exports = (options = {})=>{
    if (options && options.mode && options.mode !== "global" && options.mode !== "local" && options.mode !== "pure") {
        throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
    }
    const pureMode = options && options.mode === "pure";
    const globalMode = options && options.mode === "global";
    return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare () {
            const localAliasMap = new Map();
            return {
                Once (root) {
                    const { icssImports } = extractICSS(root, false);
                    const enforcePureMode = pureMode && !isPureCheckDisabled(root);
                    Object.keys(icssImports).forEach((key)=>{
                        Object.keys(icssImports[key]).forEach((prop)=>{
                            localAliasMap.set(prop, icssImports[key][prop]);
                        });
                    });
                    root.walkAtRules((atRule)=>{
                        if (/keyframes$/i.test(atRule.name)) {
                            const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(atRule.params);
                            const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(atRule.params);
                            let globalKeyframes = globalMode;
                            if (globalMatch) {
                                if (enforcePureMode) {
                                    const ignoreComment = getIgnoreComment(atRule);
                                    if (!ignoreComment) {
                                        throw atRule.error("@keyframes :global(...) is not allowed in pure mode");
                                    } else {
                                        ignoreComment.remove();
                                    }
                                }
                                atRule.params = globalMatch[1];
                                globalKeyframes = true;
                            } else if (localMatch) {
                                atRule.params = localMatch[0];
                                globalKeyframes = false;
                            } else if (atRule.params && !globalMode && !localAliasMap.has(atRule.params)) {
                                atRule.params = ":local(" + atRule.params + ")";
                            }
                            atRule.walkDecls((declaration)=>{
                                localizeDeclaration(declaration, {
                                    localAliasMap,
                                    options: options,
                                    global: globalKeyframes
                                });
                            });
                        } else if (/scope$/i.test(atRule.name)) {
                            if (atRule.params) {
                                const ignoreComment = pureMode ? getIgnoreComment(atRule) : undefined;
                                if (ignoreComment) {
                                    ignoreComment.remove();
                                }
                                atRule.params = atRule.params.split("to").map((item)=>{
                                    const selector = item.trim().slice(1, -1).trim();
                                    const context = localizeNode(selector, options.mode, localAliasMap);
                                    context.options = options;
                                    context.localAliasMap = localAliasMap;
                                    if (enforcePureMode && context.hasPureGlobals && !ignoreComment) {
                                        throw atRule.error('Selector in at-rule"' + selector + '" is not pure ' + "(pure selectors must contain at least one local class or id)");
                                    }
                                    return `(${context.selector})`;
                                }).join(" to ");
                            }
                            atRule.nodes.forEach((declaration)=>{
                                if (declaration.type === "decl") {
                                    localizeDeclaration(declaration, {
                                        localAliasMap,
                                        options: options,
                                        global: globalMode
                                    });
                                }
                            });
                        } else if (atRule.nodes) {
                            atRule.nodes.forEach((declaration)=>{
                                if (declaration.type === "decl") {
                                    localizeDeclaration(declaration, {
                                        localAliasMap,
                                        options: options,
                                        global: globalMode
                                    });
                                }
                            });
                        }
                    });
                    root.walkRules((rule)=>{
                        if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                            // ignore keyframe rules
                            return;
                        }
                        const context = localizeNode(rule, options.mode, localAliasMap);
                        context.options = options;
                        context.localAliasMap = localAliasMap;
                        const ignoreComment = enforcePureMode ? getIgnoreComment(rule) : undefined;
                        const isNotPure = enforcePureMode && !isPureSelector(context, rule);
                        if (isNotPure && isNodeWithoutDeclarations(rule) && !ignoreComment) {
                            throw rule.error('Selector "' + rule.selector + '" is not pure ' + "(pure selectors must contain at least one local class or id)");
                        } else if (ignoreComment) {
                            ignoreComment.remove();
                        }
                        if (pureMode) {
                            rule[isPureSelectorSymbol] = !isNotPure;
                        }
                        rule.selector = context.selector;
                        // Less-syntax mixins parse as rules with no nodes
                        if (rule.nodes) {
                            rule.nodes.forEach((declaration)=>localizeDeclaration(declaration, context));
                        }
                    });
                }
            };
        }
    };
};
module.exports.postcss = true;
}),
"[project]/node_modules/postcss-modules-extract-imports/src/topologicalSort.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const PERMANENT_MARKER = 2;
const TEMPORARY_MARKER = 1;
function createError(node, graph) {
    const er = new Error("Nondeterministic import's order");
    const related = graph[node];
    const relatedNode = related.find((relatedNode)=>graph[relatedNode].indexOf(node) > -1);
    er.nodes = [
        node,
        relatedNode
    ];
    return er;
}
function walkGraph(node, graph, state, result, strict) {
    if (state[node] === PERMANENT_MARKER) {
        return;
    }
    if (state[node] === TEMPORARY_MARKER) {
        if (strict) {
            return createError(node, graph);
        }
        return;
    }
    state[node] = TEMPORARY_MARKER;
    const children = graph[node];
    const length = children.length;
    for(let i = 0; i < length; ++i){
        const error = walkGraph(children[i], graph, state, result, strict);
        if (error instanceof Error) {
            return error;
        }
    }
    state[node] = PERMANENT_MARKER;
    result.push(node);
}
function topologicalSort(graph, strict) {
    const result = [];
    const state = {};
    const nodes = Object.keys(graph);
    const length = nodes.length;
    for(let i = 0; i < length; ++i){
        const er = walkGraph(nodes[i], graph, state, result, strict);
        if (er instanceof Error) {
            return er;
        }
    }
    return result;
}
module.exports = topologicalSort;
}),
"[project]/node_modules/postcss-modules-extract-imports/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const topologicalSort = __turbopack_context__.r("[project]/node_modules/postcss-modules-extract-imports/src/topologicalSort.js [app-route] (ecmascript)");
const matchImports = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
const icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
const VISITED_MARKER = 1;
/**
 * :import('G') {}
 *
 * Rule
 *   composes: ... from 'A'
 *   composes: ... from 'B'

 * Rule
 *   composes: ... from 'A'
 *   composes: ... from 'A'
 *   composes: ... from 'C'
 *
 * Results in:
 *
 * graph: {
 *   G: [],
 *   A: [],
 *   B: ['A'],
 *   C: ['A'],
 * }
 */ function addImportToGraph(importId, parentId, graph, visited) {
    const siblingsId = parentId + "_" + "siblings";
    const visitedId = parentId + "_" + importId;
    if (visited[visitedId] !== VISITED_MARKER) {
        if (!Array.isArray(visited[siblingsId])) {
            visited[siblingsId] = [];
        }
        const siblings = visited[siblingsId];
        if (Array.isArray(graph[importId])) {
            graph[importId] = graph[importId].concat(siblings);
        } else {
            graph[importId] = siblings.slice();
        }
        visited[visitedId] = VISITED_MARKER;
        siblings.push(importId);
    }
}
module.exports = (options = {})=>{
    let importIndex = 0;
    const createImportedName = typeof options.createImportedName !== "function" ? (importName /*, path*/ )=>`i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options.createImportedName;
    const failOnWrongOrder = options.failOnWrongOrder;
    return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare () {
            const graph = {};
            const visited = {};
            const existingImports = {};
            const importDecls = {};
            const imports = {};
            return {
                Once (root, postcss) {
                    // Check the existing imports order and save refs
                    root.walkRules((rule)=>{
                        const matches = icssImport.exec(rule.selector);
                        if (matches) {
                            const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;
                            const importPath = doubleQuotePath || singleQuotePath;
                            addImportToGraph(importPath, "root", graph, visited);
                            existingImports[importPath] = rule;
                        }
                    });
                    root.walkDecls(/^composes$/, (declaration)=>{
                        const multiple = declaration.value.split(",");
                        const values = [];
                        multiple.forEach((value)=>{
                            const matches = value.trim().match(matchImports);
                            if (!matches) {
                                values.push(value);
                                return;
                            }
                            let tmpSymbols;
                            let [, /*match*/ symbols, doubleQuotePath, singleQuotePath, global] = matches;
                            if (global) {
                                // Composing globals simply means changing these classes to wrap them in global(name)
                                tmpSymbols = symbols.split(/\s+/).map((s)=>`global(${s})`);
                            } else {
                                const importPath = doubleQuotePath || singleQuotePath;
                                let parent = declaration.parent;
                                let parentIndexes = "";
                                while(parent.type !== "root"){
                                    parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                                    parent = parent.parent;
                                }
                                const { selector } = declaration.parent;
                                const parentRule = `_${parentIndexes}${selector}`;
                                addImportToGraph(importPath, parentRule, graph, visited);
                                importDecls[importPath] = declaration;
                                imports[importPath] = imports[importPath] || {};
                                tmpSymbols = symbols.split(/\s+/).map((s)=>{
                                    if (!imports[importPath][s]) {
                                        imports[importPath][s] = createImportedName(s, importPath);
                                    }
                                    return imports[importPath][s];
                                });
                            }
                            values.push(tmpSymbols.join(" "));
                        });
                        declaration.value = values.join(", ");
                    });
                    const importsOrder = topologicalSort(graph, failOnWrongOrder);
                    if (importsOrder instanceof Error) {
                        const importPath = importsOrder.nodes.find((importPath)=>// eslint-disable-next-line no-prototype-builtins
                            importDecls.hasOwnProperty(importPath));
                        const decl = importDecls[importPath];
                        throw decl.error("Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath)=>"`" + importPath + "`").join(", ") + ".", {
                            plugin: "postcss-modules-extract-imports",
                            word: "composes"
                        });
                    }
                    let lastImportRule;
                    importsOrder.forEach((path)=>{
                        const importedSymbols = imports[path];
                        let rule = existingImports[path];
                        if (!rule && importedSymbols) {
                            rule = postcss.rule({
                                selector: `:import("${path}")`,
                                raws: {
                                    after: "\n"
                                }
                            });
                            if (lastImportRule) {
                                root.insertAfter(lastImportRule, rule);
                            } else {
                                root.prepend(rule);
                            }
                        }
                        lastImportRule = rule;
                        if (!importedSymbols) {
                            return;
                        }
                        Object.keys(importedSymbols).forEach((importedSymbol)=>{
                            rule.append(postcss.decl({
                                value: importedSymbol,
                                prop: importedSymbols[importedSymbol],
                                raws: {
                                    before: "\n  "
                                }
                            }));
                        });
                    });
                }
            };
        }
    };
};
module.exports.postcss = true;
}),
"[project]/node_modules/postcss-modules-scope/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const selectorParser = __turbopack_context__.r("[project]/node_modules/postcss-modules-scope/node_modules/postcss-selector-parser/dist/index.js [app-route] (ecmascript)");
const hasOwnProperty = Object.prototype.hasOwnProperty;
function isNestedRule(rule) {
    if (!rule.parent || rule.parent.type === "root") {
        return false;
    }
    if (rule.parent.type === "rule") {
        return true;
    }
    return isNestedRule(rule.parent);
}
function getSingleLocalNamesForComposes(root, rule) {
    if (isNestedRule(rule)) {
        throw new Error(`composition is not allowed in nested rule \n\n${rule}`);
    }
    return root.nodes.map((node)=>{
        if (node.type !== "selector" || node.nodes.length !== 1) {
            throw new Error(`composition is only allowed when selector is single :local class name not in "${root}"`);
        }
        node = node.nodes[0];
        if (node.type !== "pseudo" || node.value !== ":local" || node.nodes.length !== 1) {
            throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        node = node.first;
        if (node.type !== "selector" || node.length !== 1) {
            throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        node = node.first;
        if (node.type !== "class") {
            // 'id' is not possible, because you can't compose ids
            throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        return node.value;
    });
}
const whitespace = "[\\x20\\t\\r\\n\\f]";
const unescapeRegExp = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig");
function unescape(str) {
    return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace)=>{
        const high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
    });
}
const plugin = (options = {})=>{
    const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;
    const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;
    const exportGlobals = options && options.exportGlobals;
    return {
        postcssPlugin: "postcss-modules-scope",
        Once (root, { rule }) {
            const exports = Object.create(null);
            function exportScopedName(name, rawName, node) {
                const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css, node);
                const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css, node);
                const { key, value } = exportEntry;
                exports[key] = exports[key] || [];
                if (exports[key].indexOf(value) < 0) {
                    exports[key].push(value);
                }
                return scopedName;
            }
            function localizeNode(node) {
                switch(node.type){
                    case "selector":
                        node.nodes = node.map((item)=>localizeNode(item));
                        return node;
                    case "class":
                        return selectorParser.className({
                            value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null, node)
                        });
                    case "id":
                        {
                            return selectorParser.id({
                                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null, node)
                            });
                        }
                    case "attribute":
                        {
                            if (node.attribute === "class" && node.operator === "=") {
                                return selectorParser.attribute({
                                    attribute: node.attribute,
                                    operator: node.operator,
                                    quoteMark: "'",
                                    value: exportScopedName(node.value, null, null)
                                });
                            }
                        }
                }
                throw new Error(`${node.type} ("${node}") is not allowed in a :local block`);
            }
            function traverseNode(node) {
                switch(node.type){
                    case "pseudo":
                        if (node.value === ":local") {
                            if (node.nodes.length !== 1) {
                                throw new Error('Unexpected comma (",") in :local block');
                            }
                            const selector = localizeNode(node.first);
                            // move the spaces that were around the pseudo selector to the first
                            // non-container node
                            selector.first.spaces = node.spaces;
                            const nextNode = node.next();
                            if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector.last.value)) {
                                selector.last.spaces.after = " ";
                            }
                            node.replaceWith(selector);
                            return;
                        }
                    /* falls through */ case "root":
                    case "selector":
                        {
                            node.each((item)=>traverseNode(item));
                            break;
                        }
                    case "id":
                    case "class":
                        if (exportGlobals) {
                            exports[node.value] = [
                                node.value
                            ];
                        }
                        break;
                }
                return node;
            }
            // Find any :import and remember imported names
            const importedNames = {};
            root.walkRules(/^:import\(.+\)$/, (rule)=>{
                rule.walkDecls((decl)=>{
                    importedNames[decl.prop] = true;
                });
            });
            // Find any :local selectors
            root.walkRules((rule)=>{
                let parsedSelector = selectorParser().astSync(rule);
                rule.selector = traverseNode(parsedSelector.clone()).toString();
                rule.walkDecls(/^(composes|compose-with)$/i, (decl)=>{
                    const localNames = getSingleLocalNamesForComposes(parsedSelector, decl.parent);
                    const multiple = decl.value.split(",");
                    multiple.forEach((value)=>{
                        const classes = value.trim().split(/\s+/);
                        classes.forEach((className)=>{
                            const global = /^global\(([^)]+)\)$/.exec(className);
                            if (global) {
                                localNames.forEach((exportedName)=>{
                                    exports[exportedName].push(global[1]);
                                });
                            } else if (hasOwnProperty.call(importedNames, className)) {
                                localNames.forEach((exportedName)=>{
                                    exports[exportedName].push(className);
                                });
                            } else if (hasOwnProperty.call(exports, className)) {
                                localNames.forEach((exportedName)=>{
                                    exports[className].forEach((item)=>{
                                        exports[exportedName].push(item);
                                    });
                                });
                            } else {
                                throw decl.error(`referenced class name "${className}" in ${decl.prop} not found`);
                            }
                        });
                    });
                    decl.remove();
                });
                // Find any :local values
                rule.walkDecls((decl)=>{
                    if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                        return;
                    }
                    let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
                    tokens = tokens.map((token, idx)=>{
                        if (idx === 0 || tokens[idx - 1] === ",") {
                            let result = token;
                            const localMatch = /:local\s*\((.+?)\)/.exec(token);
                            if (localMatch) {
                                const input = localMatch.input;
                                const matchPattern = localMatch[0];
                                const matchVal = localMatch[1];
                                const newVal = exportScopedName(matchVal);
                                result = input.replace(matchPattern, newVal);
                            } else {
                                return token;
                            }
                            return result;
                        } else {
                            return token;
                        }
                    });
                    decl.value = tokens.join("");
                });
            });
            // Find any :local keyframes
            root.walkAtRules(/keyframes$/i, (atRule)=>{
                const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
                if (!localMatch) {
                    return;
                }
                atRule.params = exportScopedName(localMatch[1]);
            });
            root.walkAtRules(/scope$/i, (atRule)=>{
                if (atRule.params) {
                    atRule.params = atRule.params.split("to").map((item)=>{
                        const selector = item.trim().slice(1, -1).trim();
                        const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(selector);
                        if (!localMatch) {
                            return `(${selector})`;
                        }
                        let parsedSelector = selectorParser().astSync(selector);
                        return `(${traverseNode(parsedSelector).toString()})`;
                    }).join(" to ");
                }
            });
            // If we found any :locals, insert an :export rule
            const exportedNames = Object.keys(exports);
            if (exportedNames.length > 0) {
                const exportRule = rule({
                    selector: ":export"
                });
                exportedNames.forEach((exportedName)=>exportRule.append({
                        prop: exportedName,
                        value: exports[exportedName].join(" "),
                        raws: {
                            before: "\n  "
                        }
                    }));
                root.append(exportRule);
            }
        }
    };
};
plugin.postcss = true;
plugin.generateScopedName = function(name, path) {
    const sanitisedPath = path.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
    return `_${sanitisedPath}__${name}`.trim();
};
plugin.generateExportEntry = function(name, scopedName) {
    return {
        key: unescape(name),
        value: unescape(scopedName)
    };
};
module.exports = plugin;
}),
"[project]/node_modules/@remotion/bundler/node_modules/@esbuild/win32-x64/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"name\":\"@esbuild/win32-x64\",\"version\":\"0.25.0\",\"description\":\"The Windows 64-bit binary for esbuild, a JavaScript bundler.\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/evanw/esbuild.git\"},\"license\":\"MIT\",\"preferUnplugged\":true,\"engines\":{\"node\":\">=18\"},\"os\":[\"win32\"],\"cpu\":[\"x64\"]}"));}),
"[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// lib/npm/node.ts
var node_exports = {};
__export(node_exports, {
    analyzeMetafile: ()=>analyzeMetafile,
    analyzeMetafileSync: ()=>analyzeMetafileSync,
    build: ()=>build,
    buildSync: ()=>buildSync,
    context: ()=>context,
    default: ()=>node_default,
    formatMessages: ()=>formatMessages,
    formatMessagesSync: ()=>formatMessagesSync,
    initialize: ()=>initialize,
    stop: ()=>stop,
    transform: ()=>transform,
    transformSync: ()=>transformSync,
    version: ()=>version
});
module.exports = __toCommonJS(node_exports);
// lib/shared/stdio_protocol.ts
function encodePacket(packet) {
    let visit = (value)=>{
        if (value === null) {
            bb.write8(0);
        } else if (typeof value === "boolean") {
            bb.write8(1);
            bb.write8(+value);
        } else if (typeof value === "number") {
            bb.write8(2);
            bb.write32(value | 0);
        } else if (typeof value === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value);
        } else if (value instanceof Array) {
            bb.write8(5);
            bb.write32(value.length);
            for (let item of value){
                visit(item);
            }
        } else {
            let keys = Object.keys(value);
            bb.write8(6);
            bb.write32(keys.length);
            for (let key of keys){
                bb.write(encodeUTF8(key));
                visit(value[key]);
            }
        }
    };
    let bb = new ByteBuffer();
    bb.write32(0);
    bb.write32(packet.id << 1 | +!packet.isRequest);
    visit(packet.value);
    writeUInt32LE(bb.buf, bb.len - 4, 0);
    return bb.buf.subarray(0, bb.len);
}
function decodePacket(bytes) {
    let visit = ()=>{
        switch(bb.read8()){
            case 0:
                return null;
            case 1:
                return !!bb.read8();
            case 2:
                return bb.read32();
            case 3:
                return decodeUTF8(bb.read());
            case 4:
                return bb.read();
            case 5:
                {
                    let count = bb.read32();
                    let value2 = [];
                    for(let i = 0; i < count; i++){
                        value2.push(visit());
                    }
                    return value2;
                }
            case 6:
                {
                    let count = bb.read32();
                    let value2 = {};
                    for(let i = 0; i < count; i++){
                        value2[decodeUTF8(bb.read())] = visit();
                    }
                    return value2;
                }
            default:
                throw new Error("Invalid packet");
        }
    };
    let bb = new ByteBuffer(bytes);
    let id = bb.read32();
    let isRequest = (id & 1) === 0;
    id >>>= 1;
    let value = visit();
    if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
    }
    return {
        id,
        isRequest,
        value
    };
}
var ByteBuffer = class {
    constructor(buf = new Uint8Array(1024)){
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
    }
    _write(delta) {
        if (this.len + delta > this.buf.length) {
            let clone = new Uint8Array((this.len + delta) * 2);
            clone.set(this.buf);
            this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
    }
    write8(value) {
        let offset = this._write(1);
        this.buf[offset] = value;
    }
    write32(value) {
        let offset = this._write(4);
        writeUInt32LE(this.buf, value, offset);
    }
    write(bytes) {
        let offset = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset);
        this.buf.set(bytes, offset + 4);
    }
    _read(delta) {
        if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
    }
    read8() {
        return this.buf[this._read(1)];
    }
    read32() {
        return readUInt32LE(this.buf, this._read(4));
    }
    read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
    }
};
var encodeUTF8;
var decodeUTF8;
var encodeInvariant;
if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
    let encoder = new TextEncoder();
    let decoder = new TextDecoder();
    encodeUTF8 = (text)=>encoder.encode(text);
    decodeUTF8 = (bytes)=>decoder.decode(bytes);
    encodeInvariant = 'new TextEncoder().encode("")';
} else if (typeof Buffer !== "undefined") {
    encodeUTF8 = (text)=>Buffer.from(text);
    decodeUTF8 = (bytes)=>{
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
    };
    encodeInvariant = 'Buffer.from("")';
} else {
    throw new Error("No UTF-8 codec found");
}
if (!(encodeUTF8("") instanceof Uint8Array)) throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
function readUInt32LE(buffer, offset) {
    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
}
function writeUInt32LE(buffer, value, offset) {
    buffer[offset++] = value;
    buffer[offset++] = value >> 8;
    buffer[offset++] = value >> 16;
    buffer[offset++] = value >> 24;
}
// lib/shared/common.ts
var quote = JSON.stringify;
var buildLogLevelDefault = "warning";
var transformLogLevelDefault = "silent";
function validateTarget(target) {
    validateStringValue(target, "target");
    if (target.indexOf(",") >= 0) throw new Error(`Invalid target: ${target}`);
    return target;
}
var canBeAnything = ()=>null;
var mustBeBoolean = (value)=>typeof value === "boolean" ? null : "a boolean";
var mustBeString = (value)=>typeof value === "string" ? null : "a string";
var mustBeRegExp = (value)=>value instanceof RegExp ? null : "a RegExp object";
var mustBeInteger = (value)=>typeof value === "number" && value === (value | 0) ? null : "an integer";
var mustBeValidPortNumber = (value)=>typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
var mustBeFunction = (value)=>typeof value === "function" ? null : "a function";
var mustBeArray = (value)=>Array.isArray(value) ? null : "an array";
var mustBeObject = (value)=>typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
var mustBeEntryPoints = (value)=>typeof value === "object" && value !== null ? null : "an array or an object";
var mustBeWebAssemblyModule = (value)=>value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
var mustBeObjectOrNull = (value)=>typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
var mustBeStringOrBoolean = (value)=>typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
var mustBeStringOrObject = (value)=>typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
var mustBeStringOrArray = (value)=>typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
var mustBeStringOrUint8Array = (value)=>typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
var mustBeStringOrURL = (value)=>typeof value === "string" || value instanceof URL ? null : "a string or a URL";
function getFlag(object, keys, key, mustBeFn) {
    let value = object[key];
    keys[key + ""] = true;
    if (value === void 0) return void 0;
    let mustBe = mustBeFn(value);
    if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
    return value;
}
function checkForInvalidFlags(object, keys, where) {
    for(let key in object){
        if (!(key in keys)) {
            throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
    }
}
function validateInitializeOptions(options) {
    let keys = /* @__PURE__ */ Object.create(null);
    let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
    let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
    let worker = getFlag(options, keys, "worker", mustBeBoolean);
    checkForInvalidFlags(options, keys, "in initialize() call");
    return {
        wasmURL,
        wasmModule,
        worker
    };
}
function validateMangleCache(mangleCache) {
    let validated;
    if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for(let key in mangleCache){
            let value = mangleCache[key];
            if (typeof value === "string" || value === false) {
                validated[key] = value;
            } else {
                throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
            }
        }
    }
    return validated;
}
function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
    let color = getFlag(options, keys, "color", mustBeBoolean);
    let logLevel = getFlag(options, keys, "logLevel", mustBeString);
    let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
    if (color !== void 0) flags.push(`--color=${color}`);
    else if (isTTY2) flags.push(`--color=true`);
    flags.push(`--log-level=${logLevel || logLevelDefault}`);
    flags.push(`--log-limit=${logLimit || 0}`);
}
function validateStringValue(value, what, key) {
    if (typeof value !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
    }
    return value;
}
function pushCommonFlags(flags, options, keys) {
    let legalComments = getFlag(options, keys, "legalComments", mustBeString);
    let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
    let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
    let target = getFlag(options, keys, "target", mustBeStringOrArray);
    let format = getFlag(options, keys, "format", mustBeString);
    let globalName = getFlag(options, keys, "globalName", mustBeString);
    let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
    let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
    let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
    let minify = getFlag(options, keys, "minify", mustBeBoolean);
    let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
    let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
    let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
    let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
    let drop = getFlag(options, keys, "drop", mustBeArray);
    let dropLabels = getFlag(options, keys, "dropLabels", mustBeArray);
    let charset = getFlag(options, keys, "charset", mustBeString);
    let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
    let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
    let jsx = getFlag(options, keys, "jsx", mustBeString);
    let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
    let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
    let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
    let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
    let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
    let define = getFlag(options, keys, "define", mustBeObject);
    let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
    let supported = getFlag(options, keys, "supported", mustBeObject);
    let pure = getFlag(options, keys, "pure", mustBeArray);
    let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
    let platform = getFlag(options, keys, "platform", mustBeString);
    let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
    if (legalComments) flags.push(`--legal-comments=${legalComments}`);
    if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
    if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
    if (target) {
        if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else flags.push(`--target=${validateTarget(target)}`);
    }
    if (format) flags.push(`--format=${format}`);
    if (globalName) flags.push(`--global-name=${globalName}`);
    if (platform) flags.push(`--platform=${platform}`);
    if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
    if (minify) flags.push("--minify");
    if (minifySyntax) flags.push("--minify-syntax");
    if (minifyWhitespace) flags.push("--minify-whitespace");
    if (minifyIdentifiers) flags.push("--minify-identifiers");
    if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
    if (charset) flags.push(`--charset=${charset}`);
    if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
    if (ignoreAnnotations) flags.push(`--ignore-annotations`);
    if (drop) for (let what of drop)flags.push(`--drop:${validateStringValue(what, "drop")}`);
    if (dropLabels) flags.push(`--drop-labels=${Array.from(dropLabels).map((what)=>validateStringValue(what, "dropLabels")).join(",")}`);
    if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);
    if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);
    if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
    if (jsx) flags.push(`--jsx=${jsx}`);
    if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
    if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
    if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
    if (jsxDev) flags.push(`--jsx-dev`);
    if (jsxSideEffects) flags.push(`--jsx-side-effects`);
    if (define) {
        for(let key in define){
            if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
        }
    }
    if (logOverride) {
        for(let key in logOverride){
            if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
    }
    if (supported) {
        for(let key in supported){
            if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
            const value = supported[key];
            if (typeof value !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
            flags.push(`--supported:${key}=${value}`);
        }
    }
    if (pure) for (let fn of pure)flags.push(`--pure:${validateStringValue(fn, "pure")}`);
    if (keepNames) flags.push(`--keep-names`);
}
function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
    var _a2;
    let flags = [];
    let entries = [];
    let keys = /* @__PURE__ */ Object.create(null);
    let stdinContents = null;
    let stdinResolveDir = null;
    pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
    pushCommonFlags(flags, options, keys);
    let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
    let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
    let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
    let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
    let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
    let outfile = getFlag(options, keys, "outfile", mustBeString);
    let outdir = getFlag(options, keys, "outdir", mustBeString);
    let outbase = getFlag(options, keys, "outbase", mustBeString);
    let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
    let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArray);
    let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArray);
    let mainFields = getFlag(options, keys, "mainFields", mustBeArray);
    let conditions = getFlag(options, keys, "conditions", mustBeArray);
    let external = getFlag(options, keys, "external", mustBeArray);
    let packages = getFlag(options, keys, "packages", mustBeString);
    let alias = getFlag(options, keys, "alias", mustBeObject);
    let loader = getFlag(options, keys, "loader", mustBeObject);
    let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
    let publicPath = getFlag(options, keys, "publicPath", mustBeString);
    let entryNames = getFlag(options, keys, "entryNames", mustBeString);
    let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
    let assetNames = getFlag(options, keys, "assetNames", mustBeString);
    let inject = getFlag(options, keys, "inject", mustBeArray);
    let banner = getFlag(options, keys, "banner", mustBeObject);
    let footer = getFlag(options, keys, "footer", mustBeObject);
    let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
    let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
    let stdin = getFlag(options, keys, "stdin", mustBeObject);
    let write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
    let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
    let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
    keys.plugins = true;
    checkForInvalidFlags(options, keys, `in ${callName}() call`);
    if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
    if (bundle) flags.push("--bundle");
    if (allowOverwrite) flags.push("--allow-overwrite");
    if (splitting) flags.push("--splitting");
    if (preserveSymlinks) flags.push("--preserve-symlinks");
    if (metafile) flags.push(`--metafile`);
    if (outfile) flags.push(`--outfile=${outfile}`);
    if (outdir) flags.push(`--outdir=${outdir}`);
    if (outbase) flags.push(`--outbase=${outbase}`);
    if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
    if (packages) flags.push(`--packages=${packages}`);
    if (resolveExtensions) {
        let values = [];
        for (let value of resolveExtensions){
            validateStringValue(value, "resolve extension");
            if (value.indexOf(",") >= 0) throw new Error(`Invalid resolve extension: ${value}`);
            values.push(value);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
    }
    if (publicPath) flags.push(`--public-path=${publicPath}`);
    if (entryNames) flags.push(`--entry-names=${entryNames}`);
    if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
    if (assetNames) flags.push(`--asset-names=${assetNames}`);
    if (mainFields) {
        let values = [];
        for (let value of mainFields){
            validateStringValue(value, "main field");
            if (value.indexOf(",") >= 0) throw new Error(`Invalid main field: ${value}`);
            values.push(value);
        }
        flags.push(`--main-fields=${values.join(",")}`);
    }
    if (conditions) {
        let values = [];
        for (let value of conditions){
            validateStringValue(value, "condition");
            if (value.indexOf(",") >= 0) throw new Error(`Invalid condition: ${value}`);
            values.push(value);
        }
        flags.push(`--conditions=${values.join(",")}`);
    }
    if (external) for (let name of external)flags.push(`--external:${validateStringValue(name, "external")}`);
    if (alias) {
        for(let old in alias){
            if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
        }
    }
    if (banner) {
        for(let type in banner){
            if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
            flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
    }
    if (footer) {
        for(let type in footer){
            if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
            flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
    }
    if (inject) for (let path3 of inject)flags.push(`--inject:${validateStringValue(path3, "inject")}`);
    if (loader) {
        for(let ext in loader){
            if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
            flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
        }
    }
    if (outExtension) {
        for(let ext in outExtension){
            if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
            flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
        }
    }
    if (entryPoints) {
        if (Array.isArray(entryPoints)) {
            for(let i = 0, n = entryPoints.length; i < n; i++){
                let entryPoint = entryPoints[i];
                if (typeof entryPoint === "object" && entryPoint !== null) {
                    let entryPointKeys = /* @__PURE__ */ Object.create(null);
                    let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
                    let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
                    checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
                    if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
                    if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
                    entries.push([
                        output,
                        input
                    ]);
                } else {
                    entries.push([
                        "",
                        validateStringValue(entryPoint, "entry point at index " + i)
                    ]);
                }
            }
        } else {
            for(let key in entryPoints){
                entries.push([
                    key,
                    validateStringValue(entryPoints[key], "entry point", key)
                ]);
            }
        }
    }
    if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
        if (loader2) flags.push(`--loader=${loader2}`);
        if (resolveDir) stdinResolveDir = resolveDir;
        if (typeof contents === "string") stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array) stdinContents = contents;
    }
    let nodePaths = [];
    if (nodePathsInput) {
        for (let value of nodePathsInput){
            value += "";
            nodePaths.push(value);
        }
    }
    return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
    };
}
function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
    let flags = [];
    let keys = /* @__PURE__ */ Object.create(null);
    pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
    pushCommonFlags(flags, options, keys);
    let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
    let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
    let loader = getFlag(options, keys, "loader", mustBeString);
    let banner = getFlag(options, keys, "banner", mustBeString);
    let footer = getFlag(options, keys, "footer", mustBeString);
    let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
    checkForInvalidFlags(options, keys, `in ${callName}() call`);
    if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
    if (loader) flags.push(`--loader=${loader}`);
    if (banner) flags.push(`--banner=${banner}`);
    if (footer) flags.push(`--footer=${footer}`);
    return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
    };
}
function createChannel(streamIn) {
    const requestCallbacksByKey = {};
    const closeData = {
        didClose: false,
        reason: ""
    };
    let responseCallbacks = {};
    let nextRequestID = 0;
    let nextBuildKey = 0;
    let stdout = new Uint8Array(16 * 1024);
    let stdoutUsed = 0;
    let readFromStdout = (chunk)=>{
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset = 0;
        while(offset + 4 <= stdoutUsed){
            let length = readUInt32LE(stdout, offset);
            if (offset + 4 + length > stdoutUsed) {
                break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length));
            offset += length;
        }
        if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
        }
    };
    let afterClose = (error)=>{
        closeData.didClose = true;
        if (error) closeData.reason = ": " + (error.message || error);
        const text = "The service was stopped" + closeData.reason;
        for(let id in responseCallbacks){
            responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
    };
    let sendRequest = (refs, value, callback)=>{
        if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error, response)=>{
            try {
                callback(error, response);
            } finally{
                if (refs) refs.unref();
            }
        };
        if (refs) refs.ref();
        streamIn.writeToStdin(encodePacket({
            id,
            isRequest: true,
            value
        }));
    };
    let sendResponse = (id, value)=>{
        if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({
            id,
            isRequest: false,
            value
        }));
    };
    let handleRequest = async (id, request)=>{
        try {
            if (request.command === "ping") {
                sendResponse(id, {});
                return;
            }
            if (typeof request.key === "number") {
                const requestCallbacks = requestCallbacksByKey[request.key];
                if (!requestCallbacks) {
                    return;
                }
                const callback = requestCallbacks[request.command];
                if (callback) {
                    await callback(id, request);
                    return;
                }
            }
            throw new Error(`Invalid command: ` + request.command);
        } catch (e) {
            const errors = [
                extractErrorMessageV8(e, streamIn, null, void 0, "")
            ];
            try {
                sendResponse(id, {
                    errors
                });
            } catch  {}
        }
    };
    let isFirstPacket = true;
    let handleIncomingPacket = (bytes)=>{
        if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes);
            if (binaryVersion !== "0.25.0") {
                throw new Error(`Cannot start service: Host version "${"0.25.0"}" does not match binary version ${quote(binaryVersion)}`);
            }
            return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
        } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error) callback(packet.value.error, {});
            else callback(null, packet.value);
        }
    };
    let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback })=>{
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
            ref () {
                if (++refCount === 1) {
                    if (refs) refs.ref();
                }
            },
            unref () {
                if (--refCount === 0) {
                    delete requestCallbacksByKey[buildKey];
                    if (refs) refs.unref();
                }
            }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, buildRefs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, (err, res)=>{
            try {
                callback(err, res);
            } finally{
                buildRefs.unref();
            }
        });
    };
    let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs3, callback })=>{
        const details = createObjectStash();
        let start = (inputPath)=>{
            try {
                if (typeof input !== "string" && !(input instanceof Uint8Array)) throw new Error('The input to "transform" must be a string or a Uint8Array');
                let { flags, mangleCache } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
                let request = {
                    command: "transform",
                    flags,
                    inputFS: inputPath !== null,
                    input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
                };
                if (mangleCache) request.mangleCache = mangleCache;
                sendRequest(refs, request, (error, response)=>{
                    if (error) return callback(new Error(error), null);
                    let errors = replaceDetailsInMessages(response.errors, details);
                    let warnings = replaceDetailsInMessages(response.warnings, details);
                    let outstanding = 1;
                    let next = ()=>{
                        if (--outstanding === 0) {
                            let result = {
                                warnings,
                                code: response.code,
                                map: response.map,
                                mangleCache: void 0,
                                legalComments: void 0
                            };
                            if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
                            if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
                            callback(null, result);
                        }
                    };
                    if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
                    if (response.codeFS) {
                        outstanding++;
                        fs3.readFile(response.code, (err, contents)=>{
                            if (err !== null) {
                                callback(err, null);
                            } else {
                                response.code = contents;
                                next();
                            }
                        });
                    }
                    if (response.mapFS) {
                        outstanding++;
                        fs3.readFile(response.map, (err, contents)=>{
                            if (err !== null) {
                                callback(err, null);
                            } else {
                                response.map = contents;
                                next();
                            }
                        });
                    }
                    next();
                });
            } catch (e) {
                let flags = [];
                try {
                    pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
                } catch  {}
                const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
                sendRequest(refs, {
                    command: "error",
                    flags,
                    error
                }, ()=>{
                    error.detail = details.load(error.detail);
                    callback(failureErrorWithLog("Transform failed", [
                        error
                    ], []), null);
                });
            }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = ()=>fs3.writeFile(input, next);
        }
        start(null);
    };
    let formatMessages2 = ({ callName, refs, messages, options, callback })=>{
        if (!options) throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options, keys, "kind", mustBeString);
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
            command: "format-msgs",
            messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
            isWarning: kind === "warning"
        };
        if (color !== void 0) request.color = color;
        if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error, response)=>{
            if (error) return callback(new Error(error), null);
            callback(null, response.messages);
        });
    };
    let analyzeMetafile2 = ({ callName, refs, metafile, options, callback })=>{
        if (options === void 0) options = {};
        let keys = {};
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        let request = {
            command: "analyze-metafile",
            metafile
        };
        if (color !== void 0) request.color = color;
        if (verbose !== void 0) request.verbose = verbose;
        sendRequest(refs, request, (error, response)=>{
            if (error) return callback(new Error(error), null);
            callback(null, response.result);
        });
    };
    return {
        readFromStdout,
        afterClose,
        service: {
            buildOrContext,
            transform: transform2,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
        }
    };
}
function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
    const details = createObjectStash();
    const isContext = callName === "context";
    const handleError = (e, pluginName)=>{
        const flags = [];
        try {
            pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
        } catch  {}
        const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
        sendRequest(refs, {
            command: "error",
            flags,
            error: message
        }, ()=>{
            message.detail = details.load(message.detail);
            callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [
                message
            ], []), null);
        });
    };
    let plugins;
    if (typeof options === "object") {
        const value = options.plugins;
        if (value !== void 0) {
            if (!Array.isArray(value)) return handleError(new Error(`"plugins" must be an array`), "");
            plugins = value;
        }
    }
    if (plugins && plugins.length > 0) {
        if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, plugins, details).then((result)=>{
            if (!result.ok) return handleError(result.error, result.pluginName);
            try {
                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
            } catch (e) {
                handleError(e, "");
            }
        }, (e)=>handleError(e, ""));
        return;
    }
    try {
        buildOrContextContinue(null, (result, done)=>done([], []), ()=>{});
    } catch (e) {
        handleError(e, "");
    }
    function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const { entries, flags, write, stdinContents, stdinResolveDir, absWorkingDir, nodePaths, mangleCache } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
        if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
        const request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD2,
            nodePaths,
            context: isContext
        };
        if (requestPlugins) request.plugins = requestPlugins;
        if (mangleCache) request.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2)=>{
            const result = {
                errors: replaceDetailsInMessages(response.errors, details),
                warnings: replaceDetailsInMessages(response.warnings, details),
                outputFiles: void 0,
                metafile: void 0,
                mangleCache: void 0
            };
            const originalErrors = result.errors.slice();
            const originalWarnings = result.warnings.slice();
            if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile) result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache) result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
            runOnEndCallbacks(result, (onEndErrors, onEndWarnings)=>{
                if (originalErrors.length > 0 || onEndErrors.length > 0) {
                    const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
                    return callback2(error, null, onEndErrors, onEndWarnings);
                }
                callback2(null, result, onEndErrors, onEndWarnings);
            });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext) requestCallbacks["on-end"] = (id, request2)=>new Promise((resolve)=>{
                buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings)=>{
                    const response = {
                        errors: onEndErrors,
                        warnings: onEndWarnings
                    };
                    if (provideLatestResult) provideLatestResult(err, result);
                    latestResultPromise = void 0;
                    provideLatestResult = void 0;
                    sendResponse(id, response);
                    resolve();
                });
            });
        sendRequest(refs, request, (error, response)=>{
            if (error) return callback(new Error(error), null);
            if (!isContext) {
                return buildResponseToResult(response, (err, res)=>{
                    scheduleOnDisposeCallbacks();
                    return callback(err, res);
                });
            }
            if (response.errors.length > 0) {
                return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
            }
            let didDispose = false;
            const result = {
                rebuild: ()=>{
                    if (!latestResultPromise) latestResultPromise = new Promise((resolve, reject)=>{
                        let settlePromise;
                        provideLatestResult = (err, result2)=>{
                            if (!settlePromise) settlePromise = ()=>err ? reject(err) : resolve(result2);
                        };
                        const triggerAnotherBuild = ()=>{
                            const request2 = {
                                command: "rebuild",
                                key: buildKey
                            };
                            sendRequest(refs, request2, (error2, response2)=>{
                                if (error2) {
                                    reject(new Error(error2));
                                } else if (settlePromise) {
                                    settlePromise();
                                } else {
                                    triggerAnotherBuild();
                                }
                            });
                        };
                        triggerAnotherBuild();
                    });
                    return latestResultPromise;
                },
                watch: (options2 = {})=>new Promise((resolve, reject)=>{
                        if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
                        const keys = {};
                        checkForInvalidFlags(options2, keys, `in watch() call`);
                        const request2 = {
                            command: "watch",
                            key: buildKey
                        };
                        sendRequest(refs, request2, (error2)=>{
                            if (error2) reject(new Error(error2));
                            else resolve(void 0);
                        });
                    }),
                serve: (options2 = {})=>new Promise((resolve, reject)=>{
                        if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
                        const keys = {};
                        const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
                        const host = getFlag(options2, keys, "host", mustBeString);
                        const servedir = getFlag(options2, keys, "servedir", mustBeString);
                        const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
                        const certfile = getFlag(options2, keys, "certfile", mustBeString);
                        const fallback = getFlag(options2, keys, "fallback", mustBeString);
                        const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
                        checkForInvalidFlags(options2, keys, `in serve() call`);
                        const request2 = {
                            command: "serve",
                            key: buildKey,
                            onRequest: !!onRequest
                        };
                        if (port !== void 0) request2.port = port;
                        if (host !== void 0) request2.host = host;
                        if (servedir !== void 0) request2.servedir = servedir;
                        if (keyfile !== void 0) request2.keyfile = keyfile;
                        if (certfile !== void 0) request2.certfile = certfile;
                        if (fallback !== void 0) request2.fallback = fallback;
                        sendRequest(refs, request2, (error2, response2)=>{
                            if (error2) return reject(new Error(error2));
                            if (onRequest) {
                                requestCallbacks["serve-request"] = (id, request3)=>{
                                    onRequest(request3.args);
                                    sendResponse(id, {});
                                };
                            }
                            resolve(response2);
                        });
                    }),
                cancel: ()=>new Promise((resolve)=>{
                        if (didDispose) return resolve();
                        const request2 = {
                            command: "cancel",
                            key: buildKey
                        };
                        sendRequest(refs, request2, ()=>{
                            resolve();
                        });
                    }),
                dispose: ()=>new Promise((resolve)=>{
                        if (didDispose) return resolve();
                        didDispose = true;
                        const request2 = {
                            command: "dispose",
                            key: buildKey
                        };
                        sendRequest(refs, request2, ()=>{
                            resolve();
                            scheduleOnDisposeCallbacks();
                            refs.unref();
                        });
                    })
            };
            refs.ref();
            callback(null, result);
        });
    }
}
var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details)=>{
    let onStartCallbacks = [];
    let onEndCallbacks = [];
    let onResolveCallbacks = {};
    let onLoadCallbacks = {};
    let onDisposeCallbacks = [];
    let nextCallbackID = 0;
    let i = 0;
    let requestPlugins = [];
    let isSetupDone = false;
    plugins = [
        ...plugins
    ];
    for (let item of plugins){
        let keys = {};
        if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
        const name = getFlag(item, keys, "name", mustBeString);
        if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
        try {
            let setup = getFlag(item, keys, "setup", mustBeFunction);
            if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
            let plugin = {
                name,
                onStart: false,
                onEnd: false,
                onResolve: [],
                onLoad: []
            };
            i++;
            let resolve = (path3, options = {})=>{
                if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
                if (typeof path3 !== "string") throw new Error(`The path to resolve must be a string`);
                let keys2 = /* @__PURE__ */ Object.create(null);
                let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
                let importer = getFlag(options, keys2, "importer", mustBeString);
                let namespace = getFlag(options, keys2, "namespace", mustBeString);
                let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
                let kind = getFlag(options, keys2, "kind", mustBeString);
                let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
                let importAttributes = getFlag(options, keys2, "with", mustBeObject);
                checkForInvalidFlags(options, keys2, "in resolve() call");
                return new Promise((resolve2, reject)=>{
                    const request = {
                        command: "resolve",
                        path: path3,
                        key: buildKey,
                        pluginName: name
                    };
                    if (pluginName != null) request.pluginName = pluginName;
                    if (importer != null) request.importer = importer;
                    if (namespace != null) request.namespace = namespace;
                    if (resolveDir != null) request.resolveDir = resolveDir;
                    if (kind != null) request.kind = kind;
                    else throw new Error(`Must specify "kind" when calling "resolve"`);
                    if (pluginData != null) request.pluginData = details.store(pluginData);
                    if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
                    sendRequest(refs, request, (error, response)=>{
                        if (error !== null) reject(new Error(error));
                        else resolve2({
                            errors: replaceDetailsInMessages(response.errors, details),
                            warnings: replaceDetailsInMessages(response.warnings, details),
                            path: response.path,
                            external: response.external,
                            sideEffects: response.sideEffects,
                            namespace: response.namespace,
                            suffix: response.suffix,
                            pluginData: details.load(response.pluginData)
                        });
                    });
                });
            };
            let promise = setup({
                initialOptions,
                resolve,
                onStart (callback) {
                    let registeredText = `This error came from the "onStart" callback registered here:`;
                    let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                    onStartCallbacks.push({
                        name,
                        callback,
                        note: registeredNote
                    });
                    plugin.onStart = true;
                },
                onEnd (callback) {
                    let registeredText = `This error came from the "onEnd" callback registered here:`;
                    let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                    onEndCallbacks.push({
                        name,
                        callback,
                        note: registeredNote
                    });
                    plugin.onEnd = true;
                },
                onResolve (options, callback) {
                    let registeredText = `This error came from the "onResolve" callback registered here:`;
                    let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                    let keys2 = {};
                    let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                    let namespace = getFlag(options, keys2, "namespace", mustBeString);
                    checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
                    if (filter == null) throw new Error(`onResolve() call is missing a filter`);
                    let id = nextCallbackID++;
                    onResolveCallbacks[id] = {
                        name,
                        callback,
                        note: registeredNote
                    };
                    plugin.onResolve.push({
                        id,
                        filter: filter.source,
                        namespace: namespace || ""
                    });
                },
                onLoad (options, callback) {
                    let registeredText = `This error came from the "onLoad" callback registered here:`;
                    let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                    let keys2 = {};
                    let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                    let namespace = getFlag(options, keys2, "namespace", mustBeString);
                    checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
                    if (filter == null) throw new Error(`onLoad() call is missing a filter`);
                    let id = nextCallbackID++;
                    onLoadCallbacks[id] = {
                        name,
                        callback,
                        note: registeredNote
                    };
                    plugin.onLoad.push({
                        id,
                        filter: filter.source,
                        namespace: namespace || ""
                    });
                },
                onDispose (callback) {
                    onDisposeCallbacks.push(callback);
                },
                esbuild: streamIn.esbuild
            });
            if (promise) await promise;
            requestPlugins.push(plugin);
        } catch (e) {
            return {
                ok: false,
                error: e,
                pluginName: name
            };
        }
    }
    requestCallbacks["on-start"] = async (id, request)=>{
        details.clear();
        let response = {
            errors: [],
            warnings: []
        };
        await Promise.all(onStartCallbacks.map(async ({ name, callback, note })=>{
            try {
                let result = await callback();
                if (result != null) {
                    if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
                    let keys = {};
                    let errors = getFlag(result, keys, "errors", mustBeArray);
                    let warnings = getFlag(result, keys, "warnings", mustBeArray);
                    checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);
                    if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
                    if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
                }
            } catch (e) {
                response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
            }
        }));
        sendResponse(id, response);
    };
    requestCallbacks["on-resolve"] = async (id, request)=>{
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids){
            try {
                ({ name, callback, note } = onResolveCallbacks[id2]);
                let result = await callback({
                    path: request.path,
                    importer: request.importer,
                    namespace: request.namespace,
                    resolveDir: request.resolveDir,
                    kind: request.kind,
                    pluginData: details.load(request.pluginData),
                    with: request.with
                });
                if (result != null) {
                    if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                    let path3 = getFlag(result, keys, "path", mustBeString);
                    let namespace = getFlag(result, keys, "namespace", mustBeString);
                    let suffix = getFlag(result, keys, "suffix", mustBeString);
                    let external = getFlag(result, keys, "external", mustBeBoolean);
                    let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
                    let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                    let errors = getFlag(result, keys, "errors", mustBeArray);
                    let warnings = getFlag(result, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);
                    response.id = id2;
                    if (pluginName != null) response.pluginName = pluginName;
                    if (path3 != null) response.path = path3;
                    if (namespace != null) response.namespace = namespace;
                    if (suffix != null) response.suffix = suffix;
                    if (external != null) response.external = external;
                    if (sideEffects != null) response.sideEffects = sideEffects;
                    if (pluginData != null) response.pluginData = details.store(pluginData);
                    if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                    if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                }
            } catch (e) {
                response = {
                    id: id2,
                    errors: [
                        extractErrorMessageV8(e, streamIn, details, note && note(), name)
                    ]
                };
                break;
            }
        }
        sendResponse(id, response);
    };
    requestCallbacks["on-load"] = async (id, request)=>{
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids){
            try {
                ({ name, callback, note } = onLoadCallbacks[id2]);
                let result = await callback({
                    path: request.path,
                    namespace: request.namespace,
                    suffix: request.suffix,
                    pluginData: details.load(request.pluginData),
                    with: request.with
                });
                if (result != null) {
                    if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                    let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
                    let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
                    let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                    let loader = getFlag(result, keys, "loader", mustBeString);
                    let errors = getFlag(result, keys, "errors", mustBeArray);
                    let warnings = getFlag(result, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);
                    response.id = id2;
                    if (pluginName != null) response.pluginName = pluginName;
                    if (contents instanceof Uint8Array) response.contents = contents;
                    else if (contents != null) response.contents = encodeUTF8(contents);
                    if (resolveDir != null) response.resolveDir = resolveDir;
                    if (pluginData != null) response.pluginData = details.store(pluginData);
                    if (loader != null) response.loader = loader;
                    if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                    if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                }
            } catch (e) {
                response = {
                    id: id2,
                    errors: [
                        extractErrorMessageV8(e, streamIn, details, note && note(), name)
                    ]
                };
                break;
            }
        }
        sendResponse(id, response);
    };
    let runOnEndCallbacks = (result, done)=>done([], []);
    if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, done)=>{
            (async ()=>{
                const onEndErrors = [];
                const onEndWarnings = [];
                for (const { name, callback, note } of onEndCallbacks){
                    let newErrors;
                    let newWarnings;
                    try {
                        const value = await callback(result);
                        if (value != null) {
                            if (typeof value !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                            let keys = {};
                            let errors = getFlag(value, keys, "errors", mustBeArray);
                            let warnings = getFlag(value, keys, "warnings", mustBeArray);
                            checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name)}`);
                            if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                            if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                        }
                    } catch (e) {
                        newErrors = [
                            extractErrorMessageV8(e, streamIn, details, note && note(), name)
                        ];
                    }
                    if (newErrors) {
                        onEndErrors.push(...newErrors);
                        try {
                            result.errors.push(...newErrors);
                        } catch  {}
                    }
                    if (newWarnings) {
                        onEndWarnings.push(...newWarnings);
                        try {
                            result.warnings.push(...newWarnings);
                        } catch  {}
                    }
                }
                done(onEndErrors, onEndWarnings);
            })();
        };
    }
    let scheduleOnDisposeCallbacks = ()=>{
        for (const cb of onDisposeCallbacks){
            setTimeout(()=>cb(), 0);
        }
    };
    isSetupDone = true;
    return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
    };
};
function createObjectStash() {
    const map = /* @__PURE__ */ new Map();
    let nextID = 0;
    return {
        clear () {
            map.clear();
        },
        load (id) {
            return map.get(id);
        },
        store (value) {
            if (value === void 0) return -1;
            const id = nextID++;
            map.set(id, value);
            return id;
        }
    };
}
function extractCallerV8(e, streamIn, ident) {
    let note;
    let tried = false;
    return ()=>{
        if (tried) return note;
        tried = true;
        try {
            let lines = (e.stack + "").split("\n");
            lines.splice(1, 1);
            let location = parseStackLinesV8(streamIn, lines, ident);
            if (location) {
                note = {
                    text: e.message,
                    location
                };
                return note;
            }
        } catch  {}
    };
}
function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
    let text = "Internal error";
    let location = null;
    try {
        text = (e && e.message || e) + "";
    } catch  {}
    try {
        location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
    } catch  {}
    return {
        id: "",
        pluginName,
        text,
        location,
        notes: note ? [
            note
        ] : [],
        detail: stash ? stash.store(e) : -1
    };
}
function parseStackLinesV8(streamIn, lines, ident) {
    let at = "    at ";
    if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
        for(let i = 1; i < lines.length; i++){
            let line = lines[i];
            if (!line.startsWith(at)) continue;
            line = line.slice(at.length);
            while(true){
                let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
                if (match) {
                    line = match[1];
                    continue;
                }
                match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
                if (match) {
                    line = match[1];
                    continue;
                }
                match = /^(\S+):(\d+):(\d+)$/.exec(line);
                if (match) {
                    let contents;
                    try {
                        contents = streamIn.readFileSync(match[1], "utf8");
                    } catch  {
                        break;
                    }
                    let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
                    let column = +match[3] - 1;
                    let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                    return {
                        file: match[1],
                        namespace: "file",
                        line: +match[2],
                        column: encodeUTF8(lineText.slice(0, column)).length,
                        length: encodeUTF8(lineText.slice(column, column + length)).length,
                        lineText: lineText + "\n" + lines.slice(1).join("\n"),
                        suggestion: ""
                    };
                }
                break;
            }
        }
    }
    return null;
}
function failureErrorWithLog(text, errors, warnings) {
    let limit = 5;
    text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i)=>{
        if (i === limit) return "\n...";
        if (!e.location) return `
error: ${e.text}`;
        let { file, line, column } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
    }).join("");
    let error = new Error(text);
    for (const [key, value] of [
        [
            "errors",
            errors
        ],
        [
            "warnings",
            warnings
        ]
    ]){
        Object.defineProperty(error, key, {
            configurable: true,
            enumerable: true,
            get: ()=>value,
            set: (value2)=>Object.defineProperty(error, key, {
                    configurable: true,
                    enumerable: true,
                    value: value2
                })
        });
    }
    return error;
}
function replaceDetailsInMessages(messages, stash) {
    for (const message of messages){
        message.detail = stash.load(message.detail);
    }
    return messages;
}
function sanitizeLocation(location, where, terminalWidth) {
    if (location == null) return null;
    let keys = {};
    let file = getFlag(location, keys, "file", mustBeString);
    let namespace = getFlag(location, keys, "namespace", mustBeString);
    let line = getFlag(location, keys, "line", mustBeInteger);
    let column = getFlag(location, keys, "column", mustBeInteger);
    let length = getFlag(location, keys, "length", mustBeInteger);
    let lineText = getFlag(location, keys, "lineText", mustBeString);
    let suggestion = getFlag(location, keys, "suggestion", mustBeString);
    checkForInvalidFlags(location, keys, where);
    if (lineText) {
        const relevantASCII = lineText.slice(0, (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80));
        if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
            lineText = relevantASCII;
        }
    }
    return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
    };
}
function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
    let messagesClone = [];
    let index = 0;
    for (const message of messages){
        let keys = {};
        let id = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
            for (const note of notes){
                let noteKeys = {};
                let noteText = getFlag(note, noteKeys, "text", mustBeString);
                let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
                checkForInvalidFlags(note, noteKeys, where);
                notesClone.push({
                    text: noteText || "",
                    location: sanitizeLocation(noteLocation, where, terminalWidth)
                });
            }
        }
        messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location, where, terminalWidth),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
        });
        index++;
    }
    return messagesClone;
}
function sanitizeStringArray(values, property) {
    const result = [];
    for (const value of values){
        if (typeof value !== "string") throw new Error(`${quote(property)} must be an array of strings`);
        result.push(value);
    }
    return result;
}
function sanitizeStringMap(map, property) {
    const result = /* @__PURE__ */ Object.create(null);
    for(const key in map){
        const value = map[key];
        if (typeof value !== "string") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
        result[key] = value;
    }
    return result;
}
function convertOutputFiles({ path: path3, contents, hash }) {
    let text = null;
    return {
        path: path3,
        contents,
        hash,
        get text () {
            const binary = this.contents;
            if (text === null || binary !== contents) {
                contents = binary;
                text = decodeUTF8(binary);
            }
            return text;
        }
    };
}
// lib/npm/node-platform.ts
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
var isValidBinaryPath = (x)=>!!x && x !== "/usr/bin/esbuild";
var packageDarwin_arm64 = "@esbuild/darwin-arm64";
var packageDarwin_x64 = "@esbuild/darwin-x64";
var knownWindowsPackages = {
    "win32 arm64 LE": "@esbuild/win32-arm64",
    "win32 ia32 LE": "@esbuild/win32-ia32",
    "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
    "aix ppc64 BE": "@esbuild/aix-ppc64",
    "android arm64 LE": "@esbuild/android-arm64",
    "darwin arm64 LE": "@esbuild/darwin-arm64",
    "darwin x64 LE": "@esbuild/darwin-x64",
    "freebsd arm64 LE": "@esbuild/freebsd-arm64",
    "freebsd x64 LE": "@esbuild/freebsd-x64",
    "linux arm LE": "@esbuild/linux-arm",
    "linux arm64 LE": "@esbuild/linux-arm64",
    "linux ia32 LE": "@esbuild/linux-ia32",
    "linux mips64el LE": "@esbuild/linux-mips64el",
    "linux ppc64 LE": "@esbuild/linux-ppc64",
    "linux riscv64 LE": "@esbuild/linux-riscv64",
    "linux s390x BE": "@esbuild/linux-s390x",
    "linux x64 LE": "@esbuild/linux-x64",
    "linux loong64 LE": "@esbuild/linux-loong64",
    "netbsd arm64 LE": "@esbuild/netbsd-arm64",
    "netbsd x64 LE": "@esbuild/netbsd-x64",
    "openbsd arm64 LE": "@esbuild/openbsd-arm64",
    "openbsd x64 LE": "@esbuild/openbsd-x64",
    "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
    "android arm LE": "@esbuild/android-arm",
    "android x64 LE": "@esbuild/android-x64"
};
function pkgAndSubpathForCurrentPlatform() {
    let pkg;
    let subpath;
    let isWASM = false;
    let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
    if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
    } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
    } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
    } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
    }
    return {
        pkg,
        subpath,
        isWASM
    };
}
function pkgForSomeOtherPlatform() {
    const libMainJS = "[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)";
    const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
    if (path.basename(nodeModulesDirectory) === "node_modules") {
        for(const unixKey in knownUnixlikePackages){
            try {
                const pkg = knownUnixlikePackages[unixKey];
                if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
            } catch  {}
        }
        for(const windowsKey in knownWindowsPackages){
            try {
                const pkg = knownWindowsPackages[windowsKey];
                if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
            } catch  {}
        }
    }
    return null;
}
function downloadedBinPath(pkg, subpath) {
    const esbuildLibDir = path.dirname("[project]/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js [app-route] (ecmascript)");
    return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
}
function generateBinPath() {
    if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
            console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
            return {
                binPath: ESBUILD_BINARY_PATH,
                isWASM: false
            };
        }
    }
    const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
    let binPath;
    try {
        binPath = __turbopack_context__.f({
            "@esbuild/win32-x64/README.md": {
                id: ()=>(()=>{
                        const e = new Error("Cannot find module 'unknown module type'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })(),
                module: ()=>(()=>{
                        const e = new Error("Cannot find module 'unknown module type'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })()
            },
            "@esbuild/win32-x64/esbuild.exe": {
                id: ()=>(()=>{
                        const e = new Error("Cannot find module 'unknown module type'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })(),
                module: ()=>(()=>{
                        const e = new Error("Cannot find module 'unknown module type'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })()
            },
            "@esbuild/win32-x64/package": {
                id: ()=>"[project]/node_modules/@remotion/bundler/node_modules/@esbuild/win32-x64/package.json (json)",
                module: ()=>__turbopack_context__.r("[project]/node_modules/@remotion/bundler/node_modules/@esbuild/win32-x64/package.json (json)")
            },
            "@esbuild/win32-x64/package.json": {
                id: ()=>"[project]/node_modules/@remotion/bundler/node_modules/@esbuild/win32-x64/package.json (json)",
                module: ()=>__turbopack_context__.r("[project]/node_modules/@remotion/bundler/node_modules/@esbuild/win32-x64/package.json (json)")
            }
        }).resolve(`${pkg}/${subpath}`);
    } catch (e1) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs.existsSync(binPath)) {
            try {
                (()=>{
                    const e = new Error("Cannot find module 'unknown'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch  {
                const otherPkg = pkgForSomeOtherPlatform();
                if (otherPkg) {
                    let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                    if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                        suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                    }
                    throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
                }
                throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
            }
            throw e1;
        }
    }
    if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
            pnpapi = __turbopack_context__.r("[externals]/pnpapi [external] (pnpapi, cjs)");
        } catch (e) {}
        if (pnpapi) {
            const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
            const binTargetPath = path.join(root, "node_modules", ".cache", "esbuild", `pnpapi-${pkg.replace("/", "-")}-${"0.25.0"}-${path.basename(subpath)}`);
            if (!fs.existsSync(binTargetPath)) {
                fs.mkdirSync(path.dirname(binTargetPath), {
                    recursive: true
                });
                fs.copyFileSync(binPath, binTargetPath);
                fs.chmodSync(binTargetPath, 493);
            }
            return {
                binPath: binTargetPath,
                isWASM
            };
        }
    }
    return {
        binPath,
        isWASM
    };
}
// lib/npm/node.ts
var child_process = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var path2 = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var fs2 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var os2 = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
var tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
var worker_threads;
if (process.env.ESBUILD_WORKER_THREADS !== "0") {
    try {
        worker_threads = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
    } catch  {}
    let [major, minor] = process.versions.node.split(".");
    if (// <v12.17.0 does not work
    +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
        worker_threads = void 0;
    }
}
var _a;
var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.25.0";
var esbuildCommandAndArgs = ()=>{
    if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(("TURBOPACK compile-time value", "/ROOT/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js")) !== "main.js" || path2.basename(("TURBOPACK compile-time value", "/ROOT/node_modules/@remotion/bundler/node_modules/esbuild/lib")) !== "lib")) {
        throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${("TURBOPACK compile-time value", "/ROOT/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js")}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`);
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
            return [
                "node",
                [
                    binPath
                ]
            ];
        } else {
            return [
                binPath,
                []
            ];
        }
    }
};
var isTTY = ()=>tty.isatty(2);
var fsSync = {
    readFile (tempFile, callback) {
        try {
            let contents = fs2.readFileSync(tempFile, "utf8");
            try {
                fs2.unlinkSync(tempFile);
            } catch  {}
            callback(null, contents);
        } catch (err) {
            callback(err, null);
        }
    },
    writeFile (contents, callback) {
        try {
            let tempFile = randomFileName();
            fs2.writeFileSync(tempFile, contents);
            callback(tempFile);
        } catch  {
            callback(null);
        }
    }
};
var fsAsync = {
    readFile (tempFile, callback) {
        try {
            fs2.readFile(tempFile, "utf8", (err, contents)=>{
                try {
                    fs2.unlink(tempFile, ()=>callback(err, contents));
                } catch  {
                    callback(err, contents);
                }
            });
        } catch (err) {
            callback(err, null);
        }
    },
    writeFile (contents, callback) {
        try {
            let tempFile = randomFileName();
            fs2.writeFile(tempFile, contents, (err)=>err !== null ? callback(null) : callback(tempFile));
        } catch  {
            callback(null);
        }
    }
};
var version = "0.25.0";
var build = (options)=>ensureServiceIsRunning().build(options);
var context = (buildOptions)=>ensureServiceIsRunning().context(buildOptions);
var transform = (input, options)=>ensureServiceIsRunning().transform(input, options);
var formatMessages = (messages, options)=>ensureServiceIsRunning().formatMessages(messages, options);
var analyzeMetafile = (messages, options)=>ensureServiceIsRunning().analyzeMetafile(messages, options);
var buildSync = (options)=>{
    if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options);
    }
    let result;
    runServiceSync((service)=>service.buildOrContext({
            callName: "buildSync",
            refs: null,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res)=>{
                if (err) throw err;
                result = res;
            }
        }));
    return result;
};
var transformSync = (input, options)=>{
    if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options);
    }
    let result;
    runServiceSync((service)=>service.transform({
            callName: "transformSync",
            refs: null,
            input,
            options: options || {},
            isTTY: isTTY(),
            fs: fsSync,
            callback: (err, res)=>{
                if (err) throw err;
                result = res;
            }
        }));
    return result;
};
var formatMessagesSync = (messages, options)=>{
    if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options);
    }
    let result;
    runServiceSync((service)=>service.formatMessages({
            callName: "formatMessagesSync",
            refs: null,
            messages,
            options,
            callback: (err, res)=>{
                if (err) throw err;
                result = res;
            }
        }));
    return result;
};
var analyzeMetafileSync = (metafile, options)=>{
    if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options);
    }
    let result;
    runServiceSync((service)=>service.analyzeMetafile({
            callName: "analyzeMetafileSync",
            refs: null,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options,
            callback: (err, res)=>{
                if (err) throw err;
                result = res;
            }
        }));
    return result;
};
var stop = ()=>{
    if (stopService) stopService();
    if (workerThreadService) workerThreadService.stop();
    return Promise.resolve();
};
var initializeWasCalled = false;
var initialize = (options)=>{
    options = validateInitializeOptions(options || {});
    if (options.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
    if (options.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
    if (options.worker) throw new Error(`The "worker" option only works in the browser`);
    if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
    ensureServiceIsRunning();
    initializeWasCalled = true;
    return Promise.resolve();
};
var defaultWD = process.cwd();
var longLivedService;
var stopService;
var ensureServiceIsRunning = ()=>{
    if (longLivedService) return longLivedService;
    let [command, args] = esbuildCommandAndArgs();
    let child = child_process.spawn(command, args.concat(`--service=${"0.25.0"}`, "--ping"), {
        windowsHide: true,
        stdio: [
            "pipe",
            "pipe",
            "inherit"
        ],
        cwd: defaultWD
    });
    let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin (bytes) {
            child.stdin.write(bytes, (err)=>{
                if (err) afterClose(err);
            });
        },
        readFileSync: fs2.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports
    });
    child.stdin.on("error", afterClose);
    child.on("error", afterClose);
    const stdin = child.stdin;
    const stdout = child.stdout;
    stdout.on("data", readFromStdout);
    stdout.on("end", afterClose);
    stopService = ()=>{
        stdin.destroy();
        stdout.destroy();
        child.kill();
        initializeWasCalled = false;
        longLivedService = void 0;
        stopService = void 0;
    };
    let refCount = 0;
    child.unref();
    if (stdin.unref) {
        stdin.unref();
    }
    if (stdout.unref) {
        stdout.unref();
    }
    const refs = {
        ref () {
            if (++refCount === 1) child.ref();
        },
        unref () {
            if (--refCount === 0) child.unref();
        }
    };
    longLivedService = {
        build: (options)=>new Promise((resolve, reject)=>{
                service.buildOrContext({
                    callName: "build",
                    refs,
                    options,
                    isTTY: isTTY(),
                    defaultWD,
                    callback: (err, res)=>err ? reject(err) : resolve(res)
                });
            }),
        context: (options)=>new Promise((resolve, reject)=>service.buildOrContext({
                    callName: "context",
                    refs,
                    options,
                    isTTY: isTTY(),
                    defaultWD,
                    callback: (err, res)=>err ? reject(err) : resolve(res)
                })),
        transform: (input, options)=>new Promise((resolve, reject)=>service.transform({
                    callName: "transform",
                    refs,
                    input,
                    options: options || {},
                    isTTY: isTTY(),
                    fs: fsAsync,
                    callback: (err, res)=>err ? reject(err) : resolve(res)
                })),
        formatMessages: (messages, options)=>new Promise((resolve, reject)=>service.formatMessages({
                    callName: "formatMessages",
                    refs,
                    messages,
                    options,
                    callback: (err, res)=>err ? reject(err) : resolve(res)
                })),
        analyzeMetafile: (metafile, options)=>new Promise((resolve, reject)=>service.analyzeMetafile({
                    callName: "analyzeMetafile",
                    refs,
                    metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
                    options,
                    callback: (err, res)=>err ? reject(err) : resolve(res)
                }))
    };
    return longLivedService;
};
var runServiceSync = (callback)=>{
    let [command, args] = esbuildCommandAndArgs();
    let stdin = new Uint8Array();
    let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin (bytes) {
            if (stdin.length !== 0) throw new Error("Must run at most one command");
            stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports
    });
    callback(service);
    let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.25.0"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
    });
    readFromStdout(stdout);
    afterClose(null);
};
var randomFileName = ()=>{
    return path2.join(os2.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
};
var workerThreadService = null;
var startWorkerThreadService = (worker_threads2)=>{
    let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
    let worker = new worker_threads2.Worker(("TURBOPACK compile-time value", "/ROOT/node_modules/@remotion/bundler/node_modules/esbuild/lib/main.js"), {
        workerData: {
            workerPort,
            defaultWD,
            esbuildVersion: "0.25.0"
        },
        transferList: [
            workerPort
        ],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
    });
    let nextID = 0;
    let fakeBuildError = (text)=>{
        let error = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [
            {
                id: "",
                pluginName: "",
                text,
                location: null,
                notes: [],
                detail: void 0
            }
        ];
        error.errors = errors;
        error.warnings = [];
        return error;
    };
    let validateBuildSyncOptions = (options)=>{
        if (!options) return;
        let plugins = options.plugins;
        if (plugins && plugins.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
    };
    let applyProperties = (object, properties)=>{
        for(let key in properties){
            object[key] = properties[key];
        }
    };
    let runCallSync = (command, args)=>{
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = {
            sharedBuffer,
            id,
            command,
            args
        };
        worker.postMessage(msg);
        let status = Atomics.wait(sharedBufferView, 0, 0);
        if (status !== "ok" && status !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status);
        let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2) throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
            applyProperties(reject, properties);
            throw reject;
        }
        return resolve;
    };
    worker.unref();
    return {
        buildSync (options) {
            validateBuildSyncOptions(options);
            return runCallSync("build", [
                options
            ]);
        },
        transformSync (input, options) {
            return runCallSync("transform", [
                input,
                options
            ]);
        },
        formatMessagesSync (messages, options) {
            return runCallSync("formatMessages", [
                messages,
                options
            ]);
        },
        analyzeMetafileSync (metafile, options) {
            return runCallSync("analyzeMetafile", [
                metafile,
                options
            ]);
        },
        stop () {
            worker.terminate();
            workerThreadService = null;
        }
    };
};
var startSyncServiceWorker = ()=>{
    let workerPort = worker_threads.workerData.workerPort;
    let parentPort = worker_threads.parentPort;
    let extractProperties = (object)=>{
        let properties = {};
        if (object && typeof object === "object") {
            for(let key in object){
                properties[key] = object[key];
            }
        }
        return properties;
    };
    try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg)=>{
            (async ()=>{
                let { sharedBuffer, id, command, args } = msg;
                let sharedBufferView = new Int32Array(sharedBuffer);
                try {
                    switch(command){
                        case "build":
                            workerPort.postMessage({
                                id,
                                resolve: await service.build(args[0])
                            });
                            break;
                        case "transform":
                            workerPort.postMessage({
                                id,
                                resolve: await service.transform(args[0], args[1])
                            });
                            break;
                        case "formatMessages":
                            workerPort.postMessage({
                                id,
                                resolve: await service.formatMessages(args[0], args[1])
                            });
                            break;
                        case "analyzeMetafile":
                            workerPort.postMessage({
                                id,
                                resolve: await service.analyzeMetafile(args[0], args[1])
                            });
                            break;
                        default:
                            throw new Error(`Invalid command: ${command}`);
                    }
                } catch (reject) {
                    workerPort.postMessage({
                        id,
                        reject,
                        properties: extractProperties(reject)
                    });
                }
                Atomics.add(sharedBufferView, 0, 1);
                Atomics.notify(sharedBufferView, 0, Infinity);
            })();
        });
    } catch (reject) {
        parentPort.on("message", (msg)=>{
            let { sharedBuffer, id } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            workerPort.postMessage({
                id,
                reject,
                properties: extractProperties(reject)
            });
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
        });
    }
};
if (isInternalWorkerThread) {
    startSyncServiceWorker();
}
var node_default = node_exports;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    analyzeMetafile,
    analyzeMetafileSync,
    build,
    buildSync,
    context,
    formatMessages,
    formatMessagesSync,
    initialize,
    stop,
    transform,
    transformSync,
    version
});
}),
"[project]/node_modules/@remotion/player/dist/esm/index.mjs [app-route] (client reference proxy) <module evaluation>", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "Player",
    ()=>Player,
    "PlayerInternals",
    ()=>PlayerInternals,
    "Thumbnail",
    ()=>Thumbnail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-route] (ecmascript)");
;
const Player = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call Player() from the server but Player is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs <module evaluation>", "Player");
const PlayerInternals = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call PlayerInternals() from the server but PlayerInternals is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs <module evaluation>", "PlayerInternals");
const Thumbnail = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call Thumbnail() from the server but Thumbnail is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs <module evaluation>", "Thumbnail");
}),
"[project]/node_modules/@remotion/player/dist/esm/index.mjs [app-route] (client reference proxy)", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "Player",
    ()=>Player,
    "PlayerInternals",
    ()=>PlayerInternals,
    "Thumbnail",
    ()=>Thumbnail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-route] (ecmascript)");
;
const Player = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call Player() from the server but Player is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs", "Player");
const PlayerInternals = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call PlayerInternals() from the server but PlayerInternals is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs", "PlayerInternals");
const Thumbnail = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call Thumbnail() from the server but Thumbnail is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/node_modules/@remotion/player/dist/esm/index.mjs", "Thumbnail");
}),
"[project]/node_modules/@remotion/player/dist/esm/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$player$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@remotion/player/dist/esm/index.mjs [app-route] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$player$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/player/dist/esm/index.mjs [app-route] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$player$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/@remotion/media-utils/dist/audio-buffer/audio-buffer-to-wav.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Inlined from https://github.com/Jam3/audiobuffer-to-wav/commit/2272eb09bd46a05e50a6d684d908aa6f13c58f63#diff-e727e4bdf3657fd1d798edcd6b099d6e092f8573cba266154583a746bba0f346
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.audioBufferToWav = audioBufferToWav;
function interleave(inputL, inputR) {
    const length = inputL.length + inputR.length;
    const result = new Float32Array(length);
    let index = 0;
    let inputIndex = 0;
    while(index < length){
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for(let i = 0; i < input.length; i++, offset += 4){
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for(let i = 0; i < input.length; i++, offset += 2){
        const s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for(let i = 0; i < string.length; i++){
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}
function encodeWAV({ samples, format, sampleRate, numChannels, bitDepth }) {
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    const view = new DataView(buffer);
    /* RIFF identifier */ writeString(view, 0, 'RIFF');
    /* RIFF chunk length */ view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */ writeString(view, 8, 'WAVE');
    /* format chunk identifier */ writeString(view, 12, 'fmt ');
    /* format chunk length */ view.setUint32(16, 16, true);
    /* sample format (raw) */ view.setUint16(20, format, true);
    /* channel count */ view.setUint16(22, numChannels, true);
    /* sample rate */ view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */ view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */ view.setUint16(32, blockAlign, true);
    /* bits per sample */ view.setUint16(34, bitDepth, true);
    /* data chunk identifier */ writeString(view, 36, 'data');
    /* data chunk length */ view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    } else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
function audioBufferToWav(buffer, opt) {
    const numChannels = buffer.numberOfChannels;
    const { sampleRate } = buffer;
    const format = opt.float32 ? 3 : 1;
    const bitDepth = format === 3 ? 32 : 16;
    let result;
    if (numChannels === 2) {
        result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
    } else {
        result = buffer.getChannelData(0);
    }
    return encodeWAV({
        samples: result,
        format,
        sampleRate,
        numChannels,
        bitDepth
    });
}
}),
"[project]/node_modules/@remotion/media-utils/dist/audio-buffer/audio-url-helpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.audioBufferToDataUrl = void 0;
const audio_buffer_to_wav_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/audio-buffer/audio-buffer-to-wav.js [app-route] (ecmascript)");
/*
 * @description Takes an AudioBuffer instance and converts it to a Base 64 Data URL so it can be passed to an <Html5Audio /> tag.
 * @see [Documentation](https://remotion.dev/docs/audio-buffer-to-data-url)
 */ const audioBufferToDataUrl = (buffer)=>{
    const wavAsArrayBuffer = (0, audio_buffer_to_wav_1.audioBufferToWav)(buffer, {
        float32: true
    });
    let binary = '';
    const bytes = new Uint8Array(wavAsArrayBuffer);
    const len = bytes.byteLength;
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return 'data:audio/wav;base64,' + window.btoa(binary);
};
exports.audioBufferToDataUrl = audioBufferToDataUrl;
}),
"[project]/node_modules/@remotion/media-utils/dist/create-smooth-svg-path.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSmoothSvgPath = void 0;
const line = (pointA, pointB)=>{
    const lengthX = pointB.x - pointA.x;
    const lengthY = pointB.y - pointA.y;
    return {
        length: Math.sqrt(lengthX ** 2 + lengthY ** 2),
        angle: Math.atan2(lengthY, lengthX)
    };
};
const controlPoint = ({ current, previous, next, reverse })=>{
    const p = previous || current;
    const n = next || current;
    // The smoothing ratio
    const smoothing = 0.2;
    // Properties of the opposed-line
    const o = line(p, n);
    const angle = o.angle + (reverse ? Math.PI : 0);
    const length = o.length * smoothing;
    const x = current.x + Math.cos(angle) * length;
    const y = current.y + Math.sin(angle) * length;
    return {
        x,
        y
    };
};
const createSmoothSvgPath = ({ points })=>{
    return points.reduce((acc, current, i, a)=>{
        if (i === 0) {
            return `M ${current.x},${current.y}`;
        }
        const { x, y } = current;
        const previous = a[i - 1];
        const twoPrevious = a[i - 2];
        const next = a[i + 1];
        const { x: cp1x, y: cp1y } = controlPoint({
            current: previous,
            previous: twoPrevious,
            next: current,
            reverse: false
        });
        const { x: cp2x, y: cp2y } = controlPoint({
            current,
            previous,
            next,
            reverse: true
        });
        return `${acc} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${x},${y}`;
    }, '');
};
exports.createSmoothSvgPath = createSmoothSvgPath;
}),
"[project]/node_modules/@remotion/media-utils/dist/fetch-with-cors-catch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchWithCorsCatch = void 0;
const fetchWithCorsCatch = async (src, init)=>{
    try {
        const response = await fetch(src, {
            mode: 'cors',
            referrerPolicy: 'no-referrer-when-downgrade',
            ...init
        });
        return response;
    } catch (err) {
        const error = err;
        if (// Chrome
        error.message.includes('Failed to fetch') || // Safari
        error.message.includes('Load failed') || // Firefox
        error.message.includes('NetworkError when attempting to fetch resource')) {
            throw new TypeError(`Failed to read from ${src}: ${error.message}. Does the resource support CORS?`);
        }
        throw err;
    }
};
exports.fetchWithCorsCatch = fetchWithCorsCatch;
}),
"[project]/node_modules/@remotion/media-utils/dist/is-remote-asset.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isRemoteAsset = void 0;
const isRemoteAsset = (asset)=>!asset.startsWith(window.origin) && !asset.startsWith('data');
exports.isRemoteAsset = isRemoteAsset;
}),
"[project]/node_modules/@remotion/media-utils/dist/p-limit.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pLimit = void 0;
const pLimit = (concurrency)=>{
    const queue = [];
    let activeCount = 0;
    const next = ()=>{
        var _a;
        activeCount--;
        if (queue.length > 0) {
            (_a = queue.shift()) === null || _a === void 0 ? void 0 : _a();
        }
    };
    const run = async (fn, resolve, ...args)=>{
        activeCount++;
        // eslint-disable-next-line require-await
        const result = (async ()=>fn(...args))();
        resolve(result);
        try {
            await result;
        } catch (_a) {}
        next();
    };
    const enqueue = (fn, resolve, ...args)=>{
        queue.push(()=>run(fn, resolve, ...args));
        (async ()=>{
            var _a;
            // This function needs to wait until the next microtask before comparing
            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
            // when the run function is dequeued and called. The comparison in the if-statement
            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
            await Promise.resolve();
            if (activeCount < concurrency && queue.length > 0) {
                (_a = queue.shift()) === null || _a === void 0 ? void 0 : _a();
            }
        })();
    };
    const generator = (fn, ...args)=>new Promise((resolve)=>{
            enqueue(fn, resolve, ...args);
        });
    Object.defineProperties(generator, {
        activeCount: {
            get: ()=>activeCount
        },
        pendingCount: {
            get: ()=>queue.length
        },
        clearQueue: {
            value: ()=>{
                queue.length = 0;
            }
        }
    });
    return generator;
};
exports.pLimit = pLimit;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-audio-data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAudioData = void 0;
const fetch_with_cors_catch_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fetch-with-cors-catch.js [app-route] (ecmascript)");
const is_remote_asset_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/is-remote-asset.js [app-route] (ecmascript)");
const p_limit_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/p-limit.js [app-route] (ecmascript)");
const metadataCache = {};
const limit = (0, p_limit_1.pLimit)(3);
const fn = async (src, options)=>{
    var _a;
    if (metadataCache[src]) {
        return metadataCache[src];
    }
    if (typeof document === 'undefined') {
        throw new Error('getAudioData() is only available in the browser.');
    }
    const audioContext = new AudioContext({
        sampleRate: (_a = options === null || options === void 0 ? void 0 : options.sampleRate) !== null && _a !== void 0 ? _a : 48000
    });
    const response = await (0, fetch_with_cors_catch_1.fetchWithCorsCatch)(src);
    if (!response.ok) {
        throw new Error(`Failed to fetch audio data from ${src}: ${response.status} ${response.statusText}`);
    }
    const arrayBuffer = await response.arrayBuffer();
    const wave = await audioContext.decodeAudioData(arrayBuffer);
    const channelWaveforms = new Array(wave.numberOfChannels).fill(true).map((_, channel)=>{
        return wave.getChannelData(channel);
    });
    const metadata = {
        channelWaveforms,
        sampleRate: wave.sampleRate,
        durationInSeconds: wave.duration,
        numberOfChannels: wave.numberOfChannels,
        resultId: String(Math.random()),
        isRemote: (0, is_remote_asset_1.isRemoteAsset)(src)
    };
    metadataCache[src] = metadata;
    return metadata;
};
/*
 * @description Takes an audio or video src, loads it and returns data and metadata for the specified source.
 * @see [Documentation](https://remotion.dev/docs/get-audio-data)
 */ const getAudioData = (src, options)=>{
    return limit(fn, src, options);
};
exports.getAudioData = getAudioData;
}),
"[project]/node_modules/@remotion/media-utils/dist/media-tag-error-handling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onMediaError = void 0;
async function fetchWithTimeout(url, options, timeout = 3000) {
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(), timeout);
    options.signal = controller.signal;
    try {
        const response = await fetch(url, options);
        clearTimeout(id);
        return response;
    } catch (_a) {
        clearTimeout(id);
        throw new Error(`Fetch timed out after ${timeout}ms`);
    }
}
const checkFor404 = (src)=>{
    return fetchWithTimeout(src, {
        method: 'HEAD',
        mode: 'no-cors'
    }).then((res)=>res.status);
};
const checkFor404OrSkip = async ({ suspecting404, sameOrigin, src })=>{
    if (!suspecting404) {
        return Promise.resolve(null);
    }
    if (!sameOrigin) {
        return Promise.resolve(null);
    }
    try {
        return await checkFor404(src);
    } catch (_a) {
        return Promise.resolve(null);
    }
};
const onMediaError = ({ error, src, reject, cleanup, api })=>{
    const suspecting404 = error.MEDIA_ERR_SRC_NOT_SUPPORTED === error.code;
    const isSrcSameOriginAsCurrent = new URL(src, window.location.origin).toString().startsWith(window.location.origin);
    checkFor404OrSkip({
        suspecting404,
        sameOrigin: isSrcSameOriginAsCurrent,
        src
    }).then((status)=>{
        const err = status === 404 ? new Error([
            `Failed to execute ${api}: Received a 404 error loading "${src}".`,
            'Correct the URL of the file.'
        ].join(' ')) : new Error([
            `Failed to execute ${api}, Received a MediaError loading "${src}". Consider using parseMedia() instead which supports more codecs: https://www.remotion.dev/docs/miscellaneous/parse-media-vs-get-video-metadata`,
            status === null ? null : `HTTP Status code of the file: ${status}.`,
            error.message ? `Browser error message: ${error.message}` : null,
            'Check the path of the file and if it is a valid video.'
        ].filter(Boolean).join(' '));
        reject(err);
        cleanup();
    }).catch((e)=>{
        reject(e);
        cleanup();
    });
};
exports.onMediaError = onMediaError;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-audio-duration-in-seconds.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAudioDuration = exports.getAudioDurationInSeconds = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */ const media_tag_error_handling_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/media-tag-error-handling.js [app-route] (ecmascript)");
const p_limit_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/p-limit.js [app-route] (ecmascript)");
const limit = (0, p_limit_1.pLimit)(3);
const metadataCache = {};
const fn = (src)=>{
    if (metadataCache[src]) {
        return Promise.resolve(metadataCache[src]);
    }
    if (typeof document === 'undefined') {
        throw new Error('getAudioDuration() is only available in the browser.');
    }
    const audio = document.createElement('audio');
    audio.src = src;
    return new Promise((resolve, reject)=>{
        const onError = ()=>{
            (0, media_tag_error_handling_1.onMediaError)({
                error: audio.error,
                src,
                cleanup,
                reject,
                api: 'getAudioDurationInSeconds()'
            });
        };
        const onLoadedMetadata = ()=>{
            metadataCache[src] = audio.duration;
            resolve(audio.duration);
            cleanup();
        };
        const cleanup = ()=>{
            audio.removeEventListener('loadedmetadata', onLoadedMetadata);
            audio.removeEventListener('error', onError);
            audio.remove();
        };
        audio.addEventListener('loadedmetadata', onLoadedMetadata, {
            once: true
        });
        audio.addEventListener('error', onError, {
            once: true
        });
    });
};
/**
 * @description Gets the duration in seconds of an audio source by creating an invisible `<audio>` tag, loading the audio, and returning the duration.
 * @see [Documentation](https://remotion.dev/docs/get-audio-duration-in-seconds)
 * @deprecated Use `parseMedia()` instead: https://www.remotion.dev/docs/media-parser/parse-media
 */ const getAudioDurationInSeconds = (src)=>{
    return limit(fn, src);
};
exports.getAudioDurationInSeconds = getAudioDurationInSeconds;
/**
 * @deprecated Renamed to `getAudioDurationInSeconds`
 */ const getAudioDuration = (src)=>(0, exports.getAudioDurationInSeconds)(src);
exports.getAudioDuration = getAudioDuration;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-image-dimensions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getImageDimensions = getImageDimensions;
const p_limit_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/p-limit.js [app-route] (ecmascript)");
const imageDimensionsCache = {};
const limit = (0, p_limit_1.pLimit)(3);
const fn = async (src)=>{
    if (imageDimensionsCache[src]) {
        return imageDimensionsCache[src];
    }
    if (typeof document === 'undefined') {
        throw new Error('getImageDimensions() is only available in the browser.');
    }
    const imageDimensions = await new Promise((resolved, reject)=>{
        const image = new Image();
        image.onload = ()=>{
            const { width, height } = image;
            resolved({
                width,
                height
            });
        };
        image.onerror = reject;
        image.src = src;
    });
    imageDimensionsCache[src] = imageDimensions;
    return imageDimensions;
};
/*
 * @description Takes an image src, retrieves the dimensions of an image.
 * @see [Documentation](https://remotion.dev/docs/get-image-dimensions)
 */ function getImageDimensions(src) {
    return limit(fn, src);
}
}),
"[project]/node_modules/@remotion/media-utils/dist/get-video-metadata.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getVideoMetadata = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */ const is_remote_asset_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/is-remote-asset.js [app-route] (ecmascript)");
const media_tag_error_handling_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/media-tag-error-handling.js [app-route] (ecmascript)");
const p_limit_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/p-limit.js [app-route] (ecmascript)");
const cache = {};
const limit = (0, p_limit_1.pLimit)(3);
const fn = (src)=>{
    if (cache[src]) {
        return Promise.resolve(cache[src]);
    }
    if (typeof document === 'undefined') {
        throw new Error('getVideoMetadata() is only available in the browser.');
    }
    const video = document.createElement('video');
    video.src = src;
    return new Promise((resolve, reject)=>{
        const onError = ()=>{
            (0, media_tag_error_handling_1.onMediaError)({
                error: video.error,
                src,
                cleanup,
                reject,
                api: 'getVideoMetadata()'
            });
        };
        const onLoadedMetadata = ()=>{
            const pixels = video.videoHeight * video.videoWidth;
            if (pixels === 0) {
                reject(new Error(`Unable to determine video metadata for ${src}`));
                return;
            }
            if (!Number.isFinite(video.duration)) {
                reject(new Error(`Unable to determine video duration for ${src} - got Infinity. Re-encoding this video may fix this issue.`));
                return;
            }
            const metadata = {
                durationInSeconds: video.duration,
                width: video.videoWidth,
                height: video.videoHeight,
                aspectRatio: video.videoWidth / video.videoHeight,
                isRemote: (0, is_remote_asset_1.isRemoteAsset)(src)
            };
            resolve(metadata);
            cache[src] = metadata;
            cleanup();
        };
        const cleanup = ()=>{
            video.removeEventListener('loadedmetadata', onLoadedMetadata);
            video.removeEventListener('error', onError);
            video.remove();
        };
        video.addEventListener('loadedmetadata', onLoadedMetadata, {
            once: true
        });
        video.addEventListener('error', onError, {
            once: true
        });
    });
};
/**
 * @description Takes a src to a video, loads it and returns metadata for the specified source.
 * @see [Documentation](https://remotion.dev/docs/get-video-metadata)
 * @deprecated Use `parseMedia()` instead: https://www.remotion.dev/docs/miscellaneous/parse-media-vs-get-video-metadata
 */ const getVideoMetadata = (src)=>{
    return limit(fn, src);
};
exports.getVideoMetadata = getVideoMetadata;
}),
"[project]/node_modules/@remotion/media-utils/dist/normalize-data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeData = void 0;
const normalizeData = (filteredData)=>{
    const max = Math.max(...filteredData);
    const multiplier = max === 0 ? 0 : max ** -1;
    return filteredData.map((n)=>n * multiplier);
};
exports.normalizeData = normalizeData;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-wave-form-samples.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getWaveformSamples = void 0;
const normalize_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/normalize-data.js [app-route] (ecmascript)");
const getWaveformSamples = ({ audioBuffer, numberOfSamples, outputRange, normalize })=>{
    const blockSize = Math.floor(audioBuffer.length / numberOfSamples); // the number of samples in each subdivision
    if (blockSize === 0) {
        return [];
    }
    const filteredData = [];
    for(let i = 0; i < numberOfSamples; i++){
        const blockStart = blockSize * i; // the location of the first sample in the block
        let sum = 0;
        for(let j = 0; j < blockSize; j++){
            sum += Math.abs(audioBuffer[blockStart + j]); // find the sum of all the samples in the block
        }
        filteredData.push(sum / blockSize); // divide the sum by the block size to get the average
    }
    if (normalize) {
        if (outputRange === 'minus-one-to-one') {
            return (0, normalize_data_1.normalizeData)(filteredData).map((n, i)=>{
                if (i % 2 === 0) {
                    return n * -1;
                }
                return n;
            });
        }
        return (0, normalize_data_1.normalizeData)(filteredData);
    }
    if (outputRange === 'minus-one-to-one') {
        return filteredData.map((n, i)=>{
            if (i % 2 === 0) {
                return n * -1;
            }
            return n;
        });
    }
    return filteredData;
};
exports.getWaveformSamples = getWaveformSamples;
}),
"[project]/node_modules/@remotion/media-utils/dist/validate-channel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateChannel = void 0;
const validateChannel = (channel, numberOfChannels)=>{
    if (typeof channel !== 'number') {
        throw new TypeError(`"channel" must be a number`);
    }
    if (channel % 1 !== 0) {
        throw new TypeError(`"channel" must an integer, got ${channel}`);
    }
    if (Number.isNaN(channel)) {
        throw new TypeError(`The channel parameter is NaN.`);
    }
    if (channel < 0) {
        throw new TypeError('"channel" cannot be negative');
    }
    if (channel > numberOfChannels - 1) {
        throw new TypeError(`"channel" must be ${numberOfChannels - 1} or lower. The audio has ${numberOfChannels} channels`);
    }
};
exports.validateChannel = validateChannel;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-waveform-portion.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getWaveformPortion = void 0;
const no_react_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
const get_wave_form_samples_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-wave-form-samples.js [app-route] (ecmascript)");
const validate_channel_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/validate-channel.js [app-route] (ecmascript)");
const concatArrays = (arrays)=>{
    // sum of individual array lengths
    const totalLength = arrays.reduce((acc, value)=>acc + value.length, 0);
    const result = new Float32Array(totalLength);
    // for each array - copy it over result
    // next array is copied right after the previous one
    let length = 0;
    for (const array of arrays){
        result.set(array, length);
        length += array.length;
    }
    return result;
};
/*
 * @description Takes bulky waveform data (for example fetched by getAudioData()) and returns a trimmed and simplified version of it, for simpler visualization
 * @see [Documentation](https://remotion.dev/docs/get-waveform-portion)
 */ const getWaveformPortion = ({ audioData, startTimeInSeconds, durationInSeconds, numberOfSamples, channel = 0, outputRange = 'zero-to-one', dataOffsetInSeconds, normalize = true })=>{
    (0, validate_channel_1.validateChannel)(channel, audioData.numberOfChannels);
    const waveform = audioData.channelWaveforms[channel];
    const startSample = Math.floor((startTimeInSeconds - (dataOffsetInSeconds !== null && dataOffsetInSeconds !== void 0 ? dataOffsetInSeconds : 0)) * audioData.sampleRate);
    const endSample = Math.floor((startTimeInSeconds - (dataOffsetInSeconds !== null && dataOffsetInSeconds !== void 0 ? dataOffsetInSeconds : 0) + durationInSeconds) * audioData.sampleRate);
    const samplesBeforeStart = 0 - startSample;
    const samplesAfterEnd = endSample - waveform.length;
    const clampedStart = Math.max(startSample, 0);
    const clampedEnd = Math.min(waveform.length, endSample);
    const padStart = samplesBeforeStart > 0 ? new Float32Array(samplesBeforeStart).fill(0) : null;
    const padEnd = samplesAfterEnd > 0 ? new Float32Array(samplesAfterEnd).fill(0) : null;
    const arrs = [
        padStart,
        waveform.slice(clampedStart, clampedEnd),
        padEnd
    ].filter(no_react_1.NoReactInternals.truthy);
    const audioBuffer = arrs.length === 1 ? arrs[0] : concatArrays(arrs);
    return (0, get_wave_form_samples_1.getWaveformSamples)({
        audioBuffer,
        numberOfSamples,
        outputRange,
        normalize
    }).map((w, i)=>{
        return {
            index: i,
            amplitude: w
        };
    });
};
exports.getWaveformPortion = getWaveformPortion;
}),
"[project]/node_modules/@remotion/media-utils/dist/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@remotion/media-utils/dist/use-audio-data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useAudioData = void 0;
const react_1 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
const remotion_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
const get_audio_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-audio-data.js [app-route] (ecmascript)");
/*
 * @description Wraps the getAudioData() function into a hook and does three things: keeps the audio data in a state, wraps the function in a delayRender() / continueRender() pattern, and handles the case where the component gets unmounted while fetching is in progress to prevent React errors.
 * @see [Documentation](https://www.remotion.dev/docs/use-audio-data)
 */ const useAudioData = (src)=>{
    if (!src) {
        throw new TypeError("useAudioData requires a 'src' parameter");
    }
    const mountState = (0, react_1.useRef)({
        isMounted: true
    });
    (0, react_1.useEffect)(()=>{
        const { current } = mountState;
        current.isMounted = true;
        return ()=>{
            current.isMounted = false;
        };
    }, []);
    const [metadata, setMetadata] = (0, react_1.useState)(null);
    const { delayRender, continueRender } = (0, remotion_1.useDelayRender)();
    const fetchMetadata = (0, react_1.useCallback)(async ()=>{
        const handle = delayRender(`Waiting for audio metadata with src="${src}" to be loaded`);
        try {
            const data = await (0, get_audio_data_1.getAudioData)(src);
            if (mountState.current.isMounted) {
                setMetadata(data);
            }
        } catch (err) {
            (0, remotion_1.cancelRender)(err);
        }
        continueRender(handle);
    }, [
        src,
        delayRender,
        continueRender
    ]);
    (0, react_1.useLayoutEffect)(()=>{
        fetchMetadata();
    }, [
        fetchMetadata
    ]);
    return metadata;
};
exports.useAudioData = useAudioData;
}),
"[project]/node_modules/@remotion/media-utils/dist/combine-float32-arrays.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.combineFloat32Arrays = void 0;
const combineFloat32Arrays = (arrays)=>{
    if (arrays.length === 0) {
        return new Float32Array([]);
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    for (const array of arrays){
        totalLength += array.length;
    }
    const result = new Float32Array(totalLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
};
exports.combineFloat32Arrays = combineFloat32Arrays;
}),
"[project]/node_modules/@remotion/media-utils/dist/get-partial-audio-data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getPartialAudioData = void 0;
const mediabunny_1 = __turbopack_context__.r("[project]/node_modules/mediabunny/dist/bundles/mediabunny.cjs [app-route] (ecmascript)");
// Audio frames might have dependencies on previous and next frames so we need to decode a bit more and then discard it.
// The worst case seems to be FLAC files with a 65'535 sample window, which would be 1486.0ms at 44.1Khz.
// So let's set a threshold of 1.5 seconds.
const EXTRA_THRESHOLD_IN_SECONDS = 1.5;
const getPartialAudioData = async ({ track, fromSeconds, toSeconds, channelIndex, signal, isMatroska = false })=>{
    if (signal.aborted) {
        throw new Error('Operation was aborted');
    }
    const audioSamples = [];
    // matroska must be decoded from the start due to limitation
    // https://www.remotion.dev/docs/media/support#matroska-limitation
    // Also request extra data beforehand to handle audio frame dependencies
    const actualFromSeconds = isMatroska ? 0 : Math.max(0, fromSeconds - EXTRA_THRESHOLD_IN_SECONDS);
    // mediabunny docs: constructing the sink is virtually free and does not perform any media data reads.
    const sink = new mediabunny_1.AudioBufferSink(track);
    for await (const { buffer, timestamp, duration } of sink.buffers(actualFromSeconds, toSeconds)){
        if (signal.aborted) {
            break;
        }
        const channelData = buffer.getChannelData(channelIndex);
        const bufferStartSeconds = timestamp;
        const bufferEndSeconds = timestamp + duration;
        const overlapStartSecond = Math.max(bufferStartSeconds, fromSeconds);
        const overlapEndSecond = Math.min(bufferEndSeconds, toSeconds);
        if (overlapStartSecond >= overlapEndSecond) {
            continue;
        }
        const startSampleInBuffer = Math.floor((overlapStartSecond - bufferStartSeconds) * buffer.sampleRate);
        const endSampleInBuffer = Math.ceil((overlapEndSecond - bufferStartSeconds) * buffer.sampleRate);
        const trimmedData = channelData.slice(startSampleInBuffer, endSampleInBuffer);
        audioSamples.push(trimmedData);
    }
    const totalSamples = audioSamples.reduce((sum, sample)=>sum + sample.length, 0);
    const result = new Float32Array(totalSamples);
    let offset = 0;
    for (const audioSample of audioSamples){
        result.set(audioSample, offset);
        offset += audioSample.length;
    }
    return result;
};
exports.getPartialAudioData = getPartialAudioData;
}),
"[project]/node_modules/@remotion/media-utils/dist/use-windowed-audio-data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useWindowedAudioData = void 0;
const mediabunny_1 = __turbopack_context__.r("[project]/node_modules/mediabunny/dist/bundles/mediabunny.cjs [app-route] (ecmascript)");
const react_1 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
const remotion_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
const combine_float32_arrays_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/combine-float32-arrays.js [app-route] (ecmascript)");
const get_partial_audio_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-partial-audio-data.js [app-route] (ecmascript)");
const is_remote_asset_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/is-remote-asset.js [app-route] (ecmascript)");
const warnedMatroska = {};
const useWindowedAudioData = ({ src, frame, fps, windowInSeconds, channelIndex = 0 })=>{
    const isMounted = (0, react_1.useRef)(true);
    const [audioUtils, setAudioUtils] = (0, react_1.useState)(null);
    const [waveFormMap, setWaveformMap] = (0, react_1.useState)({});
    const requests = (0, react_1.useRef)({});
    const [initialWindowInSeconds] = (0, react_1.useState)(windowInSeconds);
    if (windowInSeconds !== initialWindowInSeconds) {
        throw new Error('windowInSeconds cannot be changed dynamically');
    }
    (0, react_1.useEffect)(()=>{
        isMounted.current = true;
        return ()=>{
            isMounted.current = false;
            Object.values(requests.current).forEach((controller)=>{
                if (controller) {
                    controller.abort();
                }
            });
            requests.current = {};
            setWaveformMap({});
            if (audioUtils) {
                audioUtils.input.dispose();
            }
        };
    }, [
        audioUtils
    ]);
    const { delayRender, continueRender } = (0, remotion_1.useDelayRender)();
    const fetchMetadata = (0, react_1.useCallback)(async (signal)=>{
        const handle = delayRender(`Waiting for audio metadata with src="${src}" to be loaded`);
        const cont = ()=>{
            continueRender(handle);
        };
        signal.addEventListener('abort', cont, {
            once: true
        });
        const input = new mediabunny_1.Input({
            formats: mediabunny_1.ALL_FORMATS,
            source: new mediabunny_1.UrlSource(src)
        });
        const onAbort = ()=>{
            input.dispose();
        };
        signal.addEventListener('abort', onAbort, {
            once: true
        });
        try {
            const durationInSeconds = await input.computeDuration();
            const audioTrack = await input.getPrimaryAudioTrack();
            if (!audioTrack) {
                throw new Error('No audio track found');
            }
            const canDecode = await audioTrack.canDecode();
            if (!canDecode) {
                throw new Error('Audio track cannot be decoded');
            }
            if (channelIndex >= audioTrack.numberOfChannels || channelIndex < 0) {
                throw new Error(`Invalid channel index ${channelIndex} for audio with ${audioTrack.numberOfChannels} channels`);
            }
            const { numberOfChannels, sampleRate } = audioTrack;
            const format = await input.getFormat();
            const isMatroska = format === mediabunny_1.MATROSKA || format === mediabunny_1.WEBM;
            if (isMounted.current) {
                setAudioUtils({
                    input,
                    track: audioTrack,
                    metadata: {
                        durationInSeconds,
                        numberOfChannels,
                        sampleRate
                    },
                    isMatroska
                });
            }
            continueRender(handle);
        } catch (err) {
            input.dispose();
            (0, remotion_1.cancelRender)(err);
        } finally{
            signal.removeEventListener('abort', cont);
            signal.removeEventListener('abort', onAbort);
        }
    }, [
        src,
        delayRender,
        continueRender,
        channelIndex
    ]);
    (0, react_1.useLayoutEffect)(()=>{
        const controller = new AbortController();
        fetchMetadata(controller.signal);
        return ()=>{
            controller.abort();
        };
    }, [
        fetchMetadata
    ]);
    const currentTime = frame / fps;
    const currentWindowIndex = Math.floor(currentTime / windowInSeconds);
    const windowsToFetch = (0, react_1.useMemo)(()=>{
        if (!(audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata)) {
            return [];
        }
        const maxWindowIndex = Math.floor(// If an audio is exactly divisible by windowInSeconds, we need to
        // subtract 0.000000000001 to avoid fetching an extra window.
        audioUtils.metadata.durationInSeconds / windowInSeconds - 0.000000000001);
        // needs to be in order because we rely on the concatenation below
        return [
            currentWindowIndex === 0 ? null : currentWindowIndex - 1,
            currentWindowIndex,
            currentWindowIndex + 1 > maxWindowIndex ? null : currentWindowIndex + 1
        ].filter((i)=>i !== null).filter((i)=>i >= 0);
    }, [
        currentWindowIndex,
        audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata,
        windowInSeconds
    ]);
    const fetchAndSetWaveformData = (0, react_1.useCallback)(async (windowIndex)=>{
        if (!(audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata) || !audioUtils) {
            throw new Error('MediaBunny context is not loaded yet');
        }
        // Cancel any existing request for this window, we don't want to over-fetch
        const existingController = requests.current[windowIndex];
        if (existingController) {
            existingController.abort();
        }
        const controller = new AbortController();
        requests.current[windowIndex] = controller;
        if (controller.signal.aborted) {
            return;
        }
        const fromSeconds = windowIndex * windowInSeconds;
        const toSeconds = (windowIndex + 1) * windowInSeconds;
        // if both fromSeconds and toSeconds are outside of the audio duration, skip fetching
        if (fromSeconds >= audioUtils.metadata.durationInSeconds || toSeconds <= 0) {
            return;
        }
        try {
            const { isMatroska } = audioUtils;
            if (isMatroska && !warnedMatroska[src]) {
                warnedMatroska[src] = true;
                remotion_1.Internals.Log.warn({
                    logLevel: 'info',
                    tag: '@remotion/media-utils'
                }, `[useWindowedAudioData] Matroska/WebM file detected at "${src}".\n\nDue to format limitation, audio decoding must start from the beginning of the file, which may lead to increased memory usage and slower performance for large files. Consider converting the audio to a more suitable format like MP3 or AAC for better performance.`);
            }
            const partialWaveData = await (0, get_partial_audio_data_1.getPartialAudioData)({
                track: audioUtils.track,
                fromSeconds,
                toSeconds,
                channelIndex,
                signal: controller.signal,
                isMatroska
            });
            if (!controller.signal.aborted) {
                setWaveformMap((prev)=>{
                    const entries = Object.keys(prev);
                    const windowsToClear = entries.filter((entry)=>!windowsToFetch.includes(Number(entry)));
                    return {
                        ...prev,
                        ...windowsToClear.reduce((acc, key)=>{
                            acc[key] = null;
                            return acc;
                        }, {}),
                        [windowIndex]: partialWaveData
                    };
                });
            }
        } catch (err) {
            if (controller.signal.aborted) {
                return;
            }
            if (err instanceof mediabunny_1.InputDisposedError) {
                return;
            }
            throw err;
        } finally{
            if (requests.current[windowIndex] === controller) {
                requests.current[windowIndex] = null;
            }
        }
    }, [
        channelIndex,
        audioUtils,
        windowInSeconds,
        windowsToFetch,
        src
    ]);
    (0, react_1.useEffect)(()=>{
        if (!(audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata)) {
            return;
        }
        const windowsToClear = Object.keys(requests.current).filter((entry)=>!windowsToFetch.includes(Number(entry)));
        for (const windowIndex of windowsToClear){
            const controller = requests.current[windowIndex];
            if (controller) {
                controller.abort();
                requests.current[windowIndex] = null;
            }
        }
        // Only fetch windows that don't already exist
        const windowsToActuallyFetch = windowsToFetch.filter((windowIndex)=>!waveFormMap[windowIndex]);
        if (windowsToActuallyFetch.length === 0) {
            return;
        }
        Promise.all(windowsToActuallyFetch.map((windowIndex)=>{
            return fetchAndSetWaveformData(windowIndex);
        })).catch((err)=>{
            var _a, _b, _c, _d, _e;
            if ((_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes('Cancelled')) {
                return;
            }
            if ((_c = (_b = err.stack) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === null || _c === void 0 ? void 0 : _c.includes('aborted')) {
                return;
            }
            // firefox
            if ((_e = (_d = err.message) === null || _d === void 0 ? void 0 : _d.toLowerCase()) === null || _e === void 0 ? void 0 : _e.includes('aborted')) {
                return;
            }
            (0, remotion_1.cancelRender)(err);
        });
    }, [
        fetchAndSetWaveformData,
        audioUtils,
        windowsToFetch,
        waveFormMap
    ]);
    // Calculate available windows for reuse
    const availableWindows = (0, react_1.useMemo)(()=>{
        return windowsToFetch.filter((i)=>waveFormMap[i]);
    }, [
        windowsToFetch,
        waveFormMap
    ]);
    const currentAudioData = (0, react_1.useMemo)(()=>{
        if (!(audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata)) {
            return null;
        }
        if (availableWindows.length === 0) {
            return null;
        }
        const windows = availableWindows.map((i)=>waveFormMap[i]);
        const data = (0, combine_float32_arrays_1.combineFloat32Arrays)(windows);
        return {
            channelWaveforms: [
                data
            ],
            durationInSeconds: audioUtils.metadata.durationInSeconds,
            isRemote: (0, is_remote_asset_1.isRemoteAsset)(src),
            numberOfChannels: 1,
            resultId: `${src}-windows-${availableWindows.join(',')}`,
            sampleRate: audioUtils.metadata.sampleRate
        };
    }, [
        src,
        waveFormMap,
        audioUtils === null || audioUtils === void 0 ? void 0 : audioUtils.metadata,
        availableWindows
    ]);
    const isBeyondAudioDuration = audioUtils ? currentTime >= audioUtils.metadata.durationInSeconds : false;
    (0, react_1.useLayoutEffect)(()=>{
        if (currentAudioData) {
            return;
        }
        if (isBeyondAudioDuration) {
            return;
        }
        const handle = delayRender(`Waiting for audio data with src="${src}" to be loaded`);
        return ()=>{
            continueRender(handle);
        };
    }, [
        currentAudioData,
        src,
        delayRender,
        continueRender,
        isBeyondAudioDuration
    ]);
    const audioData = isBeyondAudioDuration ? null : currentAudioData;
    return {
        audioData,
        dataOffsetInSeconds: availableWindows.length > 0 ? availableWindows[0] * windowInSeconds : 0
    };
};
exports.useWindowedAudioData = useWindowedAudioData;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/complex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.complexMagnitude = exports.complexMultiply = exports.complexSubtract = exports.complexAdd = void 0;
const complexAdd = function(a, b) {
    return [
        a[0] + b[0],
        a[1] + b[1]
    ];
};
exports.complexAdd = complexAdd;
const complexSubtract = function(a, b) {
    return [
        a[0] - b[0],
        a[1] - b[1]
    ];
};
exports.complexSubtract = complexSubtract;
const complexMultiply = function(a, b) {
    return [
        a[0] * b[0] - a[1] * b[1],
        a[0] * b[1] + a[1] * b[0]
    ];
};
exports.complexMultiply = complexMultiply;
const complexMagnitude = function(c) {
    return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
};
exports.complexMagnitude = complexMagnitude;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/exponent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exponent = void 0;
const mapExponent = {};
const exponent = function(k, N) {
    const x = -2 * Math.PI * (k / N);
    mapExponent[N] = mapExponent[N] || {};
    mapExponent[N][k] = mapExponent[N][k] || [
        Math.cos(x),
        Math.sin(x)
    ]; // [Real, Imaginary]
    return mapExponent[N][k];
};
exports.exponent = exponent;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/fft-accurate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fftAccurate = void 0;
const complex_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/complex.js [app-route] (ecmascript)");
const exponent_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/exponent.js [app-route] (ecmascript)");
const fftAccurate = function(vector) {
    const X = [];
    const N = vector.length;
    // Base case is X = x + 0i since our input is assumed to be real only.
    if (N === 1) {
        if (Array.isArray(vector[0])) {
            // If input vector contains complex numbers
            return [
                [
                    vector[0][0],
                    vector[0][1]
                ]
            ];
        }
        return [
            [
                vector[0],
                0
            ]
        ];
    }
    // Recurse: all even samples
    const X_evens = (0, exports.fftAccurate)(vector.filter((_, ix)=>ix % 2 === 0));
    // Recurse: all odd samples
    const X_odds = (0, exports.fftAccurate)(vector.filter((__, ix)=>ix % 2 === 1));
    // Now, perform N/2 operations!
    for(let k = 0; k < N / 2; k++){
        // t is a complex number!
        const t = X_evens[k];
        const e = (0, complex_1.complexMultiply)((0, exponent_1.exponent)(k, N), X_odds[k]);
        X[k] = (0, complex_1.complexAdd)(t, e);
        X[k + N / 2] = (0, complex_1.complexSubtract)(t, e);
    }
    return X;
};
exports.fftAccurate = fftAccurate;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/fft-fast.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// https://pastebin.com/raw/D42RbPe5
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fftFast = void 0;
// Function to reverse bits in an integer
function reverseBits(num, numBits) {
    let result = 0;
    for(let i = 0; i < numBits; i++){
        result = result << 1 | num >> i & 1;
    }
    return result;
}
// Hamming window function
function hammingWindow(N) {
    const win = new Array(N);
    for(let i = 0; i < N; i++){
        win[i] = 0.8 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1));
    }
    return win;
}
// Function to calculate the bit-reversed permutation indices
function bitReversePermutation(N) {
    const bitReversed = new Array(N);
    for(let i = 0; i < N; i++){
        bitReversed[i] = reverseBits(i, Math.log2(N));
    }
    return bitReversed;
}
const fftFast = function(vector) {
    const N = vector.length;
    const X = new Array(N);
    if (N <= 1) {
        for(let i = 0; i < vector.length; i++){
            const value = vector[i];
            X[i] = [
                value * 2,
                0
            ];
        }
        return X;
    }
    // Apply a windowing function to the input data
    const window = hammingWindow(N); // You can choose a different window function if needed
    for(let i = 0; i < N; i++){
        X[i] = [
            vector[i] * window[i],
            0
        ];
    }
    // Bit-Reversal Permutation
    const bitReversed = bitReversePermutation(N);
    for(let i = 0; i < N; i++){
        X[i] = [
            vector[bitReversed[i]],
            0
        ];
    }
    // Cooley-Tukey FFT
    for(let s = 1; s <= Math.log2(N); s++){
        const m = 1 << s; // Number of elements in each subarray
        const mHalf = m / 2; // Half the number of elements in each subarray
        const angleIncrement = 2 * Math.PI / m;
        for(let k = 0; k < N; k += m){
            let omegaReal = 1.0;
            let omegaImag = 0.0;
            for(let j = 0; j < mHalf; j++){
                const tReal = omegaReal * X[k + j + mHalf][0] - omegaImag * X[k + j + mHalf][1];
                const tImag = omegaReal * X[k + j + mHalf][1] + omegaImag * X[k + j + mHalf][0];
                const uReal = X[k + j][0];
                const uImag = X[k + j][1];
                X[k + j] = [
                    uReal + tReal,
                    uImag + tImag
                ];
                X[k + j + mHalf] = [
                    uReal - tReal,
                    uImag - tImag
                ];
                // Twiddle factor update
                const tempReal = omegaReal * Math.cos(angleIncrement) - omegaImag * Math.sin(angleIncrement);
                omegaImag = omegaReal * Math.sin(angleIncrement) + omegaImag * Math.cos(angleIncrement);
                omegaReal = tempReal;
            }
        }
    }
    return X;
};
exports.fftFast = fftFast;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/mag.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fftMag = void 0;
const complex_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/complex.js [app-route] (ecmascript)");
const fftMag = function(fftBins) {
    const ret = fftBins.map((f)=>(0, complex_1.complexMagnitude)(f));
    return ret.slice(0, ret.length / 2);
};
exports.fftMag = fftMag;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/smoothing.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.smoothen = void 0;
const smoothingPasses = 3;
const smoothingPoints = 3;
const smoothen = function(array) {
    let lastArray = array;
    const newArr = [];
    for(let pass = 0; pass < smoothingPasses; pass++){
        const sidePoints = Math.floor(smoothingPoints / 2); // our window is centered so this is both nL and nR
        const cn = 1 / (2 * sidePoints + 1); // constant
        for(let i = 0; i < sidePoints; i++){
            newArr[i] = lastArray[i];
            newArr[lastArray.length - i - 1] = lastArray[lastArray.length - i - 1];
        }
        for(let i = sidePoints; i < lastArray.length - sidePoints; i++){
            let sum = 0;
            for(let n = -sidePoints; n <= sidePoints; n++){
                sum += cn * lastArray[i + n] + n;
            }
            newArr[i] = sum;
        }
        lastArray = newArr;
    }
    return newArr;
};
exports.smoothen = smoothen;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/to-int-16.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toInt16 = void 0;
const toInt16 = (x)=>x > 0 ? x * 0x7fff : x * 0x8000;
exports.toInt16 = toInt16;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/get-visualization.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getVisualization = void 0;
const fft_accurate_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/fft-accurate.js [app-route] (ecmascript)");
const fft_fast_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/fft-fast.js [app-route] (ecmascript)");
const mag_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/mag.js [app-route] (ecmascript)");
const smoothing_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/smoothing.js [app-route] (ecmascript)");
const to_int_16_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/to-int-16.js [app-route] (ecmascript)");
const getVisualization = ({ sampleSize, data, sampleRate, frame, fps, maxInt, optimizeFor, dataOffsetInSeconds })=>{
    const isPowerOfTwo = sampleSize > 0 && (sampleSize & sampleSize - 1) === 0;
    if (!isPowerOfTwo) {
        throw new TypeError(`The argument "bars" must be a power of two. For example: 64, 128. Got instead: ${sampleSize}`);
    }
    if (!fps) {
        throw new TypeError('The argument "fps" was not provided');
    }
    if (data.length < sampleSize) {
        throw new TypeError('Audio data is not big enough to provide ' + sampleSize + ' bars.');
    }
    const start = Math.floor((frame / fps - dataOffsetInSeconds) * sampleRate);
    const actualStart = Math.max(0, start - sampleSize / 2);
    const ints = new Int16Array({
        length: sampleSize
    });
    ints.set(data.subarray(actualStart, actualStart + sampleSize).map((x)=>(0, to_int_16_1.toInt16)(x)));
    const alg = optimizeFor === 'accuracy' ? fft_accurate_1.fftAccurate : fft_fast_1.fftFast;
    const phasors = alg(ints);
    const magnitudes = (0, mag_1.fftMag)(phasors).map((p)=>p);
    return (0, smoothing_1.smoothen)(magnitudes).map((m)=>m / (sampleSize / 2) / maxInt);
};
exports.getVisualization = getVisualization;
}),
"[project]/node_modules/@remotion/media-utils/dist/fft/max-value-cached.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Adapted from node-fft project by Joshua Wong and Ben Bryan
// https://github.com/vail-systems/node-fft
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMaxPossibleMagnitude = void 0;
const to_int_16_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/to-int-16.js [app-route] (ecmascript)");
const getMax = (array)=>{
    let max = 0;
    for(let i = 0; i < array.length; i++){
        const val = array[i];
        if (val > max) {
            max = val;
        }
    }
    return max;
};
const cache = {};
const getMaxPossibleMagnitude = (metadata)=>{
    if (cache[metadata.resultId]) {
        return cache[metadata.resultId];
    }
    const result = (0, to_int_16_1.toInt16)(getMax(metadata.channelWaveforms[0]));
    cache[metadata.resultId] = result;
    return result;
};
exports.getMaxPossibleMagnitude = getMaxPossibleMagnitude;
}),
"[project]/node_modules/@remotion/media-utils/dist/visualize-audio.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.visualizeAudio = void 0;
const no_react_1 = __turbopack_context__.r("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
const get_visualization_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/get-visualization.js [app-route] (ecmascript)");
const max_value_cached_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/fft/max-value-cached.js [app-route] (ecmascript)");
const cache = {};
/**
 * @description Takes in AudioData (preferably fetched by the useAudioData() hook) and processes it in a way that makes visualizing the audio that is playing at the current frame easy.
 * @description part of @remotion/media-utils
 * @see [Documentation](https://www.remotion.dev/docs/visualize-audio)
 */ const visualizeAudioFrame = ({ audioData, frame, fps, numberOfSamples, optimizeFor, dataOffsetInSeconds })=>{
    const cacheKey = audioData.resultId + frame + fps + numberOfSamples;
    if (cache[cacheKey]) {
        return cache[cacheKey];
    }
    const maxInt = (0, max_value_cached_1.getMaxPossibleMagnitude)(audioData);
    return (0, get_visualization_1.getVisualization)({
        sampleSize: numberOfSamples * 2,
        data: audioData.channelWaveforms[0],
        frame,
        fps,
        sampleRate: audioData.sampleRate,
        maxInt,
        optimizeFor,
        dataOffsetInSeconds
    });
};
const visualizeAudio = ({ smoothing = true, optimizeFor = no_react_1.NoReactInternals.ENABLE_V5_BREAKING_CHANGES ? 'speed' : 'accuracy', dataOffsetInSeconds = 0, ...parameters })=>{
    if (!smoothing) {
        return visualizeAudioFrame({
            ...parameters,
            optimizeFor,
            dataOffsetInSeconds,
            smoothing
        });
    }
    const toSmooth = [
        parameters.frame - 1,
        parameters.frame,
        parameters.frame + 1
    ];
    const all = toSmooth.map((s)=>{
        return visualizeAudioFrame({
            ...parameters,
            frame: s,
            dataOffsetInSeconds,
            optimizeFor,
            smoothing
        });
    });
    return new Array(parameters.numberOfSamples).fill(true).map((_x, i)=>{
        return new Array(toSmooth.length).fill(true).map((_, j)=>{
            return all[j][i];
        }).reduce((a, b)=>a + b, 0) / toSmooth.length;
    });
};
exports.visualizeAudio = visualizeAudio;
}),
"[project]/node_modules/@remotion/media-utils/dist/visualize-audio-waveform.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.visualizeAudioWaveform = void 0;
const get_waveform_portion_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-waveform-portion.js [app-route] (ecmascript)");
const cache = {};
const visualizeAudioWaveformFrame = ({ audioData, frame, fps, numberOfSamples, windowInSeconds, channel, dataOffsetInSeconds, normalize = false })=>{
    if (windowInSeconds * audioData.sampleRate < numberOfSamples) {
        throw new TypeError(windowInSeconds + 's audiodata does not have ' + numberOfSamples + ' bars. Increase windowInSeconds or decrease numberOfSamples');
    }
    const cacheKey = audioData.resultId + frame + fps + numberOfSamples + 'waveform' + dataOffsetInSeconds;
    if (cache[cacheKey]) {
        return cache[cacheKey];
    }
    const time = frame / fps;
    const startTimeInSeconds = time - windowInSeconds / 2;
    return (0, get_waveform_portion_1.getWaveformPortion)({
        audioData,
        startTimeInSeconds,
        durationInSeconds: windowInSeconds,
        numberOfSamples,
        outputRange: 'minus-one-to-one',
        channel,
        dataOffsetInSeconds,
        normalize
    });
};
const visualizeAudioWaveform = (parameters)=>{
    const data = visualizeAudioWaveformFrame(parameters);
    return data.map((value)=>value.amplitude);
};
exports.visualizeAudioWaveform = visualizeAudioWaveform;
}),
"[project]/node_modules/@remotion/media-utils/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.visualizeAudioWaveform = exports.visualizeAudio = exports.useWindowedAudioData = exports.useAudioData = exports.getWaveformPortion = exports.getVideoMetadata = exports.getImageDimensions = exports.getAudioDurationInSeconds = exports.getAudioDuration = exports.getAudioData = exports.createSmoothSvgPath = exports.audioBufferToDataUrl = void 0;
var audio_url_helpers_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/audio-buffer/audio-url-helpers.js [app-route] (ecmascript)");
Object.defineProperty(exports, "audioBufferToDataUrl", {
    enumerable: true,
    get: function() {
        return audio_url_helpers_1.audioBufferToDataUrl;
    }
});
var create_smooth_svg_path_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/create-smooth-svg-path.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createSmoothSvgPath", {
    enumerable: true,
    get: function() {
        return create_smooth_svg_path_1.createSmoothSvgPath;
    }
});
var get_audio_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-audio-data.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getAudioData", {
    enumerable: true,
    get: function() {
        return get_audio_data_1.getAudioData;
    }
});
var get_audio_duration_in_seconds_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-audio-duration-in-seconds.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getAudioDuration", {
    enumerable: true,
    get: function() {
        return get_audio_duration_in_seconds_1.getAudioDuration;
    }
});
Object.defineProperty(exports, "getAudioDurationInSeconds", {
    enumerable: true,
    get: function() {
        return get_audio_duration_in_seconds_1.getAudioDurationInSeconds;
    }
});
var get_image_dimensions_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-image-dimensions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getImageDimensions", {
    enumerable: true,
    get: function() {
        return get_image_dimensions_1.getImageDimensions;
    }
});
var get_video_metadata_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-video-metadata.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getVideoMetadata", {
    enumerable: true,
    get: function() {
        return get_video_metadata_1.getVideoMetadata;
    }
});
var get_waveform_portion_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/get-waveform-portion.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getWaveformPortion", {
    enumerable: true,
    get: function() {
        return get_waveform_portion_1.getWaveformPortion;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/types.js [app-route] (ecmascript)"), exports);
var use_audio_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/use-audio-data.js [app-route] (ecmascript)");
Object.defineProperty(exports, "useAudioData", {
    enumerable: true,
    get: function() {
        return use_audio_data_1.useAudioData;
    }
});
var use_windowed_audio_data_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/use-windowed-audio-data.js [app-route] (ecmascript)");
Object.defineProperty(exports, "useWindowedAudioData", {
    enumerable: true,
    get: function() {
        return use_windowed_audio_data_1.useWindowedAudioData;
    }
});
var visualize_audio_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/visualize-audio.js [app-route] (ecmascript)");
Object.defineProperty(exports, "visualizeAudio", {
    enumerable: true,
    get: function() {
        return visualize_audio_1.visualizeAudio;
    }
});
var visualize_audio_waveform_1 = __turbopack_context__.r("[project]/node_modules/@remotion/media-utils/dist/visualize-audio-waveform.js [app-route] (ecmascript)");
Object.defineProperty(exports, "visualizeAudioWaveform", {
    enumerable: true,
    get: function() {
        return visualize_audio_waveform_1.visualizeAudioWaveform;
    }
});
}),
"[project]/node_modules/@remotion/web-renderer/dist/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
}),
"[project]/node_modules/@remotion/web-renderer/dist/add-sample.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addAudioSample",
    ()=>addAudioSample,
    "addVideoSampleAndCloseFrame",
    ()=>addVideoSampleAndCloseFrame
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/sample.js [app-route] (ecmascript)");
;
const addVideoSampleAndCloseFrame = async (frameToEncode, videoSampleSource)=>{
    const sample = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["VideoSample"](frameToEncode);
    try {
        await videoSampleSource.add(sample);
    } finally{
        sample.close();
        frameToEncode.close();
    }
};
const addAudioSample = async (audio, audioSampleSource)=>{
    const sample = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AudioSample"](audio);
    try {
        await audioSampleSource.add(sample);
    } finally{
        sample.close();
    }
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/artifact.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleArtifacts",
    ()=>handleArtifacts,
    "onlyArtifact",
    ()=>onlyArtifact
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$no$2d$react$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/no-react.mjs [app-route] (ecmascript)");
;
const onlyArtifact = async ({ assets, frameBuffer })=>{
    const artifacts = assets.filter((asset)=>asset.type === 'artifact');
    let frameBufferUint8 = null;
    const result = [];
    for (const artifact of artifacts){
        if (artifact.contentType === 'binary' || artifact.contentType === 'text') {
            result.push({
                frame: artifact.frame,
                content: artifact.content,
                filename: artifact.filename,
                downloadBehavior: artifact.downloadBehavior
            });
            continue;
        }
        if (artifact.contentType === 'thumbnail') {
            if (frameBuffer === null) {
                continue;
            }
            const ab = frameBuffer instanceof Blob ? await frameBuffer.arrayBuffer() : new Uint8Array(await (await frameBuffer.convertToBlob({
                type: 'image/png'
            })).arrayBuffer());
            frameBufferUint8 = new Uint8Array(ab);
            result.push({
                frame: artifact.frame,
                content: frameBufferUint8,
                filename: artifact.filename,
                downloadBehavior: artifact.downloadBehavior
            });
            continue;
        }
        throw new Error('Unknown artifact type: ' + artifact);
    }
    return result.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$no$2d$react$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoReactInternals"].truthy);
};
const handleArtifacts = ()=>{
    const previousArtifacts = [];
    const handle = async ({ imageData, frame, assets: artifactAssets, onArtifact })=>{
        const artifacts = await onlyArtifact({
            assets: artifactAssets,
            frameBuffer: imageData
        });
        for (const artifact of artifacts){
            const previousArtifact = previousArtifacts.find((a)=>a.filename === artifact.filename);
            if (previousArtifact) {
                throw new Error(`An artifact with output "${artifact.filename}" was already registered at frame ${previousArtifact.frame}, but now registered again at frame ${frame}. Artifacts must have unique names. https://remotion.dev/docs/artifacts`);
            }
            onArtifact(artifact);
            previousArtifacts.push({
                frame,
                filename: artifact.filename
            });
        }
    };
    return {
        handle
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/audio.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onlyInlineAudio",
    ()=>onlyInlineAudio
]);
const TARGET_NUMBER_OF_CHANNELS = 2;
const TARGET_SAMPLE_RATE = 48000;
function mixAudio(waves, length) {
    if (waves.length === 1 && waves[0].length === length) {
        return waves[0];
    }
    const mixed = new Int16Array(length);
    if (waves.length === 1) {
        mixed.set(waves[0].subarray(0, length));
        return mixed;
    }
    for(let i = 0; i < length; i++){
        const sum = waves.reduce((acc, wave)=>{
            var _a;
            return acc + ((_a = wave[i]) !== null && _a !== void 0 ? _a : 0);
        }, 0);
        // Clamp to Int16 range
        mixed[i] = Math.max(-32768, Math.min(32767, sum));
    }
    return mixed;
}
const onlyInlineAudio = ({ assets, fps, frame })=>{
    const inlineAudio = assets.filter((asset)=>asset.type === 'inline-audio');
    if (inlineAudio.length === 0) {
        return null;
    }
    const expectedLength = Math.round(TARGET_NUMBER_OF_CHANNELS * TARGET_SAMPLE_RATE / fps);
    for (const asset of inlineAudio){
        if (asset.toneFrequency !== 1) {
            throw new Error('Setting the toneFrequency is not supported yet in web rendering.');
        }
    }
    const mixedAudio = mixAudio(inlineAudio.map((asset)=>asset.audio), expectedLength);
    return new AudioData({
        data: mixedAudio,
        format: 's16',
        numberOfChannels: TARGET_NUMBER_OF_CHANNELS,
        numberOfFrames: expectedLength / TARGET_NUMBER_OF_CHANNELS,
        sampleRate: TARGET_SAMPLE_RATE,
        timestamp: frame / fps * 1000000
    });
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/can-use-webfs-target.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "canUseWebFsWriter",
    ()=>canUseWebFsWriter
]);
const canUseWebFsWriter = async ()=>{
    if (!('storage' in navigator)) {
        return false;
    }
    if (!('getDirectory' in navigator.storage)) {
        return false;
    }
    try {
        const directoryHandle = await navigator.storage.getDirectory();
        const fileHandle = await directoryHandle.getFileHandle('remotion-probe-web-fs-support', {
            create: true
        });
        const canUse = fileHandle.createWritable !== undefined;
        return canUse;
    } catch (_a) {
        return false;
    }
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/update-time.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UpdateTime",
    ()=>UpdateTime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
;
;
;
;
const UpdateTime = ({ children, audioEnabled, videoEnabled, logLevel, compId, initialFrame, timeUpdater })=>{
    const [frame, setFrame] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["useState"])(initialFrame);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["useImperativeHandle"])(timeUpdater, ()=>({
            update: (f)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["flushSync"])(()=>{
                    setFrame(f);
                });
            }
        }));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].RemotionRootContexts, {
        audioEnabled: audioEnabled,
        videoEnabled: videoEnabled,
        logLevel: logLevel,
        numberOfAudioTags: 0,
        audioLatencyHint: "interactive",
        frameState: {
            [compId]: frame
        },
        children: children
    });
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/with-resolvers.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "withResolvers",
    ()=>withResolvers
]);
const withResolvers = function() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/create-scaffold.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createScaffold",
    ()=>createScaffold
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$client$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/client.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$update$2d$time$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/update-time.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$with$2d$resolvers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/with-resolvers.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
async function createScaffold({ width, height, delayRenderTimeoutInMilliseconds, logLevel, resolvedProps, id, mediaCacheSizeInBytes, durationInFrames, fps, initialFrame, schema, Component, audioEnabled, videoEnabled, defaultCodec, defaultOutName }) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$client$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createRoot) {
        throw new Error('@remotion/web-renderer requires React 18 or higher');
    }
    const div = document.createElement('div');
    // Match same behavior as renderEntry.tsx
    div.style.display = 'flex';
    div.style.backgroundColor = 'transparent';
    div.style.position = 'fixed';
    div.style.width = `${width}px`;
    div.style.height = `${height}px`;
    div.style.zIndex = '-9999';
    div.style.top = '0';
    div.style.visibility = 'hidden';
    div.style.left = '0';
    div.style.pointerEvents = 'none';
    document.body.appendChild(div);
    const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$with$2d$resolvers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withResolvers"])();
    // TODO: This might not work in React 18
    const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$client$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createRoot(div, {
        onUncaughtError: (err)=>{
            reject(err);
        }
    });
    const delayRenderScope = {
        remotion_renderReady: true,
        remotion_delayRenderTimeouts: {},
        remotion_puppeteerTimeout: delayRenderTimeoutInMilliseconds,
        remotion_attempt: 0,
        remotion_delayRenderHandles: []
    };
    const timeUpdater = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRef"])();
    const collectAssets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["flushSync"])(()=>{
        root.render((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].MaxMediaCacheSizeContext.Provider, {
            value: mediaCacheSizeInBytes,
            children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].RemotionEnvironmentContext.Provider, {
                value: {
                    isStudio: false,
                    isRendering: true,
                    isPlayer: false,
                    isReadOnlyStudio: false,
                    isClientSideRendering: true
                },
                children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].DelayRenderContextType.Provider, {
                    value: delayRenderScope,
                    children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].CompositionManager.Provider, {
                        value: {
                            compositions: [
                                {
                                    id,
                                    // @ts-expect-error
                                    component: Component,
                                    nonce: 0,
                                    defaultProps: {},
                                    folderName: null,
                                    parentFolderName: null,
                                    schema: schema !== null && schema !== void 0 ? schema : null,
                                    calculateMetadata: null,
                                    durationInFrames,
                                    fps,
                                    height,
                                    width
                                }
                            ],
                            canvasContent: {
                                type: 'composition',
                                compositionId: id
                            },
                            currentCompositionMetadata: {
                                props: resolvedProps,
                                durationInFrames,
                                fps,
                                height,
                                width,
                                defaultCodec: defaultCodec !== null && defaultCodec !== void 0 ? defaultCodec : null,
                                defaultOutName: defaultOutName !== null && defaultOutName !== void 0 ? defaultOutName : null,
                                defaultVideoImageFormat: null,
                                defaultPixelFormat: null,
                                defaultProResProfile: null
                            },
                            folders: []
                        },
                        children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].RenderAssetManagerProvider, {
                            collectAssets: collectAssets,
                            children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$update$2d$time$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UpdateTime"], {
                                audioEnabled: audioEnabled,
                                videoEnabled: videoEnabled,
                                logLevel: logLevel,
                                compId: id,
                                initialFrame: initialFrame,
                                timeUpdater: timeUpdater,
                                children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].CanUseRemotionHooks.Provider, {
                                    value: true,
                                    children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsx"])(Component, {
                                        ...resolvedProps
                                    })
                                })
                            })
                        })
                    })
                })
            })
        }));
    });
    resolve();
    await promise;
    return {
        delayRenderScope,
        div,
        cleanupScaffold: ()=>{
            root.unmount();
            div.remove();
        },
        timeUpdater,
        collectAssets
    };
}
}),
"[project]/node_modules/@remotion/web-renderer/dist/frame-range.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getRealFrameRange",
    ()=>getRealFrameRange
]);
const getRealFrameRange = (durationInFrames, frameRange)=>{
    if (frameRange === null) {
        return [
            0,
            durationInFrames - 1
        ];
    }
    if (typeof frameRange === 'number') {
        if (frameRange < 0 || frameRange >= durationInFrames) {
            throw new Error(`Frame number is out of range, must be between 0 and ${durationInFrames - 1} but got ${frameRange}`);
        }
        return [
            frameRange,
            frameRange
        ];
    }
    if (frameRange[1] >= durationInFrames || frameRange[0] < 0) {
        throw new Error(`The "durationInFrames" of the composition was evaluated to be ${durationInFrames}, but frame range ${frameRange.join('-')} is not inbetween 0-${durationInFrames - 1}`);
    }
    return frameRange;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/get-audio-encoding-config.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDefaultAudioEncodingConfig",
    ()=>getDefaultAudioEncodingConfig
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/encode.js [app-route] (ecmascript)");
;
const getDefaultAudioEncodingConfig = async ()=>{
    const preferredDefaultAudioEncodingConfig = {
        codec: 'aac',
        bitrate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_MEDIUM"]
    };
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["canEncodeAudio"])(preferredDefaultAudioEncodingConfig.codec, preferredDefaultAudioEncodingConfig)) {
        return preferredDefaultAudioEncodingConfig;
    }
    const backupDefaultAudioEncodingConfig = {
        codec: 'opus',
        bitrate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_MEDIUM"]
    };
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["canEncodeAudio"])(backupDefaultAudioEncodingConfig.codec, backupDefaultAudioEncodingConfig)) {
        return backupDefaultAudioEncodingConfig;
    }
    return null;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/mediabunny-mappings.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "codecToMediabunnyCodec",
    ()=>codecToMediabunnyCodec,
    "containerToMediabunnyContainer",
    ()=>containerToMediabunnyContainer,
    "getDefaultVideoCodecForContainer",
    ()=>getDefaultVideoCodecForContainer,
    "getMimeType",
    ()=>getMimeType,
    "getQualityForWebRendererQuality",
    ()=>getQualityForWebRendererQuality
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/output-format.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/encode.js [app-route] (ecmascript)");
;
const codecToMediabunnyCodec = (codec)=>{
    switch(codec){
        case 'h264':
            return 'avc';
        case 'h265':
            return 'hevc';
        case 'vp8':
            return 'vp8';
        case 'vp9':
            return 'vp9';
        case 'av1':
            return 'av1';
        default:
            throw new Error(`Unsupported codec: ${codec}`);
    }
};
const containerToMediabunnyContainer = (container)=>{
    switch(container){
        case 'mp4':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mp4OutputFormat"]();
        case 'webm':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebMOutputFormat"]();
        default:
            throw new Error(`Unsupported container: ${container}`);
    }
};
const getDefaultVideoCodecForContainer = (container)=>{
    switch(container){
        case 'mp4':
            return 'h264';
        case 'webm':
            return 'vp8';
        default:
            throw new Error(`Unsupported container: ${container}`);
    }
};
const getQualityForWebRendererQuality = (quality)=>{
    switch(quality){
        case 'very-low':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_VERY_LOW"];
        case 'low':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_LOW"];
        case 'medium':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_MEDIUM"];
        case 'high':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_HIGH"];
        case 'very-high':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QUALITY_VERY_HIGH"];
        default:
            throw new Error(`Unsupported quality: ${quality}`);
    }
};
const getMimeType = (container)=>{
    switch(container){
        case 'mp4':
            return 'video/mp4';
        case 'webm':
            return 'video/webm';
        default:
            throw new Error(`Unsupported container: ${container}`);
    }
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/render-operations-queue.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onlyOneRenderAtATimeQueue",
    ()=>onlyOneRenderAtATimeQueue
]);
const onlyOneRenderAtATimeQueue = {
    ref: Promise.resolve()
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/turn-svg-into-drawable.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "turnSvgIntoDrawable",
    ()=>turnSvgIntoDrawable
]);
const turnSvgIntoDrawable = (svg)=>{
    const originalTransform = svg.style.transform;
    const originalTransformOrigin = svg.style.transformOrigin;
    const originalMarginLeft = svg.style.marginLeft;
    const originalMarginRight = svg.style.marginRight;
    const originalMarginTop = svg.style.marginTop;
    const originalMarginBottom = svg.style.marginBottom;
    svg.style.transform = 'none';
    svg.style.transformOrigin = '';
    // Margins were already included in the positioning calculation,
    // so we need to remove them to avoid double counting.
    svg.style.marginLeft = '0';
    svg.style.marginRight = '0';
    svg.style.marginTop = '0';
    svg.style.marginBottom = '0';
    const svgData = new XMLSerializer().serializeToString(svg);
    svg.style.marginLeft = originalMarginLeft;
    svg.style.marginRight = originalMarginRight;
    svg.style.marginTop = originalMarginTop;
    svg.style.marginBottom = originalMarginBottom;
    svg.style.transform = originalTransform;
    svg.style.transformOrigin = originalTransformOrigin;
    return new Promise((resolve, reject)=>{
        const image = new Image();
        const url = `data:image/svg+xml;base64,${btoa(svgData)}`;
        image.onload = function() {
            resolve(image);
        };
        image.onerror = ()=>{
            reject(new Error('Failed to convert SVG to image'));
        };
        image.src = url;
    });
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-dom-element.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "drawDomElement",
    ()=>drawDomElement
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$turn$2d$svg$2d$into$2d$drawable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/turn-svg-into-drawable.js [app-route] (ecmascript)");
;
const drawDomElement = (node)=>{
    const domDrawFn = async ({ dimensions, contextToDraw })=>{
        const drawable = await (node instanceof SVGSVGElement ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$turn$2d$svg$2d$into$2d$drawable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["turnSvgIntoDrawable"])(node) : node instanceof HTMLImageElement ? node : node instanceof HTMLCanvasElement ? node : null);
        if (!drawable) {
            return;
        }
        contextToDraw.drawImage(drawable, dimensions.left, dimensions.top, dimensions.width, dimensions.height);
    };
    return domDrawFn;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/parse-transform-origin.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseTransformOrigin",
    ()=>parseTransformOrigin
]);
const parseTransformOrigin = (transformOrigin)=>{
    if (transformOrigin.trim() === '') {
        return null;
    }
    const [x, y] = transformOrigin.split(' ');
    return {
        x: parseFloat(x),
        y: parseFloat(y)
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/calculate-transforms.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateTransforms",
    ()=>calculateTransforms
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$parse$2d$transform$2d$origin$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/parse-transform-origin.js [app-route] (ecmascript)");
;
const getInternalTransformOrigin = (transform)=>{
    var _a;
    const centerX = transform.boundingClientRect.width / 2;
    const centerY = transform.boundingClientRect.height / 2;
    const origin = (_a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$parse$2d$transform$2d$origin$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseTransformOrigin"])(transform.transformOrigin)) !== null && _a !== void 0 ? _a : {
        x: centerX,
        y: centerY
    };
    return origin;
};
const getGlobalTransformOrigin = (transform)=>{
    const { x: originX, y: originY } = getInternalTransformOrigin(transform);
    return {
        x: originX + transform.boundingClientRect.left,
        y: originY + transform.boundingClientRect.top
    };
};
const calculateTransforms = (element)=>{
    // Compute the cumulative transform by traversing parent nodes
    let parent = element;
    const transforms = [];
    const toReset = [];
    let opacity = 1;
    let elementComputedStyle = null;
    while(parent){
        const computedStyle = getComputedStyle(parent);
        // Multiply opacity values from element and all parents
        const parentOpacity = computedStyle.opacity;
        if (parentOpacity && parentOpacity !== '') {
            opacity *= parseFloat(parentOpacity);
        }
        if (parent === element) {
            elementComputedStyle = computedStyle;
        }
        if (computedStyle.transform && computedStyle.transform !== 'none' || parent === element) {
            const toParse = computedStyle.transform === 'none' || computedStyle.transform === '' ? undefined : computedStyle.transform;
            const matrix = new DOMMatrix(toParse);
            const { transform, scale, rotate } = parent.style;
            const additionalMatrices = [];
            // The order of transformations is:
            // 1. Translate --> We do not have to consider it since it changes getClientBoundingRect()
            // 2. Rotate
            // 3. Scale
            // 4. CSS "transform"
            if (rotate !== '' && rotate !== 'none') {
                additionalMatrices.push(new DOMMatrix(`rotate(${rotate})`));
            }
            if (scale !== '' && scale !== 'none') {
                additionalMatrices.push(new DOMMatrix(`scale(${scale})`));
            }
            additionalMatrices.push(matrix);
            parent.style.transform = 'none';
            parent.style.scale = 'none';
            parent.style.rotate = 'none';
            transforms.push({
                rect: parent,
                transformOrigin: computedStyle.transformOrigin,
                boundingClientRect: null,
                matrices: additionalMatrices
            });
            const parentRef = parent;
            toReset.push(()=>{
                parentRef.style.transform = transform;
                parentRef.style.scale = scale;
                parentRef.style.rotate = rotate;
            });
        }
        parent = parent.parentElement;
    }
    for (const transform of transforms){
        transform.boundingClientRect = transform.rect.getBoundingClientRect();
    }
    const dimensions = transforms[0].boundingClientRect;
    const nativeTransformOrigin = getInternalTransformOrigin(transforms[0]);
    const totalMatrix = new DOMMatrix();
    for (const transform of transforms.slice().reverse()){
        if (!transform.boundingClientRect) {
            throw new Error('Bounding client rect not found');
        }
        for (const matrix of transform.matrices){
            const globalTransformOrigin = getGlobalTransformOrigin(transform);
            const transformMatrix = new DOMMatrix().translate(globalTransformOrigin.x, globalTransformOrigin.y).multiply(matrix).translate(-globalTransformOrigin.x, -globalTransformOrigin.y);
            totalMatrix.multiplySelf(transformMatrix);
        }
    }
    if (!elementComputedStyle) {
        throw new Error('Element computed style not found');
    }
    return {
        dimensions,
        totalMatrix,
        reset: ()=>{
            for (const reset of toReset){
                reset();
            }
        },
        nativeTransformOrigin,
        opacity,
        computedStyle: elementComputedStyle
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/border-radius.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseBorderRadius",
    ()=>parseBorderRadius,
    "setBorderRadius",
    ()=>setBorderRadius
]);
function parseValue({ value, reference }) {
    value = value.trim();
    if (value.endsWith('%')) {
        const percentage = parseFloat(value);
        return percentage / 100 * reference;
    }
    if (value.endsWith('px')) {
        return parseFloat(value);
    }
    // If no unit, assume pixels
    return parseFloat(value);
}
function expandShorthand(values) {
    if (values.length === 1) {
        // All corners the same
        return [
            values[0],
            values[0],
            values[0],
            values[0]
        ];
    }
    if (values.length === 2) {
        // [0] = top-left & bottom-right, [1] = top-right & bottom-left
        return [
            values[0],
            values[1],
            values[0],
            values[1]
        ];
    }
    if (values.length === 3) {
        // [0] = top-left, [1] = top-right & bottom-left, [2] = bottom-right
        return [
            values[0],
            values[1],
            values[2],
            values[1]
        ];
    }
    // 4 values: top-left, top-right, bottom-right, bottom-left
    return [
        values[0],
        values[1],
        values[2],
        values[3]
    ];
}
function clampBorderRadius({ borderRadius, width, height }) {
    // According to CSS spec, if the sum of border radii on adjacent corners
    // exceeds the length of the edge, they should be proportionally reduced
    const clamped = {
        topLeft: {
            ...borderRadius.topLeft
        },
        topRight: {
            ...borderRadius.topRight
        },
        bottomRight: {
            ...borderRadius.bottomRight
        },
        bottomLeft: {
            ...borderRadius.bottomLeft
        }
    };
    // Check top edge
    const topSum = clamped.topLeft.horizontal + clamped.topRight.horizontal;
    if (topSum > width) {
        const factor = width / topSum;
        clamped.topLeft.horizontal *= factor;
        clamped.topRight.horizontal *= factor;
    }
    // Check right edge
    const rightSum = clamped.topRight.vertical + clamped.bottomRight.vertical;
    if (rightSum > height) {
        const factor = height / rightSum;
        clamped.topRight.vertical *= factor;
        clamped.bottomRight.vertical *= factor;
    }
    // Check bottom edge
    const bottomSum = clamped.bottomRight.horizontal + clamped.bottomLeft.horizontal;
    if (bottomSum > width) {
        const factor = width / bottomSum;
        clamped.bottomRight.horizontal *= factor;
        clamped.bottomLeft.horizontal *= factor;
    }
    // Check left edge
    const leftSum = clamped.bottomLeft.vertical + clamped.topLeft.vertical;
    if (leftSum > height) {
        const factor = height / leftSum;
        clamped.bottomLeft.vertical *= factor;
        clamped.topLeft.vertical *= factor;
    }
    return clamped;
}
function parseBorderRadius({ borderRadius, width, height }) {
    // Split by '/' to separate horizontal and vertical radii
    const parts = borderRadius.split('/').map((part)=>part.trim());
    const horizontalPart = parts[0];
    const verticalPart = parts[1];
    // Split each part into individual values
    const horizontalValues = horizontalPart.split(/\s+/).filter((v)=>v);
    const verticalValues = verticalPart ? verticalPart.split(/\s+/).filter((v)=>v) : horizontalValues; // If no '/', use horizontal values for vertical
    // Expand shorthand to 4 values
    const [hTopLeft, hTopRight, hBottomRight, hBottomLeft] = expandShorthand(horizontalValues);
    const [vTopLeft, vTopRight, vBottomRight, vBottomLeft] = expandShorthand(verticalValues);
    return clampBorderRadius({
        borderRadius: {
            topLeft: {
                horizontal: parseValue({
                    value: hTopLeft,
                    reference: width
                }),
                vertical: parseValue({
                    value: vTopLeft,
                    reference: height
                })
            },
            topRight: {
                horizontal: parseValue({
                    value: hTopRight,
                    reference: width
                }),
                vertical: parseValue({
                    value: vTopRight,
                    reference: height
                })
            },
            bottomRight: {
                horizontal: parseValue({
                    value: hBottomRight,
                    reference: width
                }),
                vertical: parseValue({
                    value: vBottomRight,
                    reference: height
                })
            },
            bottomLeft: {
                horizontal: parseValue({
                    value: hBottomLeft,
                    reference: width
                }),
                vertical: parseValue({
                    value: vBottomLeft,
                    reference: height
                })
            }
        },
        width,
        height
    });
}
function setBorderRadius({ ctx, x, y, width, height, borderRadius }) {
    if (borderRadius.topLeft.horizontal === 0 && borderRadius.topLeft.vertical === 0 && borderRadius.topRight.horizontal === 0 && borderRadius.topRight.vertical === 0 && borderRadius.bottomRight.horizontal === 0 && borderRadius.bottomRight.vertical === 0 && borderRadius.bottomLeft.horizontal === 0 && borderRadius.bottomLeft.vertical === 0) {
        return ()=>{};
    }
    ctx.save();
    ctx.beginPath();
    // Start at top-left corner, after the horizontal radius
    ctx.moveTo(x + borderRadius.topLeft.horizontal, y);
    // Top edge to top-right corner
    ctx.lineTo(x + width - borderRadius.topRight.horizontal, y);
    // Top-right corner (elliptical arc)
    if (borderRadius.topRight.horizontal > 0 || borderRadius.topRight.vertical > 0) {
        ctx.ellipse(x + width - borderRadius.topRight.horizontal, y + borderRadius.topRight.vertical, borderRadius.topRight.horizontal, borderRadius.topRight.vertical, 0, -Math.PI / 2, 0);
    }
    // Right edge to bottom-right corner
    ctx.lineTo(x + width, y + height - borderRadius.bottomRight.vertical);
    // Bottom-right corner (elliptical arc)
    if (borderRadius.bottomRight.horizontal > 0 || borderRadius.bottomRight.vertical > 0) {
        ctx.ellipse(x + width - borderRadius.bottomRight.horizontal, y + height - borderRadius.bottomRight.vertical, borderRadius.bottomRight.horizontal, borderRadius.bottomRight.vertical, 0, 0, Math.PI / 2);
    }
    // Bottom edge to bottom-left corner
    ctx.lineTo(x + borderRadius.bottomLeft.horizontal, y + height);
    // Bottom-left corner (elliptical arc)
    if (borderRadius.bottomLeft.horizontal > 0 || borderRadius.bottomLeft.vertical > 0) {
        ctx.ellipse(x + borderRadius.bottomLeft.horizontal, y + height - borderRadius.bottomLeft.vertical, borderRadius.bottomLeft.horizontal, borderRadius.bottomLeft.vertical, 0, Math.PI / 2, Math.PI);
    }
    // Left edge to top-left corner
    ctx.lineTo(x, y + borderRadius.topLeft.vertical);
    // Top-left corner (elliptical arc)
    if (borderRadius.topLeft.horizontal > 0 || borderRadius.topLeft.vertical > 0) {
        ctx.ellipse(x + borderRadius.topLeft.horizontal, y + borderRadius.topLeft.vertical, borderRadius.topLeft.horizontal, borderRadius.topLeft.vertical, 0, Math.PI, Math.PI * 3 / 2);
    }
    ctx.closePath();
    ctx.clip();
    return ()=>{
        ctx.restore();
    };
}
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-border.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "drawBorder",
    ()=>drawBorder
]);
const drawBorder = ({ ctx, x, y, width, height, borderRadius, computedStyle })=>{
    const { borderStyle, borderColor, borderWidth: computedBorderWidth } = computedStyle;
    // Parse border width (can be shorthand like "1px 2px 3px 4px")
    const borderWidths = computedBorderWidth.split(/\s+/).map((w)=>parseFloat(w));
    const borderTop = borderWidths[0] || 0;
    const borderRight = borderWidths[1] || borderTop;
    const borderBottom = borderWidths[2] || borderTop;
    const borderLeft = borderWidths[3] || borderRight;
    // Check if we have a visible border
    const hasBorder = borderStyle && borderStyle !== 'none' && borderStyle !== 'hidden' && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);
    if (!hasBorder) {
        return;
    }
    const originalStrokeStyle = ctx.strokeStyle;
    const originalLineWidth = ctx.lineWidth;
    const originalLineDash = ctx.getLineDash();
    ctx.strokeStyle = borderColor;
    // Set line dash based on border style
    if (borderStyle === 'dashed') {
        const max = Math.max(borderTop, borderRight, borderBottom, borderLeft);
        ctx.setLineDash([
            max * 2,
            max
        ]);
    } else if (borderStyle === 'dotted') {
        ctx.setLineDash([
            Math.max(borderTop, borderRight, borderBottom, borderLeft)
        ]);
    } else {
        ctx.setLineDash([]);
    }
    // For simplicity, use the maximum border width if they differ
    // A full implementation would draw each side separately
    const maxBorderWidth = Math.max(borderTop, borderRight, borderBottom, borderLeft);
    // Create path for border (inset by half the border width to draw inside)
    ctx.beginPath();
    const borderX = x + maxBorderWidth / 2;
    const borderY = y + maxBorderWidth / 2;
    const borderWidth = width - maxBorderWidth;
    const borderHeight = height - maxBorderWidth;
    // Account for border radius, adjusted for the border width
    const adjustedBorderRadius = {
        topLeft: {
            horizontal: Math.max(0, borderRadius.topLeft.horizontal - maxBorderWidth / 2),
            vertical: Math.max(0, borderRadius.topLeft.vertical - maxBorderWidth / 2)
        },
        topRight: {
            horizontal: Math.max(0, borderRadius.topRight.horizontal - maxBorderWidth / 2),
            vertical: Math.max(0, borderRadius.topRight.vertical - maxBorderWidth / 2)
        },
        bottomRight: {
            horizontal: Math.max(0, borderRadius.bottomRight.horizontal - maxBorderWidth / 2),
            vertical: Math.max(0, borderRadius.bottomRight.vertical - maxBorderWidth / 2)
        },
        bottomLeft: {
            horizontal: Math.max(0, borderRadius.bottomLeft.horizontal - maxBorderWidth / 2),
            vertical: Math.max(0, borderRadius.bottomLeft.vertical - maxBorderWidth / 2)
        }
    };
    // Draw path with border radius
    ctx.moveTo(borderX + adjustedBorderRadius.topLeft.horizontal, borderY);
    // Top edge
    ctx.lineTo(borderX + borderWidth - adjustedBorderRadius.topRight.horizontal, borderY);
    // Top-right corner
    if (adjustedBorderRadius.topRight.horizontal > 0 || adjustedBorderRadius.topRight.vertical > 0) {
        ctx.ellipse(borderX + borderWidth - adjustedBorderRadius.topRight.horizontal, borderY + adjustedBorderRadius.topRight.vertical, adjustedBorderRadius.topRight.horizontal, adjustedBorderRadius.topRight.vertical, 0, -Math.PI / 2, 0);
    }
    // Right edge
    ctx.lineTo(borderX + borderWidth, borderY + borderHeight - adjustedBorderRadius.bottomRight.vertical);
    // Bottom-right corner
    if (adjustedBorderRadius.bottomRight.horizontal > 0 || adjustedBorderRadius.bottomRight.vertical > 0) {
        ctx.ellipse(borderX + borderWidth - adjustedBorderRadius.bottomRight.horizontal, borderY + borderHeight - adjustedBorderRadius.bottomRight.vertical, adjustedBorderRadius.bottomRight.horizontal, adjustedBorderRadius.bottomRight.vertical, 0, 0, Math.PI / 2);
    }
    // Bottom edge
    ctx.lineTo(borderX + adjustedBorderRadius.bottomLeft.horizontal, borderY + borderHeight);
    // Bottom-left corner
    if (adjustedBorderRadius.bottomLeft.horizontal > 0 || adjustedBorderRadius.bottomLeft.vertical > 0) {
        ctx.ellipse(borderX + adjustedBorderRadius.bottomLeft.horizontal, borderY + borderHeight - adjustedBorderRadius.bottomLeft.vertical, adjustedBorderRadius.bottomLeft.horizontal, adjustedBorderRadius.bottomLeft.vertical, 0, Math.PI / 2, Math.PI);
    }
    // Left edge
    ctx.lineTo(borderX, borderY + adjustedBorderRadius.topLeft.vertical);
    // Top-left corner
    if (adjustedBorderRadius.topLeft.horizontal > 0 || adjustedBorderRadius.topLeft.vertical > 0) {
        ctx.ellipse(borderX + adjustedBorderRadius.topLeft.horizontal, borderY + adjustedBorderRadius.topLeft.vertical, adjustedBorderRadius.topLeft.horizontal, adjustedBorderRadius.topLeft.vertical, 0, Math.PI, Math.PI * 3 / 2);
    }
    ctx.closePath();
    ctx.lineWidth = maxBorderWidth;
    ctx.stroke();
    // Restore original values
    ctx.strokeStyle = originalStrokeStyle;
    ctx.lineWidth = originalLineWidth;
    ctx.setLineDash(originalLineDash);
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/opacity.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setOpacity",
    ()=>setOpacity
]);
const setOpacity = ({ ctx, opacity })=>{
    const previousAlpha = ctx.globalAlpha;
    ctx.globalAlpha = previousAlpha * opacity;
    return ()=>{
        ctx.globalAlpha = previousAlpha;
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/transform.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setTransform",
    ()=>setTransform
]);
const setTransform = ({ ctx, transform })=>{
    ctx.setTransform(transform);
    return ()=>{
        ctx.setTransform(new DOMMatrix());
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-element.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "drawElement",
    ()=>drawElement
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$border$2d$radius$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/border-radius.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$border$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-border.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$opacity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/opacity.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$transform$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/transform.js [app-route] (ecmascript)");
;
;
;
;
const drawElement = async ({ dimensions, computedStyle, context, draw, opacity, totalMatrix })=>{
    const background = computedStyle.backgroundColor;
    const borderRadius = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$border$2d$radius$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseBorderRadius"])({
        borderRadius: computedStyle.borderRadius,
        width: dimensions.width,
        height: dimensions.height
    });
    const finishTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$transform$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setTransform"])({
        ctx: context,
        transform: totalMatrix
    });
    const finishBorderRadius = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$border$2d$radius$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setBorderRadius"])({
        ctx: context,
        x: dimensions.left,
        y: dimensions.top,
        width: dimensions.width,
        height: dimensions.height,
        borderRadius
    });
    const finishOpacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$opacity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setOpacity"])({
        ctx: context,
        opacity
    });
    if (background && background !== 'transparent' && !(background.startsWith('rgba') && (background.endsWith(', 0)') || background.endsWith(',0')))) {
        const originalFillStyle = context.fillStyle;
        context.fillStyle = background;
        context.fillRect(dimensions.left, dimensions.top, dimensions.width, dimensions.height);
        context.fillStyle = originalFillStyle;
    }
    await draw({
        dimensions,
        computedStyle,
        contextToDraw: context
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$border$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawBorder"])({
        ctx: context,
        x: dimensions.left,
        y: dimensions.top,
        width: dimensions.width,
        height: dimensions.height,
        borderRadius,
        computedStyle
    });
    finishOpacity();
    finishBorderRadius();
    finishTransform();
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/transform-in-3d.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transformIn3d",
    ()=>transformIn3d
]);
function compileShader(shaderGl, source, type) {
    const shader = shaderGl.createShader(type);
    if (!shader) {
        throw new Error('Could not create shader');
    }
    shaderGl.shaderSource(shader, source);
    shaderGl.compileShader(shader);
    if (!shaderGl.getShaderParameter(shader, shaderGl.COMPILE_STATUS)) {
        const log = shaderGl.getShaderInfoLog(shader);
        shaderGl.deleteShader(shader);
        throw new Error('Shader compile error: ' + log);
    }
    return shader;
}
let helperCanvas = null;
const createHelperCanvas = ({ canvasWidth, canvasHeight })=>{
    if (helperCanvas && helperCanvas.canvas.width >= canvasWidth && helperCanvas.canvas.height >= canvasHeight) {
        // Clear and draw
        helperCanvas.gl.clearColor(0, 0, 0, 0); // Transparent background
        helperCanvas.gl.clear(helperCanvas.gl.COLOR_BUFFER_BIT);
        return helperCanvas;
    }
    const canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    const gl = canvas.getContext('webgl');
    if (!gl) {
        throw new Error('WebGL not supported');
    }
    // Vertex shader - now includes texture coordinates
    const vsSource = `
        attribute vec2 aPosition;
        attribute vec2 aTexCoord;
        uniform mat4 uTransform;
        uniform mat4 uProjection;
        varying vec2 vTexCoord;

        void main() {
            gl_Position = uProjection * uTransform * vec4(aPosition, 0.0, 1.0);
            vTexCoord = aTexCoord;
        }
    `;
    // Fragment shader - now samples from texture
    const fsSource = `
        precision mediump float;
        uniform sampler2D uTexture;
        varying vec2 vTexCoord;

        void main() {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    // Create program
    const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    // Clear and draw
    gl.clearColor(0, 0, 0, 0); // Transparent background
    gl.clear(gl.COLOR_BUFFER_BIT);
    // Enable blending for transparency
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    helperCanvas = {
        canvas,
        gl,
        program
    };
    return helperCanvas;
};
const transformIn3d = ({ canvasWidth, canvasHeight, matrix, sourceCanvas, offsetLeft, offsetTop })=>{
    const { canvas, gl, program } = createHelperCanvas({
        canvasWidth,
        canvasHeight
    });
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    // Create a quad (two triangles) with texture coordinates
    // prettier-ignore
    const vertices = new Float32Array([
        // Position (x, y) + TexCoord (u, v)
        // First:
        offsetLeft,
        offsetTop,
        0,
        0,
        canvasWidth + offsetLeft,
        offsetTop,
        1,
        0,
        offsetLeft,
        canvasHeight + offsetTop,
        0,
        1,
        // Second:
        offsetLeft,
        canvasHeight + offsetTop,
        0,
        1,
        canvasWidth + offsetLeft,
        offsetTop,
        1,
        0,
        canvasWidth + offsetLeft,
        canvasHeight + offsetTop,
        1,
        1
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    const aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
    // Position attribute (2 floats, stride 4 floats, offset 0)
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 4 * 4, 0);
    // Texture coordinate attribute (2 floats, stride 4 floats, offset 2)
    gl.enableVertexAttribArray(aTexCoord);
    gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 4 * 4, 2 * 4);
    // Create and configure texture
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Set texture parameters
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    // Upload the source canvas as a texture
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
    // The transform matrix
    const transformMatrix = matrix.toFloat32Array();
    const zScale = 1000000000; // By default infinite in chrome
    // Create orthographic projection matrix for pixel coordinates
    const projectionMatrix = new Float32Array([
        2 / canvas.width,
        0,
        0,
        0,
        0,
        -2 / canvas.height,
        0,
        0,
        0,
        0,
        -2 / zScale,
        0,
        -1,
        1,
        0,
        1
    ]);
    const uTransform = gl.getUniformLocation(program, 'uTransform');
    const uProjection = gl.getUniformLocation(program, 'uProjection');
    const uTexture = gl.getUniformLocation(program, 'uTexture');
    gl.uniformMatrix4fv(uTransform, false, transformMatrix);
    gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
    gl.uniform1i(uTexture, 0); // Use texture unit 0
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    // Clean up resources to prevent leaks and ensure clean state for reuse
    gl.deleteTexture(texture);
    gl.deleteBuffer(vertexBuffer);
    return canvas;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-element-to-canvas.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "drawElementToCanvas",
    ()=>drawElementToCanvas
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/compose.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$calculate$2d$transforms$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/calculate-transforms.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-element.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$transform$2d$in$2d$3d$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/transform-in-3d.js [app-route] (ecmascript)");
;
;
;
;
const drawElementToCanvas = async ({ element, context, draw, offsetLeft, offsetTop })=>{
    const { totalMatrix, reset, dimensions, opacity, computedStyle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$calculate$2d$transforms$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculateTransforms"])(element);
    if (opacity === 0) {
        reset();
        return 'continue';
    }
    if (dimensions.width <= 0 || dimensions.height <= 0) {
        reset();
        return 'continue';
    }
    if (!totalMatrix.is2D) {
        const canvasOffsetLeft = Math.min(dimensions.left, 0);
        const canvasOffsetTop = Math.min(dimensions.top, 0);
        const tempCanvasWidth = Math.max(dimensions.width, dimensions.right);
        const tempCanvasHeight = Math.max(dimensions.height, dimensions.bottom);
        const tempCanvas = new OffscreenCanvas(tempCanvasWidth, tempCanvasHeight);
        const context2 = tempCanvas.getContext('2d');
        if (!context2) {
            throw new Error('Could not get context');
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compose"])({
            element,
            context: context2,
            offsetLeft: canvasOffsetLeft,
            offsetTop: canvasOffsetTop
        });
        const transformed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$transform$2d$in$2d$3d$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["transformIn3d"])({
            canvasWidth: tempCanvasWidth,
            canvasHeight: tempCanvasHeight,
            matrix: totalMatrix,
            sourceCanvas: tempCanvas,
            offsetLeft: canvasOffsetLeft,
            offsetTop: canvasOffsetTop
        });
        context.drawImage(transformed, 0, 0);
        reset();
        return 'skip-children';
    }
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawElement"])({
        dimensions: new DOMRect(dimensions.left - offsetLeft, dimensions.top - offsetTop, dimensions.width, dimensions.height),
        computedStyle,
        context,
        draw,
        opacity,
        totalMatrix
    });
    reset();
    return 'continue';
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/text/apply-text-transform.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyTextTransform",
    ()=>applyTextTransform
]);
const applyTextTransform = (text, transform)=>{
    if (transform === 'uppercase') {
        return text.toUpperCase();
    }
    if (transform === 'lowercase') {
        return text.toLowerCase();
    }
    if (transform === 'capitalize') {
        return text.replace(/\b\w/g, (char)=>char.toUpperCase());
    }
    return text;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/text/get-collapsed-text.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCollapsedText",
    ()=>getCollapsedText
]);
const getCollapsedText = (span)=>{
    const textNode = span.firstChild;
    if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
        throw new Error('Span must contain a single text node');
    }
    const originalText = textNode.textContent || '';
    let collapsedText = originalText;
    // Helper to measure width
    const measureWidth = (text)=>{
        textNode.textContent = text;
        return span.getBoundingClientRect().width;
    };
    const originalWidth = measureWidth(originalText);
    // Test leading whitespace
    if (/^\s/.test(collapsedText)) {
        const trimmedLeading = collapsedText.replace(/^\s+/, '');
        const newWidth = measureWidth(trimmedLeading);
        if (newWidth === originalWidth) {
            // Whitespace was collapsed by the browser
            collapsedText = trimmedLeading;
        }
    }
    // Test trailing whitespace (on current collapsed text)
    if (/\s$/.test(collapsedText)) {
        const currentWidth = measureWidth(collapsedText);
        const trimmedTrailing = collapsedText.replace(/\s+$/, '');
        const newWidth = measureWidth(trimmedTrailing);
        if (newWidth === currentWidth) {
            // Whitespace was collapsed by the browser
            collapsedText = trimmedTrailing;
        }
    }
    // Test internal duplicate whitespace (on current collapsed text)
    if (/\s\s/.test(collapsedText)) {
        const currentWidth = measureWidth(collapsedText);
        const collapsedInternal = collapsedText.replace(/\s\s+/g, ' ');
        const newWidth = measureWidth(collapsedInternal);
        if (newWidth === currentWidth) {
            // Whitespace was collapsed by the browser
            collapsedText = collapsedInternal;
        }
    }
    // Restore original text
    textNode.textContent = originalText;
    return collapsedText;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/text/find-line-breaks.text.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findLineBreaks",
    ()=>findLineBreaks
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$get$2d$collapsed$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/get-collapsed-text.js [app-route] (ecmascript)");
;
function findLineBreaks(span, rtl) {
    const textNode = span.childNodes[0];
    const originalText = textNode.textContent;
    const originalRect = span.getBoundingClientRect();
    const computedStyle = getComputedStyle(span);
    const segmenter = new Intl.Segmenter('en', {
        granularity: 'word'
    });
    const segments = segmenter.segment(originalText);
    const words = Array.from(segments).map((s)=>s.segment);
    const lines = [];
    let currentLine = '';
    let testText = '';
    let previousRect = originalRect;
    textNode.textContent = '';
    for(let i = 0; i < words.length; i += 1){
        const word = words[i];
        testText += word;
        let wordsToAdd = word;
        while(typeof words[i + 1] !== 'undefined' && words[i + 1].trim() === ''){
            testText += words[i + 1];
            wordsToAdd += words[i + 1];
            i++;
        }
        previousRect = span.getBoundingClientRect();
        textNode.textContent = testText;
        const collapsedText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$get$2d$collapsed$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCollapsedText"])(span);
        textNode.textContent = collapsedText;
        const rect = span.getBoundingClientRect();
        const currentHeight = rect.height;
        // If height changed significantly, we had a line break
        if (previousRect && previousRect.height !== 0 && Math.abs(currentHeight - previousRect.height) > 2) {
            const offsetHorizontal = rtl ? previousRect.right - originalRect.right : previousRect.left - originalRect.left;
            const shouldCollapse = !computedStyle.whiteSpaceCollapse.includes('preserve');
            lines.push({
                text: shouldCollapse ? currentLine.trim() : currentLine,
                offsetTop: currentHeight - previousRect.height,
                offsetHorizontal
            });
            currentLine = wordsToAdd;
        } else {
            currentLine += wordsToAdd;
        }
    }
    // Add the last line
    if (currentLine) {
        textNode.textContent = testText;
        const rects = span.getClientRects();
        const rect = span.getBoundingClientRect();
        const lastRect = rects[rects.length - 1];
        const offsetHorizontal = rtl ? lastRect.right - originalRect.right : lastRect.left - originalRect.left;
        lines.push({
            text: currentLine,
            offsetTop: rect.height - previousRect.height,
            offsetHorizontal
        });
    }
    // Reset to original text
    textNode.textContent = originalText;
    return lines;
}
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/text/draw-text.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "drawText",
    ()=>drawText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$apply$2d$text$2d$transform$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/apply-text-transform.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$find$2d$line$2d$breaks$2e$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/find-line-breaks.text.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$get$2d$collapsed$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/get-collapsed-text.js [app-route] (ecmascript)");
;
;
;
;
const drawText = (span)=>{
    const drawFn = ({ dimensions: rect, computedStyle, contextToDraw })=>{
        const { fontFamily, fontSize, fontWeight, color, lineHeight, direction, writingMode, letterSpacing, textTransform } = computedStyle;
        const isVertical = writingMode !== 'horizontal-tb';
        if (isVertical) {
            // TODO: Only warn once per render.
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].Log.warn({
                logLevel: 'warn',
                tag: '@remotion/web-renderer'
            }, 'Detected "writing-mode" CSS property. Vertical text is not yet supported in @remotion/web-renderer');
            return;
        }
        contextToDraw.save();
        contextToDraw.font = `${fontWeight} ${fontSize} ${fontFamily}`;
        contextToDraw.fillStyle = color;
        contextToDraw.letterSpacing = letterSpacing;
        const fontSizePx = parseFloat(fontSize);
        // TODO: This is not necessarily correct, need to create text and measure to know for sure
        const lineHeightPx = lineHeight === 'normal' ? 1.2 * fontSizePx : parseFloat(lineHeight);
        const baselineOffset = (lineHeightPx - fontSizePx) / 2;
        const isRTL = direction === 'rtl';
        contextToDraw.textAlign = isRTL ? 'right' : 'left';
        contextToDraw.textBaseline = 'top';
        const originalText = span.textContent;
        const collapsedText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$get$2d$collapsed$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCollapsedText"])(span);
        const transformedText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$apply$2d$text$2d$transform$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyTextTransform"])(collapsedText, textTransform);
        span.textContent = transformedText;
        // For RTL text, fill from the right edge instead of left
        const xPosition = isRTL ? rect.right : rect.left;
        const lines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$find$2d$line$2d$breaks$2e$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findLineBreaks"])(span, isRTL);
        let offsetTop = 0;
        for (const line of lines){
            contextToDraw.fillText(line.text, xPosition + line.offsetHorizontal, rect.top + baselineOffset + offsetTop);
            offsetTop += line.offsetTop;
        }
        span.textContent = originalText;
        contextToDraw.restore();
    };
    return drawFn;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/drawing/text/handle-text-node.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleTextNode",
    ()=>handleTextNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2d$to$2d$canvas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-element-to-canvas.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$draw$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/draw-text.js [app-route] (ecmascript)");
;
;
const handleTextNode = async ({ node, context, offsetLeft, offsetTop })=>{
    const span = document.createElement('span');
    const parent = node.parentNode;
    if (!parent) {
        throw new Error('Text node has no parent');
    }
    parent.insertBefore(span, node);
    span.appendChild(node);
    const value = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2d$to$2d$canvas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawElementToCanvas"])({
        context,
        element: span,
        draw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$draw$2d$text$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawText"])(span),
        offsetLeft,
        offsetTop
    });
    // Undo the layout manipulation
    parent.insertBefore(node, span);
    parent.removeChild(span);
    return value;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/walk-tree.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "skipToNextNonDescendant",
    ()=>skipToNextNonDescendant
]);
function skipToNextNonDescendant(treeWalker) {
    // Try to go to next sibling
    if (treeWalker.nextSibling()) {
        return true;
    }
    // No sibling, go up to parent and try to find ancestor's sibling
    while(treeWalker.parentNode()){
        if (treeWalker.nextSibling()) {
            return true;
        }
    }
    // No more nodes
    return false;
}
}),
"[project]/node_modules/@remotion/web-renderer/dist/compose.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compose",
    ()=>compose
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$dom$2d$element$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-dom-element.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2d$to$2d$canvas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/draw-element-to-canvas.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$handle$2d$text$2d$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/drawing/text/handle-text-node.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$walk$2d$tree$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/walk-tree.js [app-route] (ecmascript)");
;
;
;
;
const walkOverNode = ({ node, context, offsetLeft, offsetTop })=>{
    if (node instanceof HTMLElement || node instanceof SVGElement) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$element$2d$to$2d$canvas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawElementToCanvas"])({
            element: node,
            context,
            draw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$draw$2d$dom$2d$element$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["drawDomElement"])(node),
            offsetLeft,
            offsetTop
        });
    }
    if (node instanceof Text) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$drawing$2f$text$2f$handle$2d$text$2d$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleTextNode"])({
            node,
            context,
            offsetLeft,
            offsetTop
        });
    }
    throw new Error('Unknown node type');
};
const compose = async ({ element, context, offsetLeft, offsetTop })=>{
    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (node)=>{
        if (node instanceof Element) {
            // SVG does have children, but we process SVG elements in its
            // entirety
            if (node.parentElement instanceof SVGSVGElement) {
                return NodeFilter.FILTER_REJECT;
            }
            const computedStyle = getComputedStyle(node);
            return computedStyle.display === 'none' ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_ACCEPT;
    });
    while(true){
        const val = await walkOverNode({
            node: treeWalker.currentNode,
            context,
            offsetLeft,
            offsetTop
        });
        if (val === 'skip-children') {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$walk$2d$tree$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["skipToNextNonDescendant"])(treeWalker)) {
                break;
            }
        } else if (!treeWalker.nextNode()) {
            break;
        }
    }
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/take-screenshot.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createFrame",
    ()=>createFrame,
    "takeScreenshot",
    ()=>takeScreenshot
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/compose.js [app-route] (ecmascript)");
;
const createFrame = async ({ div, width, height })=>{
    const canvas = new OffscreenCanvas(width, height);
    const context = canvas.getContext('2d');
    if (!context) {
        throw new Error('Could not get context');
    }
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compose"])({
        element: div,
        context,
        offsetLeft: 0,
        offsetTop: 0
    });
    return canvas;
};
const takeScreenshot = async ({ div, width, height, imageFormat })=>{
    const frame = await createFrame({
        div,
        width,
        height
    });
    const imageData = await frame.convertToBlob({
        type: `image/${imageFormat}`
    });
    return imageData;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/throttle-progress.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createThrottledProgressCallback",
    ()=>createThrottledProgressCallback
]);
const DEFAULT_THROTTLE_MS = 250;
const createThrottledProgressCallback = (callback, throttleMs = DEFAULT_THROTTLE_MS)=>{
    if (!callback) {
        return null;
    }
    let lastCallTime = 0;
    let pendingUpdate = null;
    let timeoutId = null;
    const throttled = (progress)=>{
        const now = Date.now();
        const timeSinceLastCall = now - lastCallTime;
        // Always store the latest progress
        pendingUpdate = progress;
        // If enough time has passed, call immediately
        if (timeSinceLastCall >= throttleMs) {
            lastCallTime = now;
            callback(progress);
            pendingUpdate = null;
            // Clear any pending timeout
            if (timeoutId !== null) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
        } else if (timeoutId === null) {
            // Schedule a call for when the throttle period expires
            const remainingTime = throttleMs - timeSinceLastCall;
            timeoutId = setTimeout(()=>{
                if (pendingUpdate !== null) {
                    lastCallTime = Date.now();
                    callback(pendingUpdate);
                    pendingUpdate = null;
                }
                timeoutId = null;
            }, remainingTime);
        }
    };
    return throttled;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/validate-video-frame.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Validates and processes a VideoFrame returned from an onFrame callback
 */ /**
 * Validates that a VideoFrame returned from onFrame callback matches expected dimensions and timestamp
 * If validation fails, closes both frames and throws an error
 */ __turbopack_context__.s([
    "validateVideoFrame",
    ()=>validateVideoFrame
]);
const validateVideoFrame = ({ originalFrame, returnedFrame, expectedWidth, expectedHeight, expectedTimestamp })=>{
    // Validate that the returned frame is actually a VideoFrame
    if (!(returnedFrame instanceof VideoFrame)) {
        originalFrame.close();
        throw new Error('onFrame callback must return a VideoFrame or void');
    }
    // Check if it's the same frame (no validation needed)
    if (returnedFrame === originalFrame) {
        return returnedFrame;
    }
    // Validate dimensions
    if (returnedFrame.displayWidth !== expectedWidth || returnedFrame.displayHeight !== expectedHeight) {
        originalFrame.close();
        returnedFrame.close();
        throw new Error(`VideoFrame dimensions mismatch: expected ${expectedWidth}x${expectedHeight}, got ${returnedFrame.displayWidth}x${returnedFrame.displayHeight}`);
    }
    // Validate timestamp
    if (returnedFrame.timestamp !== expectedTimestamp) {
        originalFrame.close();
        returnedFrame.close();
        throw new Error(`VideoFrame timestamp mismatch: expected ${expectedTimestamp}, got ${returnedFrame.timestamp}`);
    }
    // If we got a different frame but it's valid, close the original and use the new one
    originalFrame.close();
    return returnedFrame;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/wait-for-ready.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "waitForReady",
    ()=>waitForReady
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$with$2d$resolvers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/with-resolvers.js [app-route] (ecmascript)");
;
const waitForReady = ({ timeoutInMilliseconds, scope, signal, apiName })=>{
    const start = Date.now();
    const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$with$2d$resolvers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withResolvers"])();
    let cancelled = false;
    const check = ()=>{
        if (cancelled) {
            return;
        }
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            cancelled = true;
            reject(new Error(`${apiName}() was cancelled`));
            return;
        }
        if (scope.remotion_renderReady === true) {
            resolve();
            return;
        }
        if (scope.remotion_cancelledError !== undefined) {
            cancelled = true;
            reject(scope.remotion_cancelledError);
            return;
        }
        if (Date.now() - start > timeoutInMilliseconds + 3000) {
            cancelled = true;
            reject(new Error(Object.values(scope.remotion_delayRenderTimeouts).map((d)=>d.label).join(', ')));
            return;
        }
        requestAnimationFrame(check);
    };
    requestAnimationFrame(check);
    return promise;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/web-fs-target.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanupStaleOpfsFiles",
    ()=>cleanupStaleOpfsFiles,
    "createWebFsTarget",
    ()=>createWebFsTarget
]);
let sessionId = null;
const getPrefix = ()=>{
    if (!sessionId) {
        sessionId = crypto.randomUUID();
    }
    return `__remotion_render:${sessionId}:`;
};
const cleanupStaleOpfsFiles = async ()=>{
    try {
        const root = await navigator.storage.getDirectory();
        for await (const [name] of root.entries()){
            if (name.startsWith('__remotion_render:') && !name.startsWith(getPrefix())) {
                await root.removeEntry(name);
            }
        }
    } catch (_a) {
    // Ignore, could already be closed
    }
};
const createWebFsTarget = async ()=>{
    const directoryHandle = await navigator.storage.getDirectory();
    const filename = `${getPrefix()}${crypto.randomUUID()}`;
    const fileHandle = await directoryHandle.getFileHandle(filename, {
        create: true
    });
    const writable = await fileHandle.createWritable();
    const stream = new WritableStream({
        async write (chunk) {
            await writable.seek(chunk.position);
            await writable.write(chunk);
        }
    });
    const getBlob = async ()=>{
        const handle = await directoryHandle.getFileHandle(filename);
        return handle.getFile();
    };
    const close = ()=>writable.close();
    return {
        stream,
        getBlob,
        close
    };
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/render-media-on-web.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "renderMediaOnWeb",
    ()=>renderMediaOnWeb
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$media$2d$source$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/media-source.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/target.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/output.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$add$2d$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/add-sample.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$artifact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/artifact.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$audio$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/audio.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$can$2d$use$2d$webfs$2d$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/can-use-webfs-target.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$create$2d$scaffold$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/create-scaffold.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$frame$2d$range$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/frame-range.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$get$2d$audio$2d$encoding$2d$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/get-audio-encoding-config.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/mediabunny-mappings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/render-operations-queue.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$take$2d$screenshot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/take-screenshot.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$throttle$2d$progress$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/throttle-progress.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$validate$2d$video$2d$frame$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/validate-video-frame.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$wait$2d$for$2d$ready$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/wait-for-ready.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$web$2d$fs$2d$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/web-fs-target.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
// TODO: More containers
// TODO: Audio
// TODO: Metadata
// TODO: Validating inputs
// TODO: Apply defaultCodec
const internalRenderMediaOnWeb = async ({ composition, inputProps, delayRenderTimeoutInMilliseconds, logLevel, mediaCacheSizeInBytes, schema, codec, container, signal, onProgress, hardwareAcceleration, keyframeIntervalInSeconds, videoBitrate, frameRange, transparent, onArtifact, onFrame, outputTarget: userDesiredOutputTarget })=>{
    var _a, _b, _c, _d, _e, _f, _g;
    const outputTarget = userDesiredOutputTarget === null ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$can$2d$use$2d$webfs$2d$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["canUseWebFsWriter"])() ? 'web-fs' : 'arraybuffer' : userDesiredOutputTarget;
    if (outputTarget === 'web-fs') {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$web$2d$fs$2d$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cleanupStaleOpfsFiles"])();
    }
    const cleanupFns = [];
    const format = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["containerToMediabunnyContainer"])(container);
    if (codec && !format.getSupportedCodecs().includes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codecToMediabunnyCodec"])(codec))) {
        return Promise.reject(new Error(`Codec ${codec} is not supported for container ${container}`));
    }
    const resolved = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].resolveVideoConfig({
        calculateMetadata: (_a = composition.calculateMetadata) !== null && _a !== void 0 ? _a : null,
        signal: signal !== null && signal !== void 0 ? signal : new AbortController().signal,
        defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        compositionId: composition.id,
        compositionDurationInFrames: (_c = composition.durationInFrames) !== null && _c !== void 0 ? _c : null,
        compositionFps: (_d = composition.fps) !== null && _d !== void 0 ? _d : null,
        compositionHeight: (_e = composition.height) !== null && _e !== void 0 ? _e : null,
        compositionWidth: (_f = composition.width) !== null && _f !== void 0 ? _f : null
    });
    const realFrameRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$frame$2d$range$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRealFrameRange"])(resolved.durationInFrames, frameRange);
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        return Promise.reject(new Error('renderMediaOnWeb() was cancelled'));
    }
    const { delayRenderScope, div, cleanupScaffold, timeUpdater, collectAssets } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$create$2d$scaffold$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createScaffold"])({
        width: resolved.width,
        height: resolved.height,
        fps: resolved.fps,
        durationInFrames: resolved.durationInFrames,
        Component: composition.component,
        resolvedProps: resolved.props,
        id: resolved.id,
        delayRenderTimeoutInMilliseconds,
        logLevel,
        mediaCacheSizeInBytes,
        schema: schema !== null && schema !== void 0 ? schema : null,
        audioEnabled: true,
        videoEnabled: true,
        initialFrame: 0,
        defaultCodec: resolved.defaultCodec,
        defaultOutName: resolved.defaultOutName
    });
    const artifactsHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$artifact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleArtifacts"])();
    cleanupFns.push(()=>{
        cleanupScaffold();
    });
    const webFsTarget = outputTarget === 'web-fs' ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$web$2d$fs$2d$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createWebFsTarget"])() : null;
    const target = webFsTarget ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StreamTarget"](webFsTarget.stream) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BufferTarget"]();
    const output = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Output"]({
        format,
        target
    });
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$wait$2d$for$2d$ready$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["waitForReady"])({
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
            scope: delayRenderScope,
            signal,
            apiName: 'renderMediaOnWeb'
        });
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        cleanupFns.push(()=>{
            if (output.state === 'finalized' || output.state === 'canceled') {
                return;
            }
            output.cancel();
        });
        const videoSampleSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$media$2d$source$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["VideoSampleSource"]({
            codec: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codecToMediabunnyCodec"])(codec),
            bitrate: typeof videoBitrate === 'number' ? videoBitrate : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getQualityForWebRendererQuality"])(videoBitrate),
            sizeChangeBehavior: 'deny',
            hardwareAcceleration,
            latencyMode: 'quality',
            keyFrameInterval: keyframeIntervalInSeconds,
            alpha: transparent ? 'keep' : 'discard'
        });
        cleanupFns.push(()=>{
            videoSampleSource.close();
        });
        output.addVideoTrack(videoSampleSource);
        // TODO: Should be able to customize
        const defaultAudioEncodingConfig = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$get$2d$audio$2d$encoding$2d$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultAudioEncodingConfig"])();
        if (!defaultAudioEncodingConfig) {
            return Promise.reject(new Error('No default audio encoding config found'));
        }
        const audioSampleSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$media$2d$source$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AudioSampleSource"](defaultAudioEncodingConfig);
        cleanupFns.push(()=>{
            audioSampleSource.close();
        });
        output.addAudioTrack(audioSampleSource);
        await output.start();
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        const progress = {
            renderedFrames: 0,
            encodedFrames: 0
        };
        const throttledOnProgress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$throttle$2d$progress$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createThrottledProgressCallback"])(onProgress);
        for(let frame = realFrameRange[0]; frame <= realFrameRange[1]; frame++){
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            (_g = timeUpdater.current) === null || _g === void 0 ? void 0 : _g.update(frame);
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$wait$2d$for$2d$ready$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["waitForReady"])({
                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
                scope: delayRenderScope,
                signal,
                apiName: 'renderMediaOnWeb'
            });
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            const imageData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$take$2d$screenshot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createFrame"])({
                div,
                width: resolved.width,
                height: resolved.height
            });
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            const assets = collectAssets.current.collectAssets();
            if (onArtifact) {
                await artifactsHandler.handle({
                    imageData,
                    frame,
                    assets,
                    onArtifact
                });
            }
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            const audio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$audio$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyInlineAudio"])({
                assets,
                fps: resolved.fps,
                frame
            });
            const timestamp = Math.round((frame - realFrameRange[0]) / resolved.fps * 1000000);
            const videoFrame = new VideoFrame(imageData, {
                timestamp
            });
            progress.renderedFrames++;
            throttledOnProgress === null || throttledOnProgress === void 0 ? void 0 : throttledOnProgress({
                ...progress
            });
            // Process frame through onFrame callback if provided
            let frameToEncode = videoFrame;
            if (onFrame) {
                const returnedFrame = await onFrame(videoFrame);
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    throw new Error('renderMediaOnWeb() was cancelled');
                }
                frameToEncode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$validate$2d$video$2d$frame$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateVideoFrame"])({
                    originalFrame: videoFrame,
                    returnedFrame,
                    expectedWidth: resolved.width,
                    expectedHeight: resolved.height,
                    expectedTimestamp: timestamp
                });
            }
            await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$add$2d$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addVideoSampleAndCloseFrame"])(frameToEncode, videoSampleSource),
                audio ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$add$2d$sample$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addAudioSample"])(audio, audioSampleSource) : Promise.resolve()
            ]);
            progress.encodedFrames++;
            throttledOnProgress === null || throttledOnProgress === void 0 ? void 0 : throttledOnProgress({
                ...progress
            });
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
        }
        // Call progress one final time to ensure final state is reported
        onProgress === null || onProgress === void 0 ? void 0 : onProgress({
            ...progress
        });
        videoSampleSource.close();
        audioSampleSource.close();
        await output.finalize();
        const mimeType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMimeType"])(container);
        if (webFsTarget) {
            await webFsTarget.close();
            return {
                getBlob: ()=>{
                    return webFsTarget.getBlob();
                }
            };
        }
        if (!(target instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BufferTarget"])) {
            throw new Error('Expected target to be a BufferTarget');
        }
        return {
            getBlob: ()=>{
                if (!target.buffer) {
                    throw new Error('The resulting buffer is empty');
                }
                return Promise.resolve(new Blob([
                    target.buffer
                ], {
                    type: mimeType
                }));
            }
        };
    } finally{
        cleanupFns.forEach((fn)=>fn());
    }
};
const renderMediaOnWeb = (options)=>{
    var _a, _b;
    const container = (_a = options.container) !== null && _a !== void 0 ? _a : 'mp4';
    const codec = (_b = options.codec) !== null && _b !== void 0 ? _b : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$mediabunny$2d$mappings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultVideoCodecForContainer"])(container);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref.catch(()=>Promise.resolve()).then(()=>{
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        return internalRenderMediaOnWeb({
            ...options,
            delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
            logLevel: (_b = options.logLevel) !== null && _b !== void 0 ? _b : 'info',
            schema: (_c = options.schema) !== null && _c !== void 0 ? _c : undefined,
            mediaCacheSizeInBytes: (_d = options.mediaCacheSizeInBytes) !== null && _d !== void 0 ? _d : null,
            codec,
            container,
            signal: (_e = options.signal) !== null && _e !== void 0 ? _e : null,
            onProgress: (_f = options.onProgress) !== null && _f !== void 0 ? _f : null,
            hardwareAcceleration: (_g = options.hardwareAcceleration) !== null && _g !== void 0 ? _g : 'no-preference',
            keyframeIntervalInSeconds: (_h = options.keyframeIntervalInSeconds) !== null && _h !== void 0 ? _h : 5,
            videoBitrate: (_j = options.videoBitrate) !== null && _j !== void 0 ? _j : 'medium',
            frameRange: (_k = options.frameRange) !== null && _k !== void 0 ? _k : null,
            transparent: (_l = options.transparent) !== null && _l !== void 0 ? _l : false,
            onArtifact: (_m = options.onArtifact) !== null && _m !== void 0 ? _m : null,
            onFrame: (_o = options.onFrame) !== null && _o !== void 0 ? _o : null,
            outputTarget: (_p = options.outputTarget) !== null && _p !== void 0 ? _p : null
        });
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/render-still-on-web.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "renderStillOnWeb",
    ()=>renderStillOnWeb
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/remotion/dist/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$artifact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/artifact.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$create$2d$scaffold$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/create-scaffold.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/render-operations-queue.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$take$2d$screenshot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/take-screenshot.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$wait$2d$for$2d$ready$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/wait-for-ready.js [app-route] (ecmascript)");
;
;
;
;
;
;
async function internalRenderStillOnWeb({ frame, delayRenderTimeoutInMilliseconds, logLevel, inputProps, schema, imageFormat, mediaCacheSizeInBytes, composition, signal, onArtifact }) {
    var _a, _b, _c, _d, _e, _f;
    const resolved = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$remotion$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Internals"].resolveVideoConfig({
        calculateMetadata: (_a = composition.calculateMetadata) !== null && _a !== void 0 ? _a : null,
        signal: signal !== null && signal !== void 0 ? signal : new AbortController().signal,
        defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        compositionId: composition.id,
        compositionDurationInFrames: (_c = composition.durationInFrames) !== null && _c !== void 0 ? _c : null,
        compositionFps: (_d = composition.fps) !== null && _d !== void 0 ? _d : null,
        compositionHeight: (_e = composition.height) !== null && _e !== void 0 ? _e : null,
        compositionWidth: (_f = composition.width) !== null && _f !== void 0 ? _f : null
    });
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        return Promise.reject(new Error('renderStillOnWeb() was cancelled'));
    }
    const { delayRenderScope, div, cleanupScaffold, collectAssets } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$create$2d$scaffold$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createScaffold"])({
        width: resolved.width,
        height: resolved.height,
        delayRenderTimeoutInMilliseconds,
        logLevel,
        resolvedProps: resolved.props,
        id: resolved.id,
        mediaCacheSizeInBytes,
        audioEnabled: false,
        Component: composition.component,
        videoEnabled: true,
        durationInFrames: resolved.durationInFrames,
        fps: resolved.fps,
        schema: schema !== null && schema !== void 0 ? schema : null,
        initialFrame: frame,
        defaultCodec: resolved.defaultCodec,
        defaultOutName: resolved.defaultOutName
    });
    const artifactsHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$artifact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleArtifacts"])();
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$wait$2d$for$2d$ready$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["waitForReady"])({
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
            scope: delayRenderScope,
            signal,
            apiName: 'renderStillOnWeb'
        });
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        const imageData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$take$2d$screenshot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["takeScreenshot"])({
            div,
            width: resolved.width,
            height: resolved.height,
            imageFormat
        });
        const assets = collectAssets.current.collectAssets();
        if (onArtifact) {
            await artifactsHandler.handle({
                imageData,
                frame,
                assets,
                onArtifact
            });
        }
        return imageData;
    } finally{
        cleanupScaffold();
    }
}
const renderStillOnWeb = (options)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref.catch(()=>Promise.resolve()).then(()=>{
        var _a, _b, _c, _d, _e, _f;
        return internalRenderStillOnWeb({
            ...options,
            delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
            logLevel: (_b = options.logLevel) !== null && _b !== void 0 ? _b : 'info',
            schema: (_c = options.schema) !== null && _c !== void 0 ? _c : undefined,
            mediaCacheSizeInBytes: (_d = options.mediaCacheSizeInBytes) !== null && _d !== void 0 ? _d : null,
            signal: (_e = options.signal) !== null && _e !== void 0 ? _e : null,
            onArtifact: (_f = options.onArtifact) !== null && _f !== void 0 ? _f : null
        });
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$operations$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["onlyOneRenderAtATimeQueue"].ref;
};
}),
"[project]/node_modules/@remotion/web-renderer/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "renderMediaOnWeb",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$media$2d$on$2d$web$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["renderMediaOnWeb"],
    "renderStillOnWeb",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$still$2d$on$2d$web$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["renderStillOnWeb"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$media$2d$on$2d$web$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/render-media-on-web.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$remotion$2f$web$2d$renderer$2f$dist$2f$render$2d$still$2d$on$2d$web$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@remotion/web-renderer/dist/render-still-on-web.js [app-route] (ecmascript)");
}),
"[project]/node_modules/isexe/windows.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = isexe;
isexe.sync = sync;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
        return true;
    }
    pathext = pathext.split(';');
    if (pathext.indexOf('') !== -1) {
        return true;
    }
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
            return true;
        }
    }
    return false;
}
function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
    }
    return checkPathExt(path, options);
}
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
}
}),
"[project]/node_modules/isexe/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var core;
if ("TURBOPACK compile-time truthy", 1) {
    core = __turbopack_context__.r("[project]/node_modules/isexe/windows.js [app-route] (ecmascript)");
} else //TURBOPACK unreachable
;
module.exports = isexe;
isexe.sync = sync;
function isexe(path, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== 'function') {
            throw new TypeError('callback not provided');
        }
        return new Promise(function(resolve, reject) {
            isexe(path, options || {}, function(er, is) {
                if (er) {
                    reject(er);
                } else {
                    resolve(is);
                }
            });
        });
    }
    core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === 'EACCES' || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === 'EACCES') {
            return false;
        } else {
            throw er;
        }
    }
}
}),
"[project]/node_modules/which/which.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const COLON = ("TURBOPACK compile-time truthy", 1) ? ';' : "TURBOPACK unreachable";
const isexe = __turbopack_context__.r("[project]/node_modules/isexe/index.js [app-route] (ecmascript)");
const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: 'ENOENT'
    });
const getPathInfo = (cmd, opt)=>{
    const colon = opt.colon || COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ''
    ] : [
        // windows always checks the cwd first
        ...("TURBOPACK compile-time truthy", 1) ? [
            process.cwd()
        ] : "TURBOPACK unreachable",
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ '').split(colon)
    ];
    const pathExtExe = ("TURBOPACK compile-time truthy", 1) ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : "TURBOPACK unreachable";
    const pathExt = ("TURBOPACK compile-time truthy", 1) ? pathExtExe.split(colon) : "TURBOPACK unreachable";
    if ("TURBOPACK compile-time truthy", 1) {
        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
    }
    return {
        pathEnv,
        pathExt,
        pathExtExe
    };
};
const which = (cmd, opt, cb)=>{
    if (typeof opt === 'function') {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i)=>new Promise((resolve, reject)=>{
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
            if (ii === pathExt.length) return resolve(step(i + 1));
            const ext = pathExt[ii];
            isexe(p + ext, {
                pathExt: pathExtExe
            }, (er, is)=>{
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
};
const whichSync = (cmd, opt)=>{
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for(let i = 0; i < pathEnv.length; i++){
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(let j = 0; j < pathExt.length; j++){
            const cur = p + pathExt[j];
            try {
                const is = isexe.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
};
module.exports = which;
which.sync = whichSync;
}),
"[project]/node_modules/path-key/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const pathKey = (options = {})=>{
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== 'win32') {
        return 'PATH';
    }
    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
};
module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports.default = pathKey;
}),
"[project]/node_modules/cross-spawn/lib/util/resolveCommand.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const which = __turbopack_context__.r("[project]/node_modules/which/which.js [app-route] (ecmascript)");
const getPathKey = __turbopack_context__.r("[project]/node_modules/path-key/index.js [app-route] (ecmascript)");
function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
        /* Empty */ }
    }
    let resolved;
    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({
                env
            })],
            pathExt: withoutPathExt ? path.delimiter : undefined
        });
    } catch (e) {
    /* Empty */ } finally{
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }
    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }
    return resolved;
}
function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
module.exports = resolveCommand;
}),
"[project]/node_modules/cross-spawn/lib/util/escape.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');
    return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;
    // Algorithm below is based on https://qntm.org/cmd
    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input
    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information
    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(?=(\\+?)?)\1$/, '$1$1');
    // All other backslashes occur literally
    // Quote the whole thing:
    arg = `"${arg}"`;
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');
    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }
    return arg;
}
module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;
}),
"[project]/node_modules/cross-spawn/lib/util/readShebang.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const shebangCommand = __turbopack_context__.r("[project]/node_modules/shebang-command/index.js [app-route] (ecmascript)");
function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) {}
    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}
module.exports = readShebang;
}),
"[project]/node_modules/cross-spawn/lib/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const resolveCommand = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/resolveCommand.js [app-route] (ecmascript)");
const escape = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/escape.js [app-route] (ecmascript)");
const readShebang = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/readShebang.js [app-route] (ecmascript)");
const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
    }
    return parsed.file;
}
function parseNonShell(parsed) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);
    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);
    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);
        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [
            parsed.command
        ].concat(parsed.args).join(' ');
        parsed.args = [
            '/d',
            '/s',
            '/c',
            `"${shellCommand}"`
        ];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }
    return parsed;
}
function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }
    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original
    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args
        }
    };
    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}
module.exports = parse;
}),
"[project]/node_modules/cross-spawn/lib/enoent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const isWin = process.platform === 'win32';
function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
    });
}
function hookChildProcess(cp, parsed) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed);
            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }
        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}
function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }
    return null;
}
function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }
    return null;
}
module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
};
}),
"[project]/node_modules/cross-spawn/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const cp = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
const parse = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/parse.js [app-route] (ecmascript)");
const enoent = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/enoent.js [app-route] (ecmascript)");
function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
}
function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
}
module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;
module.exports._parse = parse;
module.exports._enoent = enoent;
}),
"[project]/node_modules/shebang-regex/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = /^#!(.*)/;
}),
"[project]/node_modules/shebang-command/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const shebangRegex = __turbopack_context__.r("[project]/node_modules/shebang-regex/index.js [app-route] (ecmascript)");
module.exports = (string = '')=>{
    const match = string.match(shebangRegex);
    if (!match) {
        return null;
    }
    const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
    const binary = path.split('/').pop();
    if (binary === 'env') {
        return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
};
}),
"[project]/node_modules/strip-final-newline/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (input)=>{
    const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
    const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();
    if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
    }
    if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
    }
    return input;
};
}),
"[project]/node_modules/npm-run-path/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const pathKey = __turbopack_context__.r("[project]/node_modules/path-key/index.js [app-route] (ecmascript)");
const npmRunPath = (options)=>{
    options = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options
    };
    let previous;
    let cwdPath = path.resolve(options.cwd);
    const result = [];
    while(previous !== cwdPath){
        result.push(path.join(cwdPath, 'node_modules/.bin'));
        previous = cwdPath;
        cwdPath = path.resolve(cwdPath, '..');
    }
    // Ensure the running `node` binary is used
    const execPathDir = path.resolve(options.cwd, options.execPath, '..');
    result.push(execPathDir);
    return result.concat(options.path).join(path.delimiter);
};
module.exports = npmRunPath;
// TODO: Remove this for the next major release
module.exports.default = npmRunPath;
module.exports.env = (options)=>{
    options = {
        env: process.env,
        ...options
    };
    const env = {
        ...options.env
    };
    const path = pathKey({
        env
    });
    options.path = env[path];
    env[path] = module.exports(options);
    return env;
};
}),
"[project]/node_modules/mimic-fn/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mimicFn = (to, from)=>{
    for (const prop of Reflect.ownKeys(from)){
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
};
module.exports = mimicFn;
// TODO: Remove this for the next major release
module.exports.default = mimicFn;
}),
"[project]/node_modules/onetime/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mimicFn = __turbopack_context__.r("[project]/node_modules/mimic-fn/index.js [app-route] (ecmascript)");
const calledFunctions = new WeakMap();
const onetime = (function_, options = {})=>{
    if (typeof function_ !== 'function') {
        throw new TypeError('Expected a function');
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || '<anonymous>';
    const onetime = function(...arguments_) {
        calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
        } else if (options.throw === true) {
            throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
    };
    mimicFn(onetime, function_);
    calledFunctions.set(onetime, callCount);
    return onetime;
};
module.exports = onetime;
// TODO: Remove this for the next major release
module.exports.default = onetime;
module.exports.callCount = (function_)=>{
    if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
};
}),
"[project]/node_modules/human-signals/build/src/core.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SIGNALS = void 0;
const SIGNALS = [
    {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
    },
    {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
    },
    {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
    },
    {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
    },
    {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
    },
    {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
    },
    {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
    },
    {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
    },
    {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
    },
    {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
    },
    {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
    },
    {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
    },
    {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
    },
    {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
    },
    {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
    },
    {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
    },
    {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
    },
    {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: "Paused using CTRL-Z or \"suspend\"",
        standard: "posix"
    },
    {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
    },
    {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
    },
    {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
    },
    {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
    },
    {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
    },
    {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
    },
    {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
    },
    {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
    },
    {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
    },
    {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
    },
    {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
    },
    {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
    },
    {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
    }
];
exports.SIGNALS = SIGNALS; //# sourceMappingURL=core.js.map
}),
"[project]/node_modules/human-signals/build/src/realtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SIGRTMAX = exports.getRealtimeSignals = void 0;
const getRealtimeSignals = function() {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({
        length
    }, getRealtimeSignal);
};
exports.getRealtimeSignals = getRealtimeSignals;
const getRealtimeSignal = function(value, index) {
    return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
    };
};
const SIGRTMIN = 34;
const SIGRTMAX = 64;
exports.SIGRTMAX = SIGRTMAX; //# sourceMappingURL=realtime.js.map
}),
"[project]/node_modules/human-signals/build/src/signals.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSignals = void 0;
var _os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
var _core = __turbopack_context__.r("[project]/node_modules/human-signals/build/src/core.js [app-route] (ecmascript)");
var _realtime = __turbopack_context__.r("[project]/node_modules/human-signals/build/src/realtime.js [app-route] (ecmascript)");
const getSignals = function() {
    const realtimeSignals = (0, _realtime.getRealtimeSignals)();
    const signals = [
        ..._core.SIGNALS,
        ...realtimeSignals
    ].map(normalizeSignal);
    return signals;
};
exports.getSignals = getSignals;
const normalizeSignal = function({ name, number: defaultNumber, description, action, forced = false, standard }) {
    const { signals: { [name]: constantSignal } } = _os.constants;
    const supported = constantSignal !== undefined;
    const number = supported ? constantSignal : defaultNumber;
    return {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
    };
}; //# sourceMappingURL=signals.js.map
}),
"[project]/node_modules/human-signals/build/src/main.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signalsByNumber = exports.signalsByName = void 0;
var _os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
var _signals = __turbopack_context__.r("[project]/node_modules/human-signals/build/src/signals.js [app-route] (ecmascript)");
var _realtime = __turbopack_context__.r("[project]/node_modules/human-signals/build/src/realtime.js [app-route] (ecmascript)");
const getSignalsByName = function() {
    const signals = (0, _signals.getSignals)();
    return signals.reduce(getSignalByName, {});
};
const getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
    return {
        ...signalByNameMemo,
        [name]: {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        }
    };
};
const signalsByName = getSignalsByName();
exports.signalsByName = signalsByName;
const getSignalsByNumber = function() {
    const signals = (0, _signals.getSignals)();
    const length = _realtime.SIGRTMAX + 1;
    const signalsA = Array.from({
        length
    }, (value, number)=>getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
};
const getSignalByNumber = function(number, signals) {
    const signal = findSignalByNumber(number, signals);
    if (signal === undefined) {
        return {};
    }
    const { name, description, supported, action, forced, standard } = signal;
    return {
        [number]: {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        }
    };
};
const findSignalByNumber = function(number, signals) {
    const signal = signals.find(({ name })=>_os.constants.signals[name] === number);
    if (signal !== undefined) {
        return signal;
    }
    return signals.find((signalA)=>signalA.number === number);
};
const signalsByNumber = getSignalsByNumber();
exports.signalsByNumber = signalsByNumber; //# sourceMappingURL=main.js.map
}),
"[project]/node_modules/execa/lib/error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { signalsByName } = __turbopack_context__.r("[project]/node_modules/human-signals/build/src/main.js [app-route] (ecmascript)");
const getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })=>{
    if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
        return 'was canceled';
    }
    if (errorCode !== undefined) {
        return `failed with ${errorCode}`;
    }
    if (signal !== undefined) {
        return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== undefined) {
        return `failed with exit code ${exitCode}`;
    }
    return 'failed';
};
const makeError = ({ stdout, stderr, all, error, signal, exitCode, command, escapedCommand, timedOut, isCanceled, killed, parsed: { options: { timeout } } })=>{
    // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
    // We normalize them to `undefined`
    exitCode = exitCode === null ? undefined : exitCode;
    signal = signal === null ? undefined : signal;
    const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({
        timedOut,
        timeout,
        errorCode,
        signal,
        signalDescription,
        exitCode,
        isCanceled
    });
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === '[object Error]';
    const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [
        shortMessage,
        stderr,
        stdout
    ].filter(Boolean).join('\n');
    if (isError) {
        error.originalMessage = error.message;
        error.message = message;
    } else {
        error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== undefined) {
        error.all = all;
    }
    if ('bufferedData' in error) {
        delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
};
module.exports = makeError;
}),
"[project]/node_modules/execa/lib/stdio.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const aliases = [
    'stdin',
    'stdout',
    'stderr'
];
const hasAlias = (options)=>aliases.some((alias)=>options[alias] !== undefined);
const normalizeStdio = (options)=>{
    if (!options) {
        return;
    }
    const { stdio } = options;
    if (stdio === undefined) {
        return aliases.map((alias)=>options[alias]);
    }
    if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias)=>`\`${alias}\``).join(', ')}`);
    }
    if (typeof stdio === 'string') {
        return stdio;
    }
    if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({
        length
    }, (value, index)=>stdio[index]);
};
module.exports = normalizeStdio;
// `ipc` is pushed unless it is already present
module.exports.node = (options)=>{
    const stdio = normalizeStdio(options);
    if (stdio === 'ipc') {
        return 'ipc';
    }
    if (stdio === undefined || typeof stdio === 'string') {
        return [
            stdio,
            stdio,
            stdio,
            'ipc'
        ];
    }
    if (stdio.includes('ipc')) {
        return stdio;
    }
    return [
        ...stdio,
        'ipc'
    ];
};
}),
"[project]/node_modules/execa/lib/kill.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const onExit = __turbopack_context__.r("[project]/node_modules/execa/node_modules/signal-exit/index.js [app-route] (ecmascript)");
const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = (kill, signal = 'SIGTERM', options = {})=>{
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
};
const setKillTimeout = (kill, signal, options, killResult)=>{
    if (!shouldForceKill(signal, options, killResult)) {
        return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(()=>{
        kill('SIGKILL');
    }, timeout);
    // Guarded because there's no `.unref()` when `execa` is used in the renderer
    // process in Electron. This cannot be tested since we don't run tests in
    // Electron.
    // istanbul ignore else
    if (t.unref) {
        t.unref();
    }
};
const shouldForceKill = (signal, { forceKillAfterTimeout }, killResult)=>{
    return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};
const isSigterm = (signal)=>{
    return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
};
const getForceKillAfterTimeout = ({ forceKillAfterTimeout = true })=>{
    if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
};
// `childProcess.cancel()`
const spawnedCancel = (spawned, context)=>{
    const killResult = spawned.kill();
    if (killResult) {
        context.isCanceled = true;
    }
};
const timeoutKill = (spawned, signal, reject)=>{
    spawned.kill(signal);
    reject(Object.assign(new Error('Timed out'), {
        timedOut: true,
        signal
    }));
};
// `timeout` option handling
const setupTimeout = (spawned, { timeout, killSignal = 'SIGTERM' }, spawnedPromise)=>{
    if (timeout === 0 || timeout === undefined) {
        return spawnedPromise;
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject)=>{
        timeoutId = setTimeout(()=>{
            timeoutKill(spawned, killSignal, reject);
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(()=>{
        clearTimeout(timeoutId);
    });
    return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
    ]);
};
const validateTimeout = ({ timeout })=>{
    if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
};
// `cleanup` option handling
const setExitHandler = async (spawned, { cleanup, detached }, timedPromise)=>{
    if (!cleanup || detached) {
        return timedPromise;
    }
    const removeExitHandler = onExit(()=>{
        spawned.kill();
    });
    return timedPromise.finally(()=>{
        removeExitHandler();
    });
};
module.exports = {
    spawnedKill,
    spawnedCancel,
    setupTimeout,
    validateTimeout,
    setExitHandler
};
}),
"[project]/node_modules/execa/lib/stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const isStream = __turbopack_context__.r("[project]/node_modules/is-stream/index.js [app-route] (ecmascript)");
const getStream = __turbopack_context__.r("[project]/node_modules/execa/node_modules/get-stream/index.js [app-route] (ecmascript)");
const mergeStream = __turbopack_context__.r("[project]/node_modules/merge-stream/index.js [app-route] (ecmascript)");
// `input` option
const handleInput = (spawned, input)=>{
    // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852
    // @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0
    if (input === undefined || spawned.stdin === undefined) {
        return;
    }
    if (isStream(input)) {
        input.pipe(spawned.stdin);
    } else {
        spawned.stdin.end(input);
    }
};
// `all` interleaves `stdout` and `stderr`
const makeAllStream = (spawned, { all })=>{
    if (!all || !spawned.stdout && !spawned.stderr) {
        return;
    }
    const mixed = mergeStream();
    if (spawned.stdout) {
        mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
        mixed.add(spawned.stderr);
    }
    return mixed;
};
// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const getBufferedData = async (stream, streamPromise)=>{
    if (!stream) {
        return;
    }
    stream.destroy();
    try {
        return await streamPromise;
    } catch (error) {
        return error.bufferedData;
    }
};
const getStreamPromise = (stream, { encoding, buffer, maxBuffer })=>{
    if (!stream || !buffer) {
        return;
    }
    if (encoding) {
        return getStream(stream, {
            encoding,
            maxBuffer
        });
    }
    return getStream.buffer(stream, {
        maxBuffer
    });
};
// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
const getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone)=>{
    const stdoutPromise = getStreamPromise(stdout, {
        encoding,
        buffer,
        maxBuffer
    });
    const stderrPromise = getStreamPromise(stderr, {
        encoding,
        buffer,
        maxBuffer
    });
    const allPromise = getStreamPromise(all, {
        encoding,
        buffer,
        maxBuffer: maxBuffer * 2
    });
    try {
        return await Promise.all([
            processDone,
            stdoutPromise,
            stderrPromise,
            allPromise
        ]);
    } catch (error) {
        return Promise.all([
            {
                error,
                signal: error.signal,
                timedOut: error.timedOut
            },
            getBufferedData(stdout, stdoutPromise),
            getBufferedData(stderr, stderrPromise),
            getBufferedData(all, allPromise)
        ]);
    }
};
const validateInputSync = ({ input })=>{
    if (isStream(input)) {
        throw new TypeError('The `input` option cannot be a stream in sync mode');
    }
};
module.exports = {
    handleInput,
    makeAllStream,
    getSpawnedResult,
    validateInputSync
};
}),
"[project]/node_modules/execa/lib/promise.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const nativePromisePrototype = (async ()=>{})().constructor.prototype;
const descriptors = [
    'then',
    'catch',
    'finally'
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
// The return value is a mixin of `childProcess` and `Promise`
const mergePromise = (spawned, promise)=>{
    for (const [property, descriptor] of descriptors){
        // Starting the main `promise` is deferred to avoid consuming streams
        const value = typeof promise === 'function' ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {
            ...descriptor,
            value
        });
    }
    return spawned;
};
// Use promises instead of `child_process` events
const getSpawnedPromise = (spawned)=>{
    return new Promise((resolve, reject)=>{
        spawned.on('exit', (exitCode, signal)=>{
            resolve({
                exitCode,
                signal
            });
        });
        spawned.on('error', (error)=>{
            reject(error);
        });
        if (spawned.stdin) {
            spawned.stdin.on('error', (error)=>{
                reject(error);
            });
        }
    });
};
module.exports = {
    mergePromise,
    getSpawnedPromise
};
}),
"[project]/node_modules/execa/lib/command.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const normalizeArgs = (file, args = [])=>{
    if (!Array.isArray(args)) {
        return [
            file
        ];
    }
    return [
        file,
        ...args
    ];
};
const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const DOUBLE_QUOTES_REGEXP = /"/g;
const escapeArg = (arg)=>{
    if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
        return arg;
    }
    return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};
const joinCommand = (file, args)=>{
    return normalizeArgs(file, args).join(' ');
};
const getEscapedCommand = (file, args)=>{
    return normalizeArgs(file, args).map((arg)=>escapeArg(arg)).join(' ');
};
const SPACES_REGEXP = / +/g;
// Handle `execa.command()`
const parseCommand = (command)=>{
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith('\\')) {
            // Merge previous token with current one
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
            tokens.push(token);
        }
    }
    return tokens;
};
module.exports = {
    joinCommand,
    getEscapedCommand,
    parseCommand
};
}),
"[project]/node_modules/execa/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const childProcess = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
const crossSpawn = __turbopack_context__.r("[project]/node_modules/cross-spawn/index.js [app-route] (ecmascript)");
const stripFinalNewline = __turbopack_context__.r("[project]/node_modules/strip-final-newline/index.js [app-route] (ecmascript)");
const npmRunPath = __turbopack_context__.r("[project]/node_modules/npm-run-path/index.js [app-route] (ecmascript)");
const onetime = __turbopack_context__.r("[project]/node_modules/onetime/index.js [app-route] (ecmascript)");
const makeError = __turbopack_context__.r("[project]/node_modules/execa/lib/error.js [app-route] (ecmascript)");
const normalizeStdio = __turbopack_context__.r("[project]/node_modules/execa/lib/stdio.js [app-route] (ecmascript)");
const { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = __turbopack_context__.r("[project]/node_modules/execa/lib/kill.js [app-route] (ecmascript)");
const { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = __turbopack_context__.r("[project]/node_modules/execa/lib/stream.js [app-route] (ecmascript)");
const { mergePromise, getSpawnedPromise } = __turbopack_context__.r("[project]/node_modules/execa/lib/promise.js [app-route] (ecmascript)");
const { joinCommand, parseCommand, getEscapedCommand } = __turbopack_context__.r("[project]/node_modules/execa/lib/command.js [app-route] (ecmascript)");
const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath })=>{
    const env = extendEnv ? {
        ...process.env,
        ...envOption
    } : envOption;
    if (preferLocal) {
        return npmRunPath.env({
            env,
            cwd: localDir,
            execPath
        });
    }
    return env;
};
const handleArguments = (file, args, options = {})=>{
    const parsed = crossSpawn._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: 'utf8',
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
        // #116
        args.unshift('/q');
    }
    return {
        file,
        args,
        options,
        parsed
    };
};
const handleOutput = (options, value, error)=>{
    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
        // When `execa.sync()` errors, we normalize it to '' to mimic `execa()`
        return error === undefined ? undefined : '';
    }
    if (options.stripFinalNewline) {
        return stripFinalNewline(value);
    }
    return value;
};
const execa = (file, args, options)=>{
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    const escapedCommand = getEscapedCommand(file, args);
    validateTimeout(parsed.options);
    let spawned;
    try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
        // Ensure the returned error is always both a promise and a child process
        const dummySpawned = new childProcess.ChildProcess();
        const errorPromise = Promise.reject(makeError({
            error,
            stdout: '',
            stderr: '',
            all: '',
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context = {
        isCanceled: false
    };
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromise = async ()=>{
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
            const returnedError = makeError({
                error,
                exitCode,
                signal,
                stdout,
                stderr,
                all,
                command,
                escapedCommand,
                parsed,
                timedOut,
                isCanceled: context.isCanceled,
                killed: spawned.killed
            });
            if (!parsed.options.reject) {
                return returnedError;
            }
            throw returnedError;
        }
        return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    };
    const handlePromiseOnce = onetime(handlePromise);
    handleInput(spawned, parsed.options.input);
    spawned.all = makeAllStream(spawned, parsed.options);
    return mergePromise(spawned, handlePromiseOnce);
};
module.exports = execa;
module.exports.sync = (file, args, options)=>{
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    const escapedCommand = getEscapedCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error) {
        throw makeError({
            error,
            stdout: '',
            stderr: '',
            all: '',
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError({
            stdout,
            stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command,
            escapedCommand,
            parsed,
            timedOut: result.error && result.error.code === 'ETIMEDOUT',
            isCanceled: false,
            killed: result.signal !== null
        });
        if (!parsed.options.reject) {
            return error;
        }
        throw error;
    }
    return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
    };
};
module.exports.command = (command, options)=>{
    const [file, ...args] = parseCommand(command);
    return execa(file, args, options);
};
module.exports.commandSync = (command, options)=>{
    const [file, ...args] = parseCommand(command);
    return execa.sync(file, args, options);
};
module.exports.node = (scriptPath, args, options = {})=>{
    if (args && !Array.isArray(args) && typeof args === 'object') {
        options = args;
        args = [];
    }
    const stdio = normalizeStdio.node(options);
    const defaultExecArgv = process.execArgv.filter((arg)=>!arg.startsWith('--inspect'));
    const { nodePath = process.execPath, nodeOptions = defaultExecArgv } = options;
    return execa(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
    ], {
        ...options,
        stdin: undefined,
        stdout: undefined,
        stderr: undefined,
        stdio,
        shell: false
    });
};
}),
"[project]/node_modules/execa/node_modules/signal-exit/signals.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
    'SIGABRT',
    'SIGALRM',
    'SIGHUP',
    'SIGINT',
    'SIGTERM'
];
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
}),
"[project]/node_modules/execa/node_modules/signal-exit/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var process = /*TURBOPACK member replacement*/ __turbopack_context__.g.process;
const processOk = function(process) {
    return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
};
// some kind of non-node environment, just no-op
/* istanbul ignore if */ if (!processOk(process)) {
    module.exports = function() {
        return function() {};
    };
} else {
    var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
    var signals = __turbopack_context__.r("[project]/node_modules/execa/node_modules/signal-exit/signals.js [app-route] (ecmascript)");
    var isWin = /^win/i.test(process.platform);
    var EE = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
    /* istanbul ignore if */ if (typeof EE !== 'function') {
        EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
        emitter = process.__signal_exit_emitter__;
    } else {
        emitter = process.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
    }
    // Because this emitter is a global, we have to check to see if a
    // previous version of this library failed to enable infinite listeners.
    // I know what you're about to say.  But literally everything about
    // signal-exit is a compromise with evil.  Get used to it.
    if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
    }
    module.exports = function(cb, opts) {
        /* istanbul ignore if */ if (!processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
            return function() {};
        }
        assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');
        if (loaded === false) {
            load();
        }
        var ev = 'exit';
        if (opts && opts.alwaysLast) {
            ev = 'afterexit';
        }
        var remove = function() {
            emitter.removeListener(ev, cb);
            if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
                unload();
            }
        };
        emitter.on(ev, cb);
        return remove;
    };
    var unload = function unload() {
        if (!loaded || !processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
            return;
        }
        loaded = false;
        signals.forEach(function(sig) {
            try {
                process.removeListener(sig, sigListeners[sig]);
            } catch (er) {}
        });
        process.emit = originalProcessEmit;
        process.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
    };
    module.exports.unload = unload;
    var emit = function emit(event, code, signal) {
        /* istanbul ignore if */ if (emitter.emitted[event]) {
            return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
    };
    // { <signal>: <listener fn>, ... }
    var sigListeners = {};
    signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
            /* istanbul ignore if */ if (!processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
                return;
            }
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = process.listeners(sig);
            if (listeners.length === emitter.count) {
                unload();
                emit('exit', null, sig);
                /* istanbul ignore next */ emit('afterexit', null, sig);
                /* istanbul ignore next */ if (isWin && sig === 'SIGHUP') {
                    // "SIGHUP" throws an `ENOSYS` error on Windows,
                    // so use a supported signal instead
                    sig = 'SIGINT';
                }
                /* istanbul ignore next */ process.kill(process.pid, sig);
            }
        };
    });
    module.exports.signals = function() {
        return signals;
    };
    var loaded = false;
    var load = function load() {
        if (loaded || !processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
            return;
        }
        loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        emitter.count += 1;
        signals = signals.filter(function(sig) {
            try {
                process.on(sig, sigListeners[sig]);
                return true;
            } catch (er) {
                return false;
            }
        });
        process.emit = processEmit;
        process.reallyExit = processReallyExit;
    };
    module.exports.load = load;
    var originalProcessReallyExit = process.reallyExit;
    var processReallyExit = function processReallyExit(code) {
        /* istanbul ignore if */ if (!processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
            return;
        }
        process.exitCode = code || /* istanbul ignore next */ 0;
        emit('exit', process.exitCode, null);
        /* istanbul ignore next */ emit('afterexit', process.exitCode, null);
        /* istanbul ignore next */ originalProcessReallyExit.call(process, process.exitCode);
    };
    var originalProcessEmit = process.emit;
    var processEmit = function processEmit(ev, arg) {
        if (ev === 'exit' && processOk(/*TURBOPACK member replacement*/ __turbopack_context__.g.process)) {
            /* istanbul ignore else */ if (arg !== undefined) {
                process.exitCode = arg;
            }
            var ret = originalProcessEmit.apply(this, arguments);
            /* istanbul ignore next */ emit('exit', process.exitCode, null);
            /* istanbul ignore next */ emit('afterexit', process.exitCode, null);
            /* istanbul ignore next */ return ret;
        } else {
            return originalProcessEmit.apply(this, arguments);
        }
    };
}
}),
"[project]/node_modules/is-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const isStream = (stream)=>stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
isStream.writable = (stream)=>isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
isStream.readable = (stream)=>isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
isStream.duplex = (stream)=>isStream.writable(stream) && isStream.readable(stream);
isStream.transform = (stream)=>isStream.duplex(stream) && typeof stream._transform === 'function';
module.exports = isStream;
}),
"[project]/node_modules/execa/node_modules/get-stream/buffer-stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { PassThrough: PassThroughStream } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
module.exports = (options)=>{
    options = {
        ...options
    };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === 'buffer';
    let objectMode = false;
    if (array) {
        objectMode = !(encoding || isBuffer);
    } else {
        encoding = encoding || 'utf8';
    }
    if (isBuffer) {
        encoding = null;
    }
    const stream = new PassThroughStream({
        objectMode
    });
    if (encoding) {
        stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on('data', (chunk)=>{
        chunks.push(chunk);
        if (objectMode) {
            length = chunks.length;
        } else {
            length += chunk.length;
        }
    });
    stream.getBufferedValue = ()=>{
        if (array) {
            return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
    };
    stream.getBufferedLength = ()=>length;
    return stream;
};
}),
"[project]/node_modules/execa/node_modules/get-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { constants: BufferConstants } = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const bufferStream = __turbopack_context__.r("[project]/node_modules/execa/node_modules/get-stream/buffer-stream.js [app-route] (ecmascript)");
const streamPipelinePromisified = promisify(stream.pipeline);
class MaxBufferError extends Error {
    constructor(){
        super('maxBuffer exceeded');
        this.name = 'MaxBufferError';
    }
}
async function getStream(inputStream, options) {
    if (!inputStream) {
        throw new Error('Expected a stream');
    }
    options = {
        maxBuffer: Infinity,
        ...options
    };
    const { maxBuffer } = options;
    const stream = bufferStream(options);
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                error.bufferedData = stream.getBufferedValue();
            }
            reject(error);
        };
        (async ()=>{
            try {
                await streamPipelinePromisified(inputStream, stream);
                resolve();
            } catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on('data', ()=>{
            if (stream.getBufferedLength() > maxBuffer) {
                rejectPromise(new MaxBufferError());
            }
        });
    });
    return stream.getBufferedValue();
}
module.exports = getStream;
module.exports.buffer = (stream, options)=>getStream(stream, {
        ...options,
        encoding: 'buffer'
    });
module.exports.array = (stream, options)=>getStream(stream, {
        ...options,
        array: true
    });
module.exports.MaxBufferError = MaxBufferError;
}),
"[project]/node_modules/get-stream/buffer-stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { PassThrough: PassThroughStream } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
module.exports = (options)=>{
    options = {
        ...options
    };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === 'buffer';
    let objectMode = false;
    if (array) {
        objectMode = !(encoding || isBuffer);
    } else {
        encoding = encoding || 'utf8';
    }
    if (isBuffer) {
        encoding = null;
    }
    const stream = new PassThroughStream({
        objectMode
    });
    if (encoding) {
        stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on('data', (chunk)=>{
        chunks.push(chunk);
        if (objectMode) {
            length = chunks.length;
        } else {
            length += chunk.length;
        }
    });
    stream.getBufferedValue = ()=>{
        if (array) {
            return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
    };
    stream.getBufferedLength = ()=>length;
    return stream;
};
}),
"[project]/node_modules/get-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { constants: BufferConstants } = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const pump = __turbopack_context__.r("[project]/node_modules/pump/index.js [app-route] (ecmascript)");
const bufferStream = __turbopack_context__.r("[project]/node_modules/get-stream/buffer-stream.js [app-route] (ecmascript)");
class MaxBufferError extends Error {
    constructor(){
        super('maxBuffer exceeded');
        this.name = 'MaxBufferError';
    }
}
async function getStream(inputStream, options) {
    if (!inputStream) {
        return Promise.reject(new Error('Expected a stream'));
    }
    options = {
        maxBuffer: Infinity,
        ...options
    };
    const { maxBuffer } = options;
    let stream;
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                error.bufferedData = stream.getBufferedValue();
            }
            reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error)=>{
            if (error) {
                rejectPromise(error);
                return;
            }
            resolve();
        });
        stream.on('data', ()=>{
            if (stream.getBufferedLength() > maxBuffer) {
                rejectPromise(new MaxBufferError());
            }
        });
    });
    return stream.getBufferedValue();
}
module.exports = getStream;
// TODO: Remove this for the next major release
module.exports.default = getStream;
module.exports.buffer = (stream, options)=>getStream(stream, {
        ...options,
        encoding: 'buffer'
    });
module.exports.array = (stream, options)=>getStream(stream, {
        ...options,
        array: true
    });
module.exports.MaxBufferError = MaxBufferError;
}),
"[project]/node_modules/merge-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { PassThrough } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
module.exports = function() {
    var sources = [];
    var output = new PassThrough({
        objectMode: true
    });
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on('unpipe', remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    //TURBOPACK unreachable
    ;
    function add(source) {
        if (Array.isArray(source)) {
            source.forEach(add);
            return this;
        }
        sources.push(source);
        source.once('end', remove.bind(null, source));
        source.once('error', output.emit.bind(output, 'error'));
        source.pipe(output, {
            end: false
        });
        return this;
    }
    function isEmpty() {
        return sources.length == 0;
    }
    function remove(source) {
        sources = sources.filter(function(it) {
            return it !== source;
        });
        if (!sources.length && output.readable) {
            output.end();
        }
    }
};
}),
"[project]/node_modules/extract-zip/node_modules/ms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/extract-zip/node_modules/debug/src/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/extract-zip/node_modules/debug/src/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/extract-zip/node_modules/debug/src/browser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/extract-zip/node_modules/debug/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = os.release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
    }
    //TURBOPACK unreachable
    ;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    //TURBOPACK unreachable
    ;
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}),
"[project]/node_modules/once/once.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}),
"[project]/node_modules/end-of-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-route] (ecmascript)");
var noop = function() {};
var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
};
var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};
var eos = function(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
    };
    var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
    };
    var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
    };
    var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
    };
    var onerror = function(err) {
        callback.call(stream, err);
    };
    var onclose = function() {
        process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
    };
    var onrequest = function() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !ws) {
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    if (isChildProcess(stream)) stream.on('exit', onexit);
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        cancelled = true;
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('exit', onexit);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
};
module.exports = eos;
}),
"[project]/node_modules/pump/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-route] (ecmascript)");
var eos = __turbopack_context__.r("[project]/node_modules/end-of-stream/index.js [app-route] (ecmascript)");
var fs;
try {
    fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)"); // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}
var noop = function() {};
var ancient = /^v?\.0/.test(process.version);
var isFn = function(fn) {
    return typeof fn === 'function';
};
var isFS = function(stream) {
    if (!ancient) return false // newer node version do not need to care about fs is a special way
    ;
    if (!fs) return false // browser
    ;
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};
var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
};
var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
        ;
        if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want
        ;
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err || new Error('stream was destroyed'));
    };
};
var call = function(fn) {
    fn();
};
var pipe = function(from, to) {
    return from.pipe(to);
};
var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error('pump requires two streams per minimum');
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
};
module.exports = pump;
}),
"[project]/node_modules/pend/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = Pend;
function Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
}
Pend.prototype.go = function(fn) {
    if (this.pending < this.max) {
        pendGo(this, fn);
    } else {
        this.waiting.push(fn);
    }
};
Pend.prototype.wait = function(cb) {
    if (this.pending === 0) {
        cb(this.error);
    } else {
        this.listeners.push(cb);
    }
};
Pend.prototype.hold = function() {
    return pendHold(this);
};
function pendHold(self) {
    self.pending += 1;
    var called = false;
    return onCb;
    //TURBOPACK unreachable
    ;
    function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self.error = self.error || err;
        self.pending -= 1;
        if (self.waiting.length > 0 && self.pending < self.max) {
            pendGo(self, self.waiting.shift());
        } else if (self.pending === 0) {
            var listeners = self.listeners;
            self.listeners = [];
            listeners.forEach(cbListener);
        }
    }
    function cbListener(listener) {
        listener(self.error);
    }
}
function pendGo(self, fn) {
    fn(pendHold(self));
}
}),
"[project]/node_modules/fd-slicer/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
var Readable = stream.Readable;
var Writable = stream.Writable;
var PassThrough = stream.PassThrough;
var Pend = __turbopack_context__.r("[project]/node_modules/pend/index.js [app-route] (ecmascript)");
var EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
exports.createFromBuffer = createFromBuffer;
exports.createFromFd = createFromFd;
exports.BufferSlicer = BufferSlicer;
exports.FdSlicer = FdSlicer;
util.inherits(FdSlicer, EventEmitter);
function FdSlicer(fd, options) {
    options = options || {};
    EventEmitter.call(this);
    this.fd = fd;
    this.pend = new Pend();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
}
FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var self = this;
    self.pend.go(function(cb) {
        fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
            cb();
            callback(err, bytesRead, buffer);
        });
    });
};
FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    var self = this;
    self.pend.go(function(cb) {
        fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
            cb();
            callback(err, written, buffer);
        });
    });
};
FdSlicer.prototype.createReadStream = function(options) {
    return new ReadStream(this, options);
};
FdSlicer.prototype.createWriteStream = function(options) {
    return new WriteStream(this, options);
};
FdSlicer.prototype.ref = function() {
    this.refCount += 1;
};
FdSlicer.prototype.unref = function() {
    var self = this;
    self.refCount -= 1;
    if (self.refCount > 0) return;
    if (self.refCount < 0) throw new Error("invalid unref");
    if (self.autoClose) {
        fs.close(self.fd, onCloseDone);
    }
    function onCloseDone(err) {
        if (err) {
            self.emit('error', err);
        } else {
            self.emit('close');
        }
    }
};
util.inherits(ReadStream, Readable);
function ReadStream(context, options) {
    options = options || {};
    Readable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
}
ReadStream.prototype._read = function(n) {
    var self = this;
    if (self.destroyed) return;
    var toRead = Math.min(self._readableState.highWaterMark, n);
    if (self.endOffset != null) {
        toRead = Math.min(toRead, self.endOffset - self.pos);
    }
    if (toRead <= 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
        return;
    }
    self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        var buffer = new Buffer(toRead);
        fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
            if (err) {
                self.destroy(err);
            } else if (bytesRead === 0) {
                self.destroyed = true;
                self.push(null);
                self.context.unref();
            } else {
                self.pos += bytesRead;
                self.push(buffer.slice(0, bytesRead));
            }
            cb();
        });
    });
};
ReadStream.prototype.destroy = function(err) {
    if (this.destroyed) return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit('error', err);
    this.context.unref();
};
util.inherits(WriteStream, Writable);
function WriteStream(context, options) {
    options = options || {};
    Writable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on('finish', this.destroy.bind(this));
}
WriteStream.prototype._write = function(buffer, encoding, callback) {
    var self = this;
    if (self.destroyed) return;
    if (self.pos + buffer.length > self.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = 'ETOOBIG';
        self.destroy();
        callback(err);
        return;
    }
    self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
            if (err) {
                self.destroy();
                cb();
                callback(err);
            } else {
                self.bytesWritten += bytes;
                self.pos += bytes;
                self.emit('progress');
                cb();
                callback();
            }
        });
    });
};
WriteStream.prototype.destroy = function() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.context.unref();
};
util.inherits(BufferSlicer, EventEmitter);
function BufferSlicer(buffer, options) {
    EventEmitter.call(this);
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer;
    this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}
BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var end = position + length;
    var delta = end - this.buffer.length;
    var written = delta > 0 ? delta : length;
    this.buffer.copy(buffer, offset, position, end);
    setImmediate(function() {
        callback(null, written);
    });
};
BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    buffer.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
        callback(null, length, buffer);
    });
};
BufferSlicer.prototype.createReadStream = function(options) {
    options = options || {};
    var readStream = new PassThrough(options);
    readStream.destroyed = false;
    readStream.start = options.start || 0;
    readStream.endOffset = options.end;
    // by the time this function returns, we'll be done.
    readStream.pos = readStream.endOffset || this.buffer.length;
    // respect the maxChunkSize option to slice up the chunk into smaller pieces.
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while(true){
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
            // last chunk
            if (offset < entireSlice.length) {
                readStream.write(entireSlice.slice(offset, entireSlice.length));
            }
            break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
        readStream.destroyed = true;
    };
    return readStream;
};
BufferSlicer.prototype.createWriteStream = function(options) {
    var bufferSlicer = this;
    options = options || {};
    var writeStream = new Writable(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
            var err = new Error("maximum file length exceeded");
            err.code = 'ETOOBIG';
            writeStream.destroyed = true;
            callback(err);
            return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit('progress');
        callback();
    };
    writeStream.destroy = function() {
        writeStream.destroyed = true;
    };
    return writeStream;
};
BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
};
BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) {
        throw new Error("invalid unref");
    }
};
function createFromBuffer(buffer, options) {
    return new BufferSlicer(buffer, options);
}
function createFromFd(fd, options) {
    return new FdSlicer(fd, options);
}
}),
"[project]/node_modules/buffer-crc32/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)").Buffer;
var CRC_TABLE = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
if (typeof Int32Array !== 'undefined') {
    CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
    if (Buffer.isBuffer(input)) {
        return input;
    }
    var hasNewBufferAPI = typeof Buffer.alloc === "function" && typeof Buffer.from === "function";
    if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
    } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
    } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
}
function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
}
function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for(var n = 0; n < buf.length; n++){
        crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ crc >>> 8;
    }
    return crc ^ -1;
}
function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function() {
    return _crc32.apply(null, arguments);
};
crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
};
module.exports = crc32;
}),
"[project]/node_modules/yauzl/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var zlib = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
var fd_slicer = __turbopack_context__.r("[project]/node_modules/fd-slicer/index.js [app-route] (ecmascript)");
var crc32 = __turbopack_context__.r("[project]/node_modules/buffer-crc32/index.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
var Transform = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Transform;
var PassThrough = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").PassThrough;
var Writable = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Writable;
exports.open = open;
exports.fromFd = fromFd;
exports.fromBuffer = fromBuffer;
exports.fromRandomAccessReader = fromRandomAccessReader;
exports.dosDateTimeToDate = dosDateTimeToDate;
exports.validateFileName = validateFileName;
exports.ZipFile = ZipFile;
exports.Entry = Entry;
exports.RandomAccessReader = RandomAccessReader;
function open(path, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = true;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs.open(path, "r", function(err, fd) {
        if (err) return callback(err);
        fromFd(fd, options, function(err, zipfile) {
            if (err) fs.close(fd, defaultCallback);
            callback(err, zipfile);
        });
    });
}
function fromFd(fd, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = false;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = fd_slicer.createFromFd(fd, {
            autoClose: true
        });
        fromRandomAccessReader(reader, stats.size, options, callback);
    });
}
function fromBuffer(buffer, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    options.autoClose = false;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
    var reader = fd_slicer.createFromBuffer(buffer, {
        maxChunkSize: 0x10000
    });
    fromRandomAccessReader(reader, buffer.length, options, callback);
}
function fromRandomAccessReader(reader, totalSize, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = true;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    var decodeStrings = !!options.decodeStrings;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    }
    // the matching unref() call is in zipfile.close()
    reader.ref();
    // eocdr means End of Central Directory Record.
    // search backwards for the eocdr signature.
    // the last field of the eocdr is a variable-length comment.
    // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
    // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
    // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
    var eocdrWithoutCommentSize = 22;
    var maxCommentSize = 0xffff; // 2-byte size
    var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer = newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer.length;
    readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for(var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1){
            if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
            // found eocdr
            var eocdrBuffer = buffer.slice(i);
            // 0 - End of central directory signature = 0x06054b50
            // 4 - Number of this disk
            var diskNumber = eocdrBuffer.readUInt16LE(4);
            if (diskNumber !== 0) {
                return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
            }
            // 6 - Disk where central directory starts
            // 8 - Number of central directory records on this disk
            // 10 - Total number of central directory records
            var entryCount = eocdrBuffer.readUInt16LE(10);
            // 12 - Size of central directory (bytes)
            // 16 - Offset of start of central directory, relative to start of archive
            var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
            // 20 - Comment length
            var commentLength = eocdrBuffer.readUInt16LE(20);
            var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
            if (commentLength !== expectedCommentLength) {
                return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
            }
            // 22 - Comment
            // the encoding is always cp437.
            var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
            if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
                return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            }
            // ZIP64 format
            // ZIP64 Zip64 end of central directory locator
            var zip64EocdlBuffer = newBuffer(20);
            var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
            readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
                if (err) return callback(err);
                // 0 - zip64 end of central dir locator signature = 0x07064b50
                if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
                    return callback(new Error("invalid zip64 end of central directory locator signature"));
                }
                // 4 - number of the disk with the start of the zip64 end of central directory
                // 8 - relative offset of the zip64 end of central directory record
                var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
                // 16 - total number of disks
                // ZIP64 end of central directory record
                var zip64EocdrBuffer = newBuffer(56);
                readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
                    if (err) return callback(err);
                    // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
                    if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
                        return callback(new Error("invalid zip64 end of central directory record signature"));
                    }
                    // 4 - size of zip64 end of central directory record                8 bytes
                    // 12 - version made by                                             2 bytes
                    // 14 - version needed to extract                                   2 bytes
                    // 16 - number of this disk                                         4 bytes
                    // 20 - number of the disk with the start of the central directory  4 bytes
                    // 24 - total number of entries in the central directory on this disk         8 bytes
                    // 32 - total number of entries in the central directory            8 bytes
                    entryCount = readUInt64LE(zip64EocdrBuffer, 32);
                    // 40 - size of the central directory                               8 bytes
                    // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
                    centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
                    // 56 - zip64 extensible data sector                                (variable size)
                    return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                });
            });
            return;
        }
        callback(new Error("end of central directory record signature not found"));
    });
}
util.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self = this;
    EventEmitter.call(self);
    self.reader = reader;
    // forward close events
    self.reader.on("error", function(err) {
        // error closing the fd
        emitError(self, err);
    });
    self.reader.once("close", function() {
        self.emit("close");
    });
    self.readEntryCursor = centralDirectoryOffset;
    self.fileSize = fileSize;
    self.entryCount = entryCount;
    self.comment = comment;
    self.entriesRead = 0;
    self.autoClose = !!autoClose;
    self.lazyEntries = !!lazyEntries;
    self.decodeStrings = !!decodeStrings;
    self.validateEntrySizes = !!validateEntrySizes;
    self.strictFileNames = !!strictFileNames;
    self.isOpen = true;
    self.emittedError = false;
    if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function() {
    if (!this.isOpen) return;
    this.isOpen = false;
    this.reader.unref();
};
function emitErrorAndAutoClose(self, err) {
    if (self.autoClose) self.close();
    emitError(self, err);
}
function emitError(self, err) {
    if (self.emittedError) return;
    self.emittedError = true;
    self.emit("error", err);
}
ZipFile.prototype.readEntry = function() {
    if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
};
ZipFile.prototype._readEntry = function() {
    var self = this;
    if (self.entryCount === self.entriesRead) {
        // done with metadata
        setImmediate(function() {
            if (self.autoClose) self.close();
            if (self.emittedError) return;
            self.emit("end");
        });
        return;
    }
    if (self.emittedError) return;
    var buffer = newBuffer(46);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
        if (err) return emitErrorAndAutoClose(self, err);
        if (self.emittedError) return;
        var entry = new Entry();
        // 0 - Central directory file header signature
        var signature = buffer.readUInt32LE(0);
        if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        // 4 - Version made by
        entry.versionMadeBy = buffer.readUInt16LE(4);
        // 6 - Version needed to extract (minimum)
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        // 8 - General purpose bit flag
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        // 10 - Compression method
        entry.compressionMethod = buffer.readUInt16LE(10);
        // 12 - File last modification time
        entry.lastModFileTime = buffer.readUInt16LE(12);
        // 14 - File last modification date
        entry.lastModFileDate = buffer.readUInt16LE(14);
        // 16 - CRC-32
        entry.crc32 = buffer.readUInt32LE(16);
        // 20 - Compressed size
        entry.compressedSize = buffer.readUInt32LE(20);
        // 24 - Uncompressed size
        entry.uncompressedSize = buffer.readUInt32LE(24);
        // 28 - File name length (n)
        entry.fileNameLength = buffer.readUInt16LE(28);
        // 30 - Extra field length (m)
        entry.extraFieldLength = buffer.readUInt16LE(30);
        // 32 - File comment length (k)
        entry.fileCommentLength = buffer.readUInt16LE(32);
        // 34 - Disk number where file starts
        // 36 - Internal file attributes
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        // 38 - External file attributes
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        // 42 - Relative offset of local file header
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));
        self.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
            if (err) return emitErrorAndAutoClose(self, err);
            if (self.emittedError) return;
            // 46 - File name
            var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
            entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
            // 46+n - Extra field
            var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
            var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
            entry.extraFields = [];
            var i = 0;
            while(i < extraFieldBuffer.length - 3){
                var headerId = extraFieldBuffer.readUInt16LE(i + 0);
                var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
                var dataStart = i + 4;
                var dataEnd = dataStart + dataSize;
                if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
                var dataBuffer = newBuffer(dataSize);
                extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
                entry.extraFields.push({
                    id: headerId,
                    data: dataBuffer
                });
                i = dataEnd;
            }
            // 46+n+m - File comment
            entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
            // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
            entry.comment = entry.fileComment;
            self.readEntryCursor += buffer.length;
            self.entriesRead += 1;
            if (entry.uncompressedSize === 0xffffffff || entry.compressedSize === 0xffffffff || entry.relativeOffsetOfLocalHeader === 0xffffffff) {
                // ZIP64 format
                // find the Zip64 Extended Information Extra Field
                var zip64EiefBuffer = null;
                for(var i = 0; i < entry.extraFields.length; i++){
                    var extraField = entry.extraFields[i];
                    if (extraField.id === 0x0001) {
                        zip64EiefBuffer = extraField.data;
                        break;
                    }
                }
                if (zip64EiefBuffer == null) {
                    return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
                }
                var index = 0;
                // 0 - Original Size          8 bytes
                if (entry.uncompressedSize === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) {
                        return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
                    }
                    entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
                // 8 - Compressed Size        8 bytes
                if (entry.compressedSize === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) {
                        return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
                    }
                    entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
                // 16 - Relative Header Offset 8 bytes
                if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) {
                        return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
                    }
                    entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
            // 24 - Disk Start Number      4 bytes
            }
            // check for Info-ZIP Unicode Path Extra Field (0x7075)
            // see https://github.com/thejoshwolfe/yauzl/issues/33
            if (self.decodeStrings) {
                for(var i = 0; i < entry.extraFields.length; i++){
                    var extraField = entry.extraFields[i];
                    if (extraField.id === 0x7075) {
                        if (extraField.data.length < 6) {
                            continue;
                        }
                        // Version       1 byte      version of this extra field, currently 1
                        if (extraField.data.readUInt8(0) !== 1) {
                            continue;
                        }
                        // NameCRC32     4 bytes     File Name Field CRC32 Checksum
                        var oldNameCrc32 = extraField.data.readUInt32LE(1);
                        if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                            continue;
                        }
                        // UnicodeName   Variable    UTF-8 version of the entry File Name
                        entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                        break;
                    }
                }
            }
            // validate file size
            if (self.validateEntrySizes && entry.compressionMethod === 0) {
                var expectedCompressedSize = entry.uncompressedSize;
                if (entry.isEncrypted()) {
                    // traditional encryption prefixes the file data with a header
                    expectedCompressedSize += 12;
                }
                if (entry.compressedSize !== expectedCompressedSize) {
                    var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
                    return emitErrorAndAutoClose(self, new Error(msg));
                }
            }
            if (self.decodeStrings) {
                if (!self.strictFileNames) {
                    // allow backslash
                    entry.fileName = entry.fileName.replace(/\\/g, "/");
                }
                var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
                if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
            }
            self.emit("entry", entry);
            if (!self.lazyEntries) self._readEntry();
        });
    });
};
ZipFile.prototype.openReadStream = function(entry, options, callback) {
    var self = this;
    // parameter validation
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
        callback = options;
        options = {};
    } else {
        // validate options that the caller has no excuse to get wrong
        if (options.decrypt != null) {
            if (!entry.isEncrypted()) {
                throw new Error("options.decrypt can only be specified for encrypted entries");
            }
            if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
            if (entry.isCompressed()) {
                if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
            }
        }
        if (options.decompress != null) {
            if (!entry.isCompressed()) {
                throw new Error("options.decompress can only be specified for compressed entries");
            }
            if (!(options.decompress === false || options.decompress === true)) {
                throw new Error("invalid options.decompress value: " + options.decompress);
            }
        }
        if (options.start != null || options.end != null) {
            if (entry.isCompressed() && options.decompress !== false) {
                throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
            }
            if (entry.isEncrypted() && options.decrypt !== false) {
                throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
            }
        }
        if (options.start != null) {
            relativeStart = options.start;
            if (relativeStart < 0) throw new Error("options.start < 0");
            if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
            relativeEnd = options.end;
            if (relativeEnd < 0) throw new Error("options.end < 0");
            if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
            if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
    }
    // any further errors can either be caused by the zipfile,
    // or were introduced in a minor version of yauzl,
    // so should be passed to the client rather than thrown.
    if (!self.isOpen) return callback(new Error("closed"));
    if (entry.isEncrypted()) {
        if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    // make sure we don't lose the fd before we open the actual read stream
    self.reader.ref();
    var buffer = newBuffer(30);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
            if (err) return callback(err);
            // 0 - Local file header signature = 0x04034b50
            var signature = buffer.readUInt32LE(0);
            if (signature !== 0x04034b50) {
                return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
            }
            // all this should be redundant
            // 4 - Version needed to extract (minimum)
            // 6 - General purpose bit flag
            // 8 - Compression method
            // 10 - File last modification time
            // 12 - File last modification date
            // 14 - CRC-32
            // 18 - Compressed size
            // 22 - Uncompressed size
            // 26 - File name length (n)
            var fileNameLength = buffer.readUInt16LE(26);
            // 28 - Extra field length (m)
            var extraFieldLength = buffer.readUInt16LE(28);
            // 30 - File name
            // 30+n - Extra field
            var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
            var decompress;
            if (entry.compressionMethod === 0) {
                // 0 - The file is stored (no compression)
                decompress = false;
            } else if (entry.compressionMethod === 8) {
                // 8 - The file is Deflated
                decompress = options.decompress != null ? options.decompress : true;
            } else {
                return callback(new Error("unsupported compression method: " + entry.compressionMethod));
            }
            var fileDataStart = localFileHeaderEnd;
            var fileDataEnd = fileDataStart + entry.compressedSize;
            if (entry.compressedSize !== 0) {
                // bounds check now, because the read streams will probably not complain loud enough.
                // since we're dealing with an unsigned offset plus an unsigned size,
                // we only have 1 thing to check for.
                if (fileDataEnd > self.fileSize) {
                    return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
                }
            }
            var readStream = self.reader.createReadStream({
                start: fileDataStart + relativeStart,
                end: fileDataStart + relativeEnd
            });
            var endpointStream = readStream;
            if (decompress) {
                var destroyed = false;
                var inflateFilter = zlib.createInflateRaw();
                readStream.on("error", function(err) {
                    // setImmediate here because errors can be emitted during the first call to pipe()
                    setImmediate(function() {
                        if (!destroyed) inflateFilter.emit("error", err);
                    });
                });
                readStream.pipe(inflateFilter);
                if (self.validateEntrySizes) {
                    endpointStream = new AssertByteCountStream(entry.uncompressedSize);
                    inflateFilter.on("error", function(err) {
                        // forward zlib errors to the client-visible stream
                        setImmediate(function() {
                            if (!destroyed) endpointStream.emit("error", err);
                        });
                    });
                    inflateFilter.pipe(endpointStream);
                } else {
                    // the zlib filter is the client-visible stream
                    endpointStream = inflateFilter;
                }
                // this is part of yauzl's API, so implement this function on the client-visible stream
                endpointStream.destroy = function() {
                    destroyed = true;
                    if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
                    readStream.unpipe(inflateFilter);
                    // TODO: the inflateFilter may cause a memory leak. see Issue #27.
                    readStream.destroy();
                };
            }
            callback(null, endpointStream);
        } finally{
            self.reader.unref();
        }
    });
};
function Entry() {}
Entry.prototype.getLastModDate = function() {
    return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
};
function dosDateTimeToDate(date, time) {
    var day = date & 0x1f; // 1-31
    var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
    var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108
    var millisecond = 0;
    var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
    var minute = time >> 5 & 0x3f; // 0-59
    var hour = time >> 11 & 0x1f; // 0-23
    return new Date(year, month, day, hour, minute, second, millisecond);
}
function validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
    }
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
    }
    if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
    }
    // all good
    return null;
}
function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
    if (length === 0) {
        // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
        return setImmediate(function() {
            callback(null, newBuffer(0));
        });
    }
    reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) {
            return callback(new Error("unexpected EOF"));
        }
        callback();
    });
}
util.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
    Transform.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
    }
    cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
    }
    cb();
};
util.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
    EventEmitter.call(this);
    this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
    var self = this;
    self.refCount -= 1;
    if (self.refCount > 0) return;
    if (self.refCount < 0) throw new Error("invalid unref");
    self.close(onCloseDone);
    function onCloseDone(err) {
        if (err) return self.emit('error', err);
        self.emit('close');
    }
};
RandomAccessReader.prototype.createReadStream = function(options) {
    var start = options.start;
    var end = options.end;
    if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
            emptyStream.end();
        });
        return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new RefUnrefFilter(this);
    stream.on("error", function(err) {
        setImmediate(function() {
            if (!destroyed) refUnrefFilter.emit("error", err);
        });
    });
    refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
    };
    var byteCounter = new AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
            if (!destroyed) byteCounter.emit("error", err);
        });
    });
    byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
    };
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
    var readStream = this.createReadStream({
        start: position,
        end: position + length
    });
    var writeStream = new Writable();
    var written = 0;
    writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error) {
        callback(error);
    });
    readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
};
util.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
    PassThrough.call(this);
    this.context = context;
    this.context.ref();
    this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet) return;
    this.unreffedYet = true;
    this.context.unref();
};
var cp437 = '\u0000 !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
function decodeBuffer(buffer, start, end, isUtf8) {
    if (isUtf8) {
        return buffer.toString("utf8", start, end);
    } else {
        var result = "";
        for(var i = start; i < end; i++){
            result += cp437[buffer[i]];
        }
        return result;
    }
}
function readUInt64LE(buffer, offset) {
    // there is no native function for this, because we can't actually store 64-bit integers precisely.
    // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
    // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
    var lower32 = buffer.readUInt32LE(offset);
    var upper32 = buffer.readUInt32LE(offset + 4);
    // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
    return upper32 * 0x100000000 + lower32;
// as long as we're bounds checking the result of this function against the total file size,
// we'll catch any overflow errors, because we already made sure the total file size was within reason.
}
// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
    newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
    };
} else {
    newBuffer = function(len) {
        return new Buffer(len);
    };
}
function defaultCallback(err) {
    if (err) throw err;
}
}),
"[project]/node_modules/extract-zip/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/extract-zip/node_modules/debug/src/index.js [app-route] (ecmascript)")('extract-zip');
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const { createWriteStream, promises: fs } = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const getStream = __turbopack_context__.r("[project]/node_modules/get-stream/index.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const yauzl = __turbopack_context__.r("[project]/node_modules/yauzl/index.js [app-route] (ecmascript)");
const openZip = promisify(yauzl.open);
const pipeline = promisify(stream.pipeline);
class Extractor {
    constructor(zipPath, opts){
        this.zipPath = zipPath;
        this.opts = opts;
    }
    async extract() {
        debug('opening', this.zipPath, 'with opts', this.opts);
        this.zipfile = await openZip(this.zipPath, {
            lazyEntries: true
        });
        this.canceled = false;
        return new Promise((resolve, reject)=>{
            this.zipfile.on('error', (err)=>{
                this.canceled = true;
                reject(err);
            });
            this.zipfile.readEntry();
            this.zipfile.on('close', ()=>{
                if (!this.canceled) {
                    debug('zip extraction complete');
                    resolve();
                }
            });
            this.zipfile.on('entry', async (entry)=>{
                /* istanbul ignore if */ if (this.canceled) {
                    debug('skipping entry', entry.fileName, {
                        cancelled: this.canceled
                    });
                    return;
                }
                debug('zipfile entry', entry.fileName);
                if (entry.fileName.startsWith('__MACOSX/')) {
                    this.zipfile.readEntry();
                    return;
                }
                const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
                try {
                    await fs.mkdir(destDir, {
                        recursive: true
                    });
                    const canonicalDestDir = await fs.realpath(destDir);
                    const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
                    if (relativeDestDir.split(path.sep).includes('..')) {
                        throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
                    }
                    await this.extractEntry(entry);
                    debug('finished processing', entry.fileName);
                    this.zipfile.readEntry();
                } catch (err) {
                    this.canceled = true;
                    this.zipfile.close();
                    reject(err);
                }
            });
        });
    }
    async extractEntry(entry) {
        /* istanbul ignore if */ if (this.canceled) {
            debug('skipping entry extraction', entry.fileName, {
                cancelled: this.canceled
            });
            return;
        }
        if (this.opts.onEntry) {
            this.opts.onEntry(entry, this.zipfile);
        }
        const dest = path.join(this.opts.dir, entry.fileName);
        // convert external file attr int into a fs stat mode int
        const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
        // check if it's a symlink or dir (using stat mode constants)
        const IFMT = 61440;
        const IFDIR = 16384;
        const IFLNK = 40960;
        const symlink = (mode & IFMT) === IFLNK;
        let isDir = (mode & IFMT) === IFDIR;
        // Failsafe, borrowed from jsZip
        if (!isDir && entry.fileName.endsWith('/')) {
            isDir = true;
        }
        // check for windows weird way of specifying a directory
        // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566
        const madeBy = entry.versionMadeBy >> 8;
        if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;
        debug('extracting entry', {
            filename: entry.fileName,
            isDir: isDir,
            isSymlink: symlink
        });
        const procMode = this.getExtractedMode(mode, isDir) & 0o777;
        // always ensure folders are created
        const destDir = isDir ? dest : path.dirname(dest);
        const mkdirOptions = {
            recursive: true
        };
        if (isDir) {
            mkdirOptions.mode = procMode;
        }
        debug('mkdir', {
            dir: destDir,
            ...mkdirOptions
        });
        await fs.mkdir(destDir, mkdirOptions);
        if (isDir) return;
        debug('opening read stream', dest);
        const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
        if (symlink) {
            const link = await getStream(readStream);
            debug('creating symlink', link, dest);
            await fs.symlink(link, dest);
        } else {
            await pipeline(readStream, createWriteStream(dest, {
                mode: procMode
            }));
        }
    }
    getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        // Set defaults, if necessary
        if (mode === 0) {
            if (isDir) {
                if (this.opts.defaultDirMode) {
                    mode = parseInt(this.opts.defaultDirMode, 10);
                }
                if (!mode) {
                    mode = 0o755;
                }
            } else {
                if (this.opts.defaultFileMode) {
                    mode = parseInt(this.opts.defaultFileMode, 10);
                }
                if (!mode) {
                    mode = 0o644;
                }
            }
        }
        return mode;
    }
}
module.exports = async function(zipPath, opts) {
    debug('creating target directory', opts.dir);
    if (!path.isAbsolute(opts.dir)) {
        throw new Error('Target directory is expected to be absolute');
    }
    await fs.mkdir(opts.dir, {
        recursive: true
    });
    opts.dir = await fs.realpath(opts.dir);
    return new Extractor(zipPath, opts).extract();
};
}),
"[project]/node_modules/@remotion/streaming/dist/esm/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/make-stream-payload-message.ts
__turbopack_context__.s([
    "makeStreamPayloadMessage",
    ()=>makeStreamPayloadMessage,
    "makeStreamer",
    ()=>makeStreamer
]);
var magicWordStr = "remotion_buffer:";
var makeStreamPayloadMessage = ({ status, body, nonce })=>{
    const nonceArr = new TextEncoder().encode(nonce);
    const magicWordArr = new TextEncoder().encode(magicWordStr);
    const separatorArr = new TextEncoder().encode(":");
    const bodyLengthArr = new TextEncoder().encode(body.length.toString());
    const statusArr = new TextEncoder().encode(String(status));
    const totalLength = nonceArr.length + magicWordArr.length + separatorArr.length * 3 + bodyLengthArr.length + statusArr.length + body.length;
    const concat = new Uint8Array(totalLength);
    let offset = 0;
    const appendToConcat = (data)=>{
        concat.set(data, offset);
        offset += data.length;
    };
    appendToConcat(magicWordArr);
    appendToConcat(nonceArr);
    appendToConcat(separatorArr);
    appendToConcat(bodyLengthArr);
    appendToConcat(separatorArr);
    appendToConcat(statusArr);
    appendToConcat(separatorArr);
    appendToConcat(body);
    return concat;
};
// src/make-streamer.ts
var streamingKey = "remotion_buffer:";
var makeStreamer = (onMessage)=>{
    const separator = new Uint8Array(streamingKey.length);
    for(let i = 0; i < streamingKey.length; i++){
        separator[i] = streamingKey.charCodeAt(i);
    }
    let unprocessedBuffers = [];
    let outputBuffer = new Uint8Array(0);
    let missingData = null;
    const findSeparatorIndex = ()=>{
        let searchIndex = 0;
        while(true){
            const separatorIndex = outputBuffer.indexOf(separator[0], searchIndex);
            if (separatorIndex === -1) {
                return -1;
            }
            if (outputBuffer.subarray(separatorIndex, separatorIndex + separator.length).toString() !== separator.toString()) {
                searchIndex = separatorIndex + 1;
                continue;
            }
            return separatorIndex;
        }
    };
    const processInput = ()=>{
        let separatorIndex = findSeparatorIndex();
        if (separatorIndex === -1) {
            return;
        }
        separatorIndex += separator.length;
        let nonceString = "";
        let lengthString = "";
        let statusString = "";
        while(true){
            if (separatorIndex > outputBuffer.length - 1) {
                return;
            }
            const nextDigit = outputBuffer[separatorIndex];
            separatorIndex++;
            if (nextDigit === 58) {
                break;
            }
            nonceString += String.fromCharCode(nextDigit);
        }
        while(true){
            if (separatorIndex > outputBuffer.length - 1) {
                return;
            }
            const nextDigit = outputBuffer[separatorIndex];
            separatorIndex++;
            if (nextDigit === 58) {
                break;
            }
            lengthString += String.fromCharCode(nextDigit);
        }
        while(true){
            if (separatorIndex > outputBuffer.length - 1) {
                return;
            }
            const nextDigit = outputBuffer[separatorIndex];
            if (nextDigit === 58) {
                break;
            }
            separatorIndex++;
            statusString += String.fromCharCode(nextDigit);
        }
        const length = Number(lengthString);
        const status = Number(statusString);
        const dataLength = outputBuffer.length - separatorIndex - 1;
        if (dataLength < length) {
            missingData = {
                dataMissing: length - dataLength
            };
            return;
        }
        const data = outputBuffer.subarray(separatorIndex + 1, separatorIndex + 1 + Number(lengthString));
        onMessage(status === 1 ? "error" : "success", nonceString, data);
        missingData = null;
        outputBuffer = outputBuffer.subarray(separatorIndex + Number(lengthString) + 1);
        processInput();
    };
    const onData = (data)=>{
        unprocessedBuffers.push(data);
        if (missingData) {
            missingData.dataMissing -= data.length;
        }
        if (missingData && missingData.dataMissing > 0) {
            return;
        }
        const newBuffer = new Uint8Array(outputBuffer.length + unprocessedBuffers.reduce((acc, val)=>acc + val.length, 0));
        newBuffer.set(outputBuffer, 0);
        let offset = outputBuffer.length;
        for (const buf of unprocessedBuffers){
            newBuffer.set(buf, offset);
            offset += buf.length;
        }
        outputBuffer = newBuffer;
        unprocessedBuffers = [];
        processInput();
    };
    return {
        onData,
        getOutputBuffer: ()=>outputBuffer,
        clear: ()=>{
            unprocessedBuffers = [];
            outputBuffer = new Uint8Array(0);
        }
    };
};
;
}),
"[project]/node_modules/@remotion/licensing/dist/register-usage-point.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerUsageEvent = exports.HOST = void 0;
exports.HOST = 'https://www.remotion.pro';
const registerUsageEvent = async ({ apiKey, host, succeeded, event })=>{
    const abortController = new AbortController();
    const timeout = setTimeout(()=>{
        abortController.abort();
    }, 10000);
    try {
        const res = await fetch(`${exports.HOST}/api/track/register-usage-point`, {
            method: 'POST',
            body: JSON.stringify({
                event,
                apiKey,
                host,
                succeeded
            }),
            headers: {
                'Content-Type': 'application/json'
            },
            signal: abortController.signal
        });
        clearTimeout(timeout);
        const json = await res.json();
        if (json.success) {
            return {
                billable: json.billable,
                classification: json.classification
            };
        }
        if (!res.ok) {
            throw new Error(json.error);
        }
        const read = await res.json();
        return read;
    } catch (err) {
        clearTimeout(timeout);
        if (err instanceof Error && err.name === 'AbortError') {
            throw new Error('Request timed out after 10 seconds');
        }
        throw err;
    }
};
exports.registerUsageEvent = registerUsageEvent;
}),
"[project]/node_modules/@remotion/licensing/dist/get-usage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getUsage = void 0;
const register_usage_point_1 = __turbopack_context__.r("[project]/node_modules/@remotion/licensing/dist/register-usage-point.js [app-route] (ecmascript)");
const getUsage = async ({ apiKey, since })=>{
    const res = await fetch(`${register_usage_point_1.HOST}/api/track/get-usage`, {
        method: 'POST',
        body: JSON.stringify({
            apiKey,
            since: since !== null && since !== void 0 ? since : null
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    const json = await res.json();
    if (json.success) {
        return {
            cloudRenders: json.cloudRenders,
            webcodecConversions: json.webcodecConversions
        };
    }
    throw new Error(json.error);
};
exports.getUsage = getUsage;
}),
"[project]/node_modules/@remotion/licensing/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getUsage = exports.registerUsageEvent = void 0;
var register_usage_point_1 = __turbopack_context__.r("[project]/node_modules/@remotion/licensing/dist/register-usage-point.js [app-route] (ecmascript)");
Object.defineProperty(exports, "registerUsageEvent", {
    enumerable: true,
    get: function() {
        return register_usage_point_1.registerUsageEvent;
    }
});
var get_usage_1 = __turbopack_context__.r("[project]/node_modules/@remotion/licensing/dist/get-usage.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getUsage", {
    enumerable: true,
    get: function() {
        return get_usage_1.getUsage;
    }
});
}),
];

//# sourceMappingURL=node_modules_5e8ea75c._.js.map