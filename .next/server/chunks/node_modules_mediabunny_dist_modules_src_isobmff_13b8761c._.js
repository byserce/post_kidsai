module.exports = [
"[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "buildIsobmffMimeType",
    ()=>buildIsobmffMimeType
]);
const buildIsobmffMimeType = (info)=>{
    const base = info.hasVideo ? 'video/' : info.hasAudio ? 'audio/' : 'application/';
    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');
    if (info.codecStrings.length > 0) {
        const uniqueCodecMimeTypes = [
            ...new Set(info.codecStrings)
        ];
        string += `; codecs="${uniqueCodecMimeTypes.join(', ')}"`;
    }
    return string;
};
}),
"[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "MAX_BOX_HEADER_SIZE",
    ()=>MAX_BOX_HEADER_SIZE,
    "MIN_BOX_HEADER_SIZE",
    ()=>MIN_BOX_HEADER_SIZE,
    "readBoxHeader",
    ()=>readBoxHeader,
    "readDataBox",
    ()=>readDataBox,
    "readFixed_16_16",
    ()=>readFixed_16_16,
    "readFixed_2_30",
    ()=>readFixed_2_30,
    "readIsomVariableInteger",
    ()=>readIsomVariableInteger,
    "readMetadataStringShort",
    ()=>readMetadataStringShort
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/metadata.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/reader.js [app-route] (ecmascript)");
;
;
;
const MIN_BOX_HEADER_SIZE = 8;
const MAX_BOX_HEADER_SIZE = 16;
const readBoxHeader = (slice)=>{
    let totalSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
    const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAscii"])(slice, 4);
    let headerSize = 8;
    const hasLargeSize = totalSize === 1;
    if (hasLargeSize) {
        totalSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
        headerSize = 16;
    }
    const contentSize = totalSize - headerSize;
    if (contentSize < 0) {
        return null; // Hardly a box is it
    }
    return {
        name,
        totalSize,
        headerSize,
        contentSize
    };
};
const readFixed_16_16 = (slice)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice) / 0x10000;
};
const readFixed_2_30 = (slice)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice) / 0x40000000;
};
const readIsomVariableInteger = (slice)=>{
    let result = 0;
    for(let i = 0; i < 4; i++){
        result <<= 7;
        const nextByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
        result |= nextByte & 0x7f;
        if ((nextByte & 0x80) === 0) {
            break;
        }
    }
    return result;
};
const readMetadataStringShort = (slice)=>{
    let stringLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
    slice.skip(2); // Language
    stringLength = Math.min(stringLength, slice.remainingLength);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecoder"].decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, stringLength));
};
const readDataBox = (slice)=>{
    const header = readBoxHeader(slice);
    if (!header || header.name !== 'data') {
        return null;
    }
    if (slice.remainingLength < 8) {
        // Box is too small
        return null;
    }
    const typeIndicator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
    slice.skip(4); // Locale indicator
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, header.contentSize - 8);
    switch(typeIndicator){
        case 1:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecoder"].decode(data); // UTF-8
        case 2:
            return new TextDecoder('utf-16be').decode(data); // UTF-16-BE
        case 13:
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RichImageData"](data, 'image/jpeg');
        case 14:
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RichImageData"](data, 'image/png');
        case 27:
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RichImageData"](data, 'image/bmp');
        default:
            return data;
    }
};
}),
"[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-demuxer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "IsobmffDemuxer",
    ()=>IsobmffDemuxer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec-data.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$demuxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/demuxer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/input-track.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/packet.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/reader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/metadata.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
class IsobmffDemuxer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$demuxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Demuxer"] {
    constructor(input){
        super(input);
        this.moovSlice = null;
        this.currentTrack = null;
        this.tracks = [];
        this.metadataPromise = null;
        this.movieTimescale = -1;
        this.movieDurationInTimescale = -1;
        this.isQuickTime = false;
        this.metadataTags = {};
        this.currentMetadataKeys = null;
        this.isFragmented = false;
        this.fragmentTrackDefaults = [];
        this.currentFragment = null;
        /**
         * Caches the last fragment that was read. Based on the assumption that there will be multiple reads to the
         * same fragment in quick succession.
         */ this.lastReadFragment = null;
        this.reader = input._reader;
    }
    async computeDuration() {
        const tracks = await this.getTracks();
        const trackDurations = await Promise.all(tracks.map((x)=>x.computeDuration()));
        return Math.max(0, ...trackDurations);
    }
    async getTracks() {
        await this.readMetadata();
        return this.tracks.map((track)=>track.inputTrack);
    }
    async getMimeType() {
        await this.readMetadata();
        const codecStrings = await Promise.all(this.tracks.map((x)=>x.inputTrack.getCodecParameterString()));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildIsobmffMimeType"])({
            isQuickTime: this.isQuickTime,
            hasVideo: this.tracks.some((x)=>x.info?.type === 'video'),
            hasAudio: this.tracks.some((x)=>x.info?.type === 'audio'),
            codecStrings: codecStrings.filter(Boolean)
        });
    }
    async getMetadataTags() {
        await this.readMetadata();
        return this.metadataTags;
    }
    readMetadata() {
        return this.metadataPromise ??= (async ()=>{
            let currentPos = 0;
            while(true){
                let slice = this.reader.requestSliceRange(currentPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"]);
                if (slice instanceof Promise) slice = await slice;
                if (!slice) break;
                const startPos = currentPos;
                const boxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(slice);
                if (!boxInfo) {
                    break;
                }
                if (boxInfo.name === 'ftyp') {
                    const majorBrand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAscii"])(slice, 4);
                    this.isQuickTime = majorBrand === 'qt  ';
                } else if (boxInfo.name === 'moov') {
                    // Found moov, load it
                    let moovSlice = this.reader.requestSlice(slice.filePos, boxInfo.contentSize);
                    if (moovSlice instanceof Promise) moovSlice = await moovSlice;
                    if (!moovSlice) break;
                    this.moovSlice = moovSlice;
                    this.readContiguousBoxes(this.moovSlice);
                    // Put default tracks first
                    this.tracks.sort((a, b)=>Number(b.disposition.default) - Number(a.disposition.default));
                    for (const track of this.tracks){
                        // Modify the edit list offset based on the previous segment durations. They are in different
                        // timescales, so we first convert to seconds and then into the track timescale.
                        const previousSegmentDurationsInSeconds = track.editListPreviousSegmentDurations / this.movieTimescale;
                        track.editListOffset -= Math.round(previousSegmentDurationsInSeconds * track.timescale);
                    }
                    break;
                }
                currentPos = startPos + boxInfo.totalSize;
            }
            if (this.isFragmented && this.reader.fileSize !== null) {
                // The last 4 bytes may contain the size of the mfra box at the end of the file
                let lastWordSlice = this.reader.requestSlice(this.reader.fileSize - 4, 4);
                if (lastWordSlice instanceof Promise) lastWordSlice = await lastWordSlice;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(lastWordSlice);
                const lastWord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(lastWordSlice);
                const potentialMfraPos = this.reader.fileSize - lastWord;
                if (potentialMfraPos >= 0 && potentialMfraPos <= this.reader.fileSize - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"]) {
                    let mfraHeaderSlice = this.reader.requestSliceRange(potentialMfraPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"]);
                    if (mfraHeaderSlice instanceof Promise) mfraHeaderSlice = await mfraHeaderSlice;
                    if (mfraHeaderSlice) {
                        const boxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(mfraHeaderSlice);
                        if (boxInfo && boxInfo.name === 'mfra') {
                            // We found the mfra box, allowing for much better random access. Let's parse it.
                            let mfraSlice = this.reader.requestSlice(mfraHeaderSlice.filePos, boxInfo.contentSize);
                            if (mfraSlice instanceof Promise) mfraSlice = await mfraSlice;
                            if (mfraSlice) {
                                this.readContiguousBoxes(mfraSlice);
                            }
                        }
                    }
                }
            }
        })();
    }
    getSampleTableForTrack(internalTrack) {
        if (internalTrack.sampleTable) {
            return internalTrack.sampleTable;
        }
        const sampleTable = {
            sampleTimingEntries: [],
            sampleCompositionTimeOffsets: [],
            sampleSizes: [],
            keySampleIndices: null,
            chunkOffsets: [],
            sampleToChunk: [],
            presentationTimestamps: null,
            presentationTimestampIndexMap: null
        };
        internalTrack.sampleTable = sampleTable;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.moovSlice);
        const stblContainerSlice = this.moovSlice.slice(internalTrack.sampleTableByteOffset);
        this.currentTrack = internalTrack;
        this.traverseBox(stblContainerSlice);
        this.currentTrack = null;
        const isPcmCodec = internalTrack.info?.type === 'audio' && internalTrack.info.codec && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PCM_AUDIO_CODECS"].includes(internalTrack.info.codec);
        if (isPcmCodec && sampleTable.sampleCompositionTimeOffsets.length === 0) {
            // If the audio has PCM samples, the way the samples are defined in the sample table is somewhat
            // suboptimal: Each individual audio sample is its own sample, meaning we can have 48000 samples per second.
            // Because we treat each sample as its own atomic unit that can be decoded, this would lead to a huge
            // amount of very short samples for PCM audio. So instead, we make a transformation: If the audio is in PCM,
            // we say that each chunk (that normally holds many samples) now is one big sample. We can this because
            // the samples in the chunk are contiguous and the format is PCM, so the entire chunk as one thing still
            // encodes valid audio information.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(internalTrack.info?.type === 'audio');
            const pcmInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(internalTrack.info.codec);
            const newSampleTimingEntries = [];
            const newSampleSizes = [];
            for(let i = 0; i < sampleTable.sampleToChunk.length; i++){
                const chunkEntry = sampleTable.sampleToChunk[i];
                const nextEntry = sampleTable.sampleToChunk[i + 1];
                const chunkCount = (nextEntry ? nextEntry.startChunkIndex : sampleTable.chunkOffsets.length) - chunkEntry.startChunkIndex;
                for(let j = 0; j < chunkCount; j++){
                    const startSampleIndex = chunkEntry.startSampleIndex + j * chunkEntry.samplesPerChunk;
                    const endSampleIndex = startSampleIndex + chunkEntry.samplesPerChunk; // Exclusive, outside of chunk
                    const startTimingEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleTimingEntries, startSampleIndex, (x)=>x.startIndex);
                    const startTimingEntry = sampleTable.sampleTimingEntries[startTimingEntryIndex];
                    const endTimingEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleTimingEntries, endSampleIndex, (x)=>x.startIndex);
                    const endTimingEntry = sampleTable.sampleTimingEntries[endTimingEntryIndex];
                    const firstSampleTimestamp = startTimingEntry.startDecodeTimestamp + (startSampleIndex - startTimingEntry.startIndex) * startTimingEntry.delta;
                    const lastSampleTimestamp = endTimingEntry.startDecodeTimestamp + (endSampleIndex - endTimingEntry.startIndex) * endTimingEntry.delta;
                    const delta = lastSampleTimestamp - firstSampleTimestamp;
                    const lastSampleTimingEntry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(newSampleTimingEntries);
                    if (lastSampleTimingEntry && lastSampleTimingEntry.delta === delta) {
                        lastSampleTimingEntry.count++;
                    } else {
                        // One sample for the entire chunk
                        newSampleTimingEntries.push({
                            startIndex: chunkEntry.startChunkIndex + j,
                            startDecodeTimestamp: firstSampleTimestamp,
                            count: 1,
                            delta
                        });
                    }
                    // Instead of determining the chunk's size by looping over the samples sizes in the sample table, we
                    // can directly compute it as we know how many PCM frames are in this chunk, and the size of each
                    // PCM frame. This also improves compatibility with some files which fail to write proper sample
                    // size values into their sample tables in the PCM case.
                    const chunkSize = chunkEntry.samplesPerChunk * pcmInfo.sampleSize * internalTrack.info.numberOfChannels;
                    newSampleSizes.push(chunkSize);
                }
                chunkEntry.startSampleIndex = chunkEntry.startChunkIndex;
                chunkEntry.samplesPerChunk = 1;
            }
            sampleTable.sampleTimingEntries = newSampleTimingEntries;
            sampleTable.sampleSizes = newSampleSizes;
        }
        if (sampleTable.sampleCompositionTimeOffsets.length > 0) {
            // If composition time offsets are defined, we must build a list of all presentation timestamps and then
            // sort them
            sampleTable.presentationTimestamps = [];
            for (const entry of sampleTable.sampleTimingEntries){
                for(let i = 0; i < entry.count; i++){
                    sampleTable.presentationTimestamps.push({
                        presentationTimestamp: entry.startDecodeTimestamp + i * entry.delta,
                        sampleIndex: entry.startIndex + i
                    });
                }
            }
            for (const entry of sampleTable.sampleCompositionTimeOffsets){
                for(let i = 0; i < entry.count; i++){
                    const sampleIndex = entry.startIndex + i;
                    const sample = sampleTable.presentationTimestamps[sampleIndex];
                    if (!sample) {
                        continue;
                    }
                    sample.presentationTimestamp += entry.offset;
                }
            }
            sampleTable.presentationTimestamps.sort((a, b)=>a.presentationTimestamp - b.presentationTimestamp);
            sampleTable.presentationTimestampIndexMap = Array(sampleTable.presentationTimestamps.length).fill(-1);
            for(let i = 0; i < sampleTable.presentationTimestamps.length; i++){
                sampleTable.presentationTimestampIndexMap[sampleTable.presentationTimestamps[i].sampleIndex] = i;
            }
        } else {
        // If they're not defined, we can simply use the decode timestamps as presentation timestamps
        }
        return sampleTable;
    }
    async readFragment(startPos) {
        if (this.lastReadFragment?.moofOffset === startPos) {
            return this.lastReadFragment;
        }
        let headerSlice = this.reader.requestSliceRange(startPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"]);
        if (headerSlice instanceof Promise) headerSlice = await headerSlice;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(headerSlice);
        const moofBoxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(headerSlice);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(moofBoxInfo?.name === 'moof');
        let entireSlice = this.reader.requestSlice(startPos, moofBoxInfo.totalSize);
        if (entireSlice instanceof Promise) entireSlice = await entireSlice;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(entireSlice);
        this.traverseBox(entireSlice);
        const fragment = this.lastReadFragment;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(fragment && fragment.moofOffset === startPos);
        for (const [, trackData] of fragment.trackData){
            const track = trackData.track;
            const { fragmentPositionCache } = track;
            if (!trackData.startTimestampIsFinal) {
                // It may be that some tracks don't define the base decode time, i.e. when the fragment begins. This
                // we'll need to figure out the start timestamp another way. We'll compute the timestamp by accessing
                // the lookup entries and fragment cache, which works out nicely with the lookup algorithm: If these
                // exist, then the lookup will automatically start at the furthest possible point. If they don't, the
                // lookup starts sequentially from the start, incrementally summing up all fragment durations. It's sort
                // of implicit, but it ends up working nicely.
                const lookupEntry = track.fragmentLookupTable.find((x)=>x.moofOffset === fragment.moofOffset);
                if (lookupEntry) {
                    // There's a lookup entry, let's use its timestamp
                    offsetFragmentTrackDataByTimestamp(trackData, lookupEntry.timestamp);
                } else {
                    const lastCacheIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(fragmentPositionCache, fragment.moofOffset - 1, (x)=>x.moofOffset);
                    if (lastCacheIndex !== -1) {
                        // Let's use the timestamp of the previous fragment in the cache
                        const lastCache = fragmentPositionCache[lastCacheIndex];
                        offsetFragmentTrackDataByTimestamp(trackData, lastCache.endTimestamp);
                    } else {
                    // We're the first fragment I guess, "offset by 0"
                    }
                }
                trackData.startTimestampIsFinal = true;
            }
            // Let's remember that a fragment with a given timestamp is here, speeding up future lookups if no
            // lookup table exists
            const insertionIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(fragmentPositionCache, trackData.startTimestamp, (x)=>x.startTimestamp);
            if (insertionIndex === -1 || fragmentPositionCache[insertionIndex].moofOffset !== fragment.moofOffset) {
                fragmentPositionCache.splice(insertionIndex + 1, 0, {
                    moofOffset: fragment.moofOffset,
                    startTimestamp: trackData.startTimestamp,
                    endTimestamp: trackData.endTimestamp
                });
            }
        }
        return fragment;
    }
    readContiguousBoxes(slice) {
        const startIndex = slice.filePos;
        while(slice.filePos - startIndex <= slice.length - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"]){
            const foundBox = this.traverseBox(slice);
            if (!foundBox) {
                break;
            }
        }
    }
    // eslint-disable-next-line @stylistic/generator-star-spacing
    *iterateContiguousBoxes(slice) {
        const startIndex = slice.filePos;
        while(slice.filePos - startIndex <= slice.length - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"]){
            const startPos = slice.filePos;
            const boxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(slice);
            if (!boxInfo) {
                break;
            }
            yield {
                boxInfo,
                slice
            };
            slice.filePos = startPos + boxInfo.totalSize;
        }
    }
    traverseBox(slice) {
        const startPos = slice.filePos;
        const boxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(slice);
        if (!boxInfo) {
            return false;
        }
        const contentStartPos = slice.filePos;
        const boxEndPos = startPos + boxInfo.totalSize;
        switch(boxInfo.name){
            case 'mdia':
            case 'minf':
            case 'dinf':
            case 'mfra':
            case 'edts':
                {
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                }
                ;
                break;
            case 'mvhd':
                {
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    if (version === 1) {
                        slice.skip(8 + 8);
                        this.movieTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        this.movieDurationInTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                    } else {
                        slice.skip(4 + 4);
                        this.movieTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        this.movieDurationInTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                }
                ;
                break;
            case 'trak':
                {
                    const track = {
                        id: -1,
                        demuxer: this,
                        inputTrack: null,
                        disposition: {
                            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_TRACK_DISPOSITION"]
                        },
                        info: null,
                        timescale: -1,
                        durationInMovieTimescale: -1,
                        durationInMediaTimescale: -1,
                        rotation: 0,
                        internalCodecId: null,
                        name: null,
                        languageCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"],
                        sampleTableByteOffset: -1,
                        sampleTable: null,
                        fragmentLookupTable: [],
                        currentFragmentState: null,
                        fragmentPositionCache: [],
                        editListPreviousSegmentDurations: 0,
                        editListOffset: 0
                    };
                    this.currentTrack = track;
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    if (track.id !== -1 && track.timescale !== -1 && track.info !== null) {
                        if (track.info.type === 'video' && track.info.width !== -1) {
                            const videoTrack = track;
                            track.inputTrack = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputVideoTrack"](this.input, new IsobmffVideoTrackBacking(videoTrack));
                            this.tracks.push(track);
                        } else if (track.info.type === 'audio' && track.info.numberOfChannels !== -1) {
                            const audioTrack = track;
                            track.inputTrack = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputAudioTrack"](this.input, new IsobmffAudioTrackBacking(audioTrack));
                            this.tracks.push(track);
                        }
                    }
                    this.currentTrack = null;
                }
                ;
                break;
            case 'tkhd':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU24Be"])(slice);
                    // Spec says disabled tracks are to be treated like they don't exist, but in practice, they are treated
                    // more like non-default tracks.
                    const trackEnabled = !!(flags & 0x1);
                    track.disposition.default = trackEnabled;
                    // Skip over creation & modification time to reach the track ID
                    if (version === 0) {
                        slice.skip(8);
                        track.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        slice.skip(4);
                        track.durationInMovieTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    } else if (version === 1) {
                        slice.skip(16);
                        track.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        slice.skip(4);
                        track.durationInMovieTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                    } else {
                        throw new Error(`Incorrect track header version ${version}.`);
                    }
                    slice.skip(2 * 4 + 2 + 2 + 2 + 2);
                    const matrix = [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_2_30"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_2_30"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_2_30"])(slice)
                    ];
                    const rotation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeRotation"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["roundToMultiple"])(extractRotationFromMatrix(matrix), 90));
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(rotation === 0 || rotation === 90 || rotation === 180 || rotation === 270);
                    track.rotation = rotation;
                }
                ;
                break;
            case 'elst':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    let relevantEntryFound = false;
                    let previousSegmentDurations = 0;
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const segmentDuration = version === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        const mediaTime = version === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI64Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice);
                        const mediaRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFixed_16_16"])(slice);
                        if (segmentDuration === 0) {
                            continue;
                        }
                        if (relevantEntryFound) {
                            console.warn('Unsupported edit list: multiple edits are not currently supported. Only using first edit.');
                            break;
                        }
                        if (mediaTime === -1) {
                            previousSegmentDurations += segmentDuration;
                            continue;
                        }
                        if (mediaRate !== 1) {
                            console.warn('Unsupported edit list entry: media rate must be 1.');
                            break;
                        }
                        track.editListPreviousSegmentDurations = previousSegmentDurations;
                        track.editListOffset = mediaTime;
                        relevantEntryFound = true;
                    }
                }
                ;
                break;
            case 'mdhd':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    if (version === 0) {
                        slice.skip(8);
                        track.timescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        track.durationInMediaTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    } else if (version === 1) {
                        slice.skip(16);
                        track.timescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        track.durationInMediaTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                    }
                    let language = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                    if (language > 0) {
                        track.languageCode = '';
                        for(let i = 0; i < 3; i++){
                            track.languageCode = String.fromCharCode(0x60 + (language & 0b11111)) + track.languageCode;
                            language >>= 5;
                        }
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isIso639Dash2LanguageCode"])(track.languageCode)) {
                            // Sometimes the bytes are garbage
                            track.languageCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"];
                        }
                    }
                }
                ;
                break;
            case 'hdlr':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    slice.skip(8); // Version + flags + pre-defined
                    const handlerType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAscii"])(slice, 4);
                    if (handlerType === 'vide') {
                        track.info = {
                            type: 'video',
                            width: -1,
                            height: -1,
                            codec: null,
                            codecDescription: null,
                            colorSpace: null,
                            avcType: null,
                            avcCodecInfo: null,
                            hevcCodecInfo: null,
                            vp9CodecInfo: null,
                            av1CodecInfo: null
                        };
                    } else if (handlerType === 'soun') {
                        track.info = {
                            type: 'audio',
                            numberOfChannels: -1,
                            sampleRate: -1,
                            codec: null,
                            codecDescription: null,
                            aacCodecInfo: null
                        };
                    }
                }
                ;
                break;
            case 'stbl':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    track.sampleTableByteOffset = startPos;
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                }
                ;
                break;
            case 'stsd':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (track.info === null || track.sampleTable) {
                        break;
                    }
                    const stsdVersion = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    const entries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entries; i++){
                        const sampleBoxStartPos = slice.filePos;
                        const sampleBoxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(slice);
                        if (!sampleBoxInfo) {
                            break;
                        }
                        track.internalCodecId = sampleBoxInfo.name;
                        const lowercaseBoxName = sampleBoxInfo.name.toLowerCase();
                        if (track.info.type === 'video') {
                            if (lowercaseBoxName === 'avc1' || lowercaseBoxName === 'avc3') {
                                track.info.codec = 'avc';
                                track.info.avcType = lowercaseBoxName === 'avc1' ? 1 : 3;
                            } else if (lowercaseBoxName === 'hvc1' || lowercaseBoxName === 'hev1') {
                                track.info.codec = 'hevc';
                            } else if (lowercaseBoxName === 'vp08') {
                                track.info.codec = 'vp8';
                            } else if (lowercaseBoxName === 'vp09') {
                                track.info.codec = 'vp9';
                            } else if (lowercaseBoxName === 'av01') {
                                track.info.codec = 'av1';
                            } else {
                                console.warn(`Unsupported video codec (sample entry type '${sampleBoxInfo.name}').`);
                            }
                            slice.skip(6 * 1 + 2 + 2 + 2 + 3 * 4);
                            track.info.width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                            track.info.height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                            slice.skip(4 + 4 + 4 + 2 + 32 + 2 + 2);
                            this.readContiguousBoxes(slice.slice(slice.filePos, sampleBoxStartPos + sampleBoxInfo.totalSize - slice.filePos));
                        } else {
                            if (lowercaseBoxName === 'mp4a') {
                            // We don't know the codec yet (might be AAC, might be MP3), need to read the esds box
                            } else if (lowercaseBoxName === 'opus') {
                                track.info.codec = 'opus';
                            } else if (lowercaseBoxName === 'flac') {
                                track.info.codec = 'flac';
                            } else if (lowercaseBoxName === 'twos' || lowercaseBoxName === 'sowt' || lowercaseBoxName === 'raw ' || lowercaseBoxName === 'in24' || lowercaseBoxName === 'in32' || lowercaseBoxName === 'fl32' || lowercaseBoxName === 'fl64' || lowercaseBoxName === 'lpcm' || lowercaseBoxName === 'ipcm' // ISO/IEC 23003-5
                             || lowercaseBoxName === 'fpcm' // "
                            ) {
                            // It's PCM
                            // developer.apple.com/documentation/quicktime-file-format/sound_sample_descriptions/
                            } else if (lowercaseBoxName === 'ulaw') {
                                track.info.codec = 'ulaw';
                            } else if (lowercaseBoxName === 'alaw') {
                                track.info.codec = 'alaw';
                            } else {
                                console.warn(`Unsupported audio codec (sample entry type '${sampleBoxInfo.name}').`);
                            }
                            slice.skip(6 * 1 + 2);
                            const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                            slice.skip(3 * 2);
                            let channelCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                            let sampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                            slice.skip(2 * 2);
                            // Can't use fixed16_16 as that's signed
                            let sampleRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice) / 0x10000;
                            if (stsdVersion === 0 && version > 0) {
                                // Additional QuickTime fields
                                if (version === 1) {
                                    slice.skip(4);
                                    sampleSize = 8 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                                    slice.skip(2 * 4);
                                } else if (version === 2) {
                                    slice.skip(4);
                                    sampleRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readF64Be"])(slice);
                                    channelCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                                    slice.skip(4); // Always 0x7f000000
                                    sampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                                    slice.skip(2 * 4);
                                    if (lowercaseBoxName === 'lpcm') {
                                        const bytesPerSample = sampleSize + 7 >> 3;
                                        const isFloat = Boolean(flags & 1);
                                        const isBigEndian = Boolean(flags & 2);
                                        const sFlags = flags & 4 ? -1 : 0; // I guess it means "signed flags" or something?
                                        if (sampleSize > 0 && sampleSize <= 64) {
                                            if (isFloat) {
                                                if (sampleSize === 32) {
                                                    track.info.codec = isBigEndian ? 'pcm-f32be' : 'pcm-f32';
                                                }
                                            } else {
                                                if (sFlags & 1 << bytesPerSample - 1) {
                                                    if (bytesPerSample === 1) {
                                                        track.info.codec = 'pcm-s8';
                                                    } else if (bytesPerSample === 2) {
                                                        track.info.codec = isBigEndian ? 'pcm-s16be' : 'pcm-s16';
                                                    } else if (bytesPerSample === 3) {
                                                        track.info.codec = isBigEndian ? 'pcm-s24be' : 'pcm-s24';
                                                    } else if (bytesPerSample === 4) {
                                                        track.info.codec = isBigEndian ? 'pcm-s32be' : 'pcm-s32';
                                                    }
                                                } else {
                                                    if (bytesPerSample === 1) {
                                                        track.info.codec = 'pcm-u8';
                                                    }
                                                }
                                            }
                                        }
                                        if (track.info.codec === null) {
                                            console.warn('Unsupported PCM format.');
                                        }
                                    }
                                }
                            }
                            if (track.info.codec === 'opus') {
                                sampleRate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OPUS_SAMPLE_RATE"]; // Always the same
                            }
                            track.info.numberOfChannels = channelCount;
                            track.info.sampleRate = sampleRate;
                            // PCM codec assignments
                            if (lowercaseBoxName === 'twos') {
                                if (sampleSize === 8) {
                                    track.info.codec = 'pcm-s8';
                                } else if (sampleSize === 16) {
                                    track.info.codec = 'pcm-s16be';
                                } else {
                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'twos'.`);
                                    track.info.codec = null;
                                }
                            } else if (lowercaseBoxName === 'sowt') {
                                if (sampleSize === 8) {
                                    track.info.codec = 'pcm-s8';
                                } else if (sampleSize === 16) {
                                    track.info.codec = 'pcm-s16';
                                } else {
                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'sowt'.`);
                                    track.info.codec = null;
                                }
                            } else if (lowercaseBoxName === 'raw ') {
                                track.info.codec = 'pcm-u8';
                            } else if (lowercaseBoxName === 'in24') {
                                track.info.codec = 'pcm-s24be';
                            } else if (lowercaseBoxName === 'in32') {
                                track.info.codec = 'pcm-s32be';
                            } else if (lowercaseBoxName === 'fl32') {
                                track.info.codec = 'pcm-f32be';
                            } else if (lowercaseBoxName === 'fl64') {
                                track.info.codec = 'pcm-f64be';
                            } else if (lowercaseBoxName === 'ipcm') {
                                track.info.codec = 'pcm-s16be'; // Placeholder, will be adjusted by the pcmC box
                            } else if (lowercaseBoxName === 'fpcm') {
                                track.info.codec = 'pcm-f32be'; // Placeholder, will be adjusted by the pcmC box
                            }
                            this.readContiguousBoxes(slice.slice(slice.filePos, sampleBoxStartPos + sampleBoxInfo.totalSize - slice.filePos));
                        }
                    }
                }
                ;
                break;
            case 'avcC':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info);
                    track.info.codecDescription = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, boxInfo.contentSize);
                }
                ;
                break;
            case 'hvcC':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info);
                    track.info.codecDescription = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, boxInfo.contentSize);
                }
                ;
                break;
            case 'vpcC':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'video');
                    slice.skip(4); // Version + flags
                    const profile = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const level = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const thirdByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const bitDepth = thirdByte >> 4;
                    const chromaSubsampling = thirdByte >> 1 & 0b111;
                    const videoFullRangeFlag = thirdByte & 1;
                    const colourPrimaries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const transferCharacteristics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const matrixCoefficients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    track.info.vp9CodecInfo = {
                        profile,
                        level,
                        bitDepth,
                        chromaSubsampling,
                        videoFullRangeFlag,
                        colourPrimaries,
                        transferCharacteristics,
                        matrixCoefficients
                    };
                }
                ;
                break;
            case 'av1C':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'video');
                    slice.skip(1); // Marker + version
                    const secondByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const profile = secondByte >> 5;
                    const level = secondByte & 0b11111;
                    const thirdByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const tier = thirdByte >> 7;
                    const highBitDepth = thirdByte >> 6 & 1;
                    const twelveBit = thirdByte >> 5 & 1;
                    const monochrome = thirdByte >> 4 & 1;
                    const chromaSubsamplingX = thirdByte >> 3 & 1;
                    const chromaSubsamplingY = thirdByte >> 2 & 1;
                    const chromaSamplePosition = thirdByte & 0b11;
                    // Logic from https://aomediacodec.github.io/av1-spec/av1-spec.pdf
                    const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
                    track.info.av1CodecInfo = {
                        profile,
                        level,
                        tier,
                        bitDepth,
                        monochrome,
                        chromaSubsamplingX,
                        chromaSubsamplingY,
                        chromaSamplePosition
                    };
                }
                ;
                break;
            case 'colr':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'video');
                    const colourType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAscii"])(slice, 4);
                    if (colourType !== 'nclx') {
                        break;
                    }
                    const colourPrimaries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                    const transferCharacteristics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                    const matrixCoefficients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                    const fullRangeFlag = Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice) & 0x80);
                    track.info.colorSpace = {
                        primaries: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COLOR_PRIMARIES_MAP_INVERSE"][colourPrimaries],
                        transfer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TRANSFER_CHARACTERISTICS_MAP_INVERSE"][transferCharacteristics],
                        matrix: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MATRIX_COEFFICIENTS_MAP_INVERSE"][matrixCoefficients],
                        fullRange: fullRangeFlag
                    };
                }
                ;
                break;
            case 'wave':
                {
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                }
                ;
                break;
            case 'esds':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'audio');
                    slice.skip(4); // Version + flags
                    const tag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(tag === 0x03); // ES Descriptor
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readIsomVariableInteger"])(slice); // Length
                    slice.skip(2); // ES ID
                    const mixed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const streamDependenceFlag = (mixed & 0x80) !== 0;
                    const urlFlag = (mixed & 0x40) !== 0;
                    const ocrStreamFlag = (mixed & 0x20) !== 0;
                    if (streamDependenceFlag) {
                        slice.skip(2);
                    }
                    if (urlFlag) {
                        const urlLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                        slice.skip(urlLength);
                    }
                    if (ocrStreamFlag) {
                        slice.skip(2);
                    }
                    const decoderConfigTag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(decoderConfigTag === 0x04); // DecoderConfigDescriptor
                    const decoderConfigDescriptorLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readIsomVariableInteger"])(slice); // Length
                    const payloadStart = slice.filePos;
                    const objectTypeIndication = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    if (objectTypeIndication === 0x40 || objectTypeIndication === 0x67) {
                        track.info.codec = 'aac';
                        track.info.aacCodecInfo = {
                            isMpeg2: objectTypeIndication === 0x67
                        };
                    } else if (objectTypeIndication === 0x69 || objectTypeIndication === 0x6b) {
                        track.info.codec = 'mp3';
                    } else if (objectTypeIndication === 0xdd) {
                        track.info.codec = 'vorbis'; // "nonstandard, gpac uses it" - FFmpeg
                    } else {
                        console.warn(`Unsupported audio codec (objectTypeIndication ${objectTypeIndication}) - discarding track.`);
                    }
                    slice.skip(1 + 3 + 4 + 4);
                    if (decoderConfigDescriptorLength > slice.filePos - payloadStart) {
                        // There's a DecoderSpecificInfo at the end, let's read it
                        const decoderSpecificInfoTag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(decoderSpecificInfoTag === 0x05); // DecoderSpecificInfo
                        const decoderSpecificInfoLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readIsomVariableInteger"])(slice);
                        track.info.codecDescription = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, decoderSpecificInfoLength);
                        if (track.info.codec === 'aac') {
                            // Let's try to deduce more accurate values directly from the AudioSpecificConfig:
                            const audioSpecificConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAacAudioSpecificConfig"])(track.info.codecDescription);
                            if (audioSpecificConfig.numberOfChannels !== null) {
                                track.info.numberOfChannels = audioSpecificConfig.numberOfChannels;
                            }
                            if (audioSpecificConfig.sampleRate !== null) {
                                track.info.sampleRate = audioSpecificConfig.sampleRate;
                            }
                        }
                    }
                }
                ;
                break;
            case 'enda':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'audio');
                    const littleEndian = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice) & 0xff; // 0xff is from FFmpeg
                    if (littleEndian) {
                        if (track.info.codec === 'pcm-s16be') {
                            track.info.codec = 'pcm-s16';
                        } else if (track.info.codec === 'pcm-s24be') {
                            track.info.codec = 'pcm-s24';
                        } else if (track.info.codec === 'pcm-s32be') {
                            track.info.codec = 'pcm-s32';
                        } else if (track.info.codec === 'pcm-f32be') {
                            track.info.codec = 'pcm-f32';
                        } else if (track.info.codec === 'pcm-f64be') {
                            track.info.codec = 'pcm-f64';
                        }
                    }
                }
                ;
                break;
            case 'pcmC':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'audio');
                    slice.skip(1 + 3); // Version + flags
                    // ISO/IEC 23003-5
                    const formatFlags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const isLittleEndian = Boolean(formatFlags & 0x01);
                    const pcmSampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    if (track.info.codec === 'pcm-s16be') {
                        // ipcm
                        if (isLittleEndian) {
                            if (pcmSampleSize === 16) {
                                track.info.codec = 'pcm-s16';
                            } else if (pcmSampleSize === 24) {
                                track.info.codec = 'pcm-s24';
                            } else if (pcmSampleSize === 32) {
                                track.info.codec = 'pcm-s32';
                            } else {
                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);
                                track.info.codec = null;
                            }
                        } else {
                            if (pcmSampleSize === 16) {
                                track.info.codec = 'pcm-s16be';
                            } else if (pcmSampleSize === 24) {
                                track.info.codec = 'pcm-s24be';
                            } else if (pcmSampleSize === 32) {
                                track.info.codec = 'pcm-s32be';
                            } else {
                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);
                                track.info.codec = null;
                            }
                        }
                    } else if (track.info.codec === 'pcm-f32be') {
                        // fpcm
                        if (isLittleEndian) {
                            if (pcmSampleSize === 32) {
                                track.info.codec = 'pcm-f32';
                            } else if (pcmSampleSize === 64) {
                                track.info.codec = 'pcm-f64';
                            } else {
                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);
                                track.info.codec = null;
                            }
                        } else {
                            if (pcmSampleSize === 32) {
                                track.info.codec = 'pcm-f32be';
                            } else if (pcmSampleSize === 64) {
                                track.info.codec = 'pcm-f64be';
                            } else {
                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);
                                track.info.codec = null;
                            }
                        }
                    }
                    break;
                }
                ;
            case 'dOps':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'audio');
                    slice.skip(1); // Version
                    // https://www.opus-codec.org/docs/opus_in_isobmff.html
                    const outputChannelCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const preSkip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"])(slice);
                    const inputSampleRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const outputGain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI16Be"])(slice);
                    const channelMappingFamily = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    let channelMappingTable;
                    if (channelMappingFamily !== 0) {
                        channelMappingTable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, 2 + outputChannelCount);
                    } else {
                        channelMappingTable = new Uint8Array(0);
                    }
                    // https://datatracker.ietf.org/doc/html/draft-ietf-codec-oggopus-06
                    const description = new Uint8Array(8 + 1 + 1 + 2 + 4 + 2 + 1 + channelMappingTable.byteLength);
                    const view = new DataView(description.buffer);
                    view.setUint32(0, 0x4f707573, false); // 'Opus'
                    view.setUint32(4, 0x48656164, false); // 'Head'
                    view.setUint8(8, 1); // Version
                    view.setUint8(9, outputChannelCount);
                    view.setUint16(10, preSkip, true);
                    view.setUint32(12, inputSampleRate, true);
                    view.setInt16(16, outputGain, true);
                    view.setUint8(18, channelMappingFamily);
                    description.set(channelMappingTable, 19);
                    track.info.codecDescription = description;
                    track.info.numberOfChannels = outputChannelCount;
                // Don't copy the input sample rate, irrelevant, and output sample rate is fixed
                }
                ;
                break;
            case 'dfLa':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.info?.type === 'audio');
                    slice.skip(4); // Version + flags
                    // https://datatracker.ietf.org/doc/rfc9639/
                    const BLOCK_TYPE_MASK = 0x7f;
                    const LAST_METADATA_BLOCK_FLAG_MASK = 0x80;
                    const startPos = slice.filePos;
                    while(slice.filePos < boxEndPos){
                        const flagAndType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                        const metadataBlockLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU24Be"])(slice);
                        const type = flagAndType & BLOCK_TYPE_MASK;
                        // It's a STREAMINFO block; let's extract the actual sample rate and channel count
                        if (type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FlacBlockType"].STREAMINFO) {
                            slice.skip(10);
                            // Extract sample rate and channel count
                            const word = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                            const sampleRate = word >>> 12;
                            const numberOfChannels = (word >> 9 & 0b111) + 1;
                            track.info.sampleRate = sampleRate;
                            track.info.numberOfChannels = numberOfChannels;
                            slice.skip(20);
                        } else {
                            // Simply skip ahead to the next block
                            slice.skip(metadataBlockLength);
                        }
                        if (flagAndType & LAST_METADATA_BLOCK_FLAG_MASK) {
                            break;
                        }
                    }
                    const endPos = slice.filePos;
                    slice.filePos = startPos;
                    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, endPos - startPos);
                    const description = new Uint8Array(4 + bytes.byteLength);
                    const view = new DataView(description.buffer);
                    view.setUint32(0, 0x664c6143, false); // 'fLaC'
                    description.set(bytes, 4);
                    // Set the codec description to be 'fLaC' + all metadata blocks
                    track.info.codecDescription = description;
                }
                ;
                break;
            case 'stts':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    let currentIndex = 0;
                    let currentTimestamp = 0;
                    for(let i = 0; i < entryCount; i++){
                        const sampleCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        const sampleDelta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        track.sampleTable.sampleTimingEntries.push({
                            startIndex: currentIndex,
                            startDecodeTimestamp: currentTimestamp,
                            count: sampleCount,
                            delta: sampleDelta
                        });
                        currentIndex += sampleCount;
                        currentTimestamp += sampleCount * sampleDelta;
                    }
                }
                ;
                break;
            case 'ctts':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(1 + 3); // Version + flags
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    let sampleIndex = 0;
                    for(let i = 0; i < entryCount; i++){
                        const sampleCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        const sampleOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice);
                        track.sampleTable.sampleCompositionTimeOffsets.push({
                            startIndex: sampleIndex,
                            count: sampleCount,
                            offset: sampleOffset
                        });
                        sampleIndex += sampleCount;
                    }
                }
                ;
                break;
            case 'stsz':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    const sampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const sampleCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    if (sampleSize === 0) {
                        for(let i = 0; i < sampleCount; i++){
                            const sampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                            track.sampleTable.sampleSizes.push(sampleSize);
                        }
                    } else {
                        track.sampleTable.sampleSizes.push(sampleSize);
                    }
                }
                ;
                break;
            case 'stz2':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    slice.skip(3); // Reserved
                    const fieldSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice); // in bits
                    const sampleCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, Math.ceil(sampleCount * fieldSize / 8));
                    const bitstream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Bitstream"](bytes);
                    for(let i = 0; i < sampleCount; i++){
                        const sampleSize = bitstream.readBits(fieldSize);
                        track.sampleTable.sampleSizes.push(sampleSize);
                    }
                }
                ;
                break;
            case 'stss':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    track.sampleTable.keySampleIndices = [];
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const sampleIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice) - 1; // Convert to 0-indexed
                        track.sampleTable.keySampleIndices.push(sampleIndex);
                    }
                    if (track.sampleTable.keySampleIndices[0] !== 0) {
                        // Some files don't mark the first sample a key sample, which is basically almost always incorrect.
                        // Here, we correct for that mistake:
                        track.sampleTable.keySampleIndices.unshift(0);
                    }
                }
                ;
                break;
            case 'stsc':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4);
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const startChunkIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice) - 1; // Convert to 0-indexed
                        const samplesPerChunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        const sampleDescriptionIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        track.sampleTable.sampleToChunk.push({
                            startSampleIndex: -1,
                            startChunkIndex,
                            samplesPerChunk,
                            sampleDescriptionIndex
                        });
                    }
                    let startSampleIndex = 0;
                    for(let i = 0; i < track.sampleTable.sampleToChunk.length; i++){
                        track.sampleTable.sampleToChunk[i].startSampleIndex = startSampleIndex;
                        if (i < track.sampleTable.sampleToChunk.length - 1) {
                            const nextChunk = track.sampleTable.sampleToChunk[i + 1];
                            const chunkCount = nextChunk.startChunkIndex - track.sampleTable.sampleToChunk[i].startChunkIndex;
                            startSampleIndex += chunkCount * track.sampleTable.sampleToChunk[i].samplesPerChunk;
                        }
                    }
                }
                ;
                break;
            case 'stco':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const chunkOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        track.sampleTable.chunkOffsets.push(chunkOffset);
                    }
                }
                ;
                break;
            case 'co64':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    if (!track.sampleTable) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const chunkOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                        track.sampleTable.chunkOffsets.push(chunkOffset);
                    }
                }
                ;
                break;
            case 'mvex':
                {
                    this.isFragmented = true;
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                }
                ;
                break;
            case 'mehd':
                {
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    const fragmentDuration = version === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    this.movieDurationInTimescale = fragmentDuration;
                }
                ;
                break;
            case 'trex':
                {
                    slice.skip(4); // Version + flags
                    const trackId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const defaultSampleDescriptionIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const defaultSampleDuration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const defaultSampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const defaultSampleFlags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    // We store these separately rather than in the tracks since the tracks may not exist yet
                    this.fragmentTrackDefaults.push({
                        trackId,
                        defaultSampleDescriptionIndex,
                        defaultSampleDuration,
                        defaultSampleSize,
                        defaultSampleFlags
                    });
                }
                ;
                break;
            case 'tfra':
                {
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    const trackId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const track = this.tracks.find((x)=>x.id === trackId);
                    if (!track) {
                        break;
                    }
                    const word = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const lengthSizeOfTrafNum = (word & 0b110000) >> 4;
                    const lengthSizeOfTrunNum = (word & 0b001100) >> 2;
                    const lengthSizeOfSampleNum = word & 0b000011;
                    const functions = [
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"],
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU16Be"],
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU24Be"],
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"]
                    ];
                    const readTrafNum = functions[lengthSizeOfTrafNum];
                    const readTrunNum = functions[lengthSizeOfTrunNum];
                    const readSampleNum = functions[lengthSizeOfSampleNum];
                    const numberOfEntries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < numberOfEntries; i++){
                        const time = version === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        const moofOffset = version === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        readTrafNum(slice);
                        readTrunNum(slice);
                        readSampleNum(slice);
                        track.fragmentLookupTable.push({
                            timestamp: time,
                            moofOffset
                        });
                    }
                    // Sort by timestamp in case it's not naturally sorted
                    track.fragmentLookupTable.sort((a, b)=>a.timestamp - b.timestamp);
                    // Remove multiple entries for the same time
                    for(let i = 0; i < track.fragmentLookupTable.length - 1; i++){
                        const entry1 = track.fragmentLookupTable[i];
                        const entry2 = track.fragmentLookupTable[i + 1];
                        if (entry1.timestamp === entry2.timestamp) {
                            track.fragmentLookupTable.splice(i + 1, 1);
                            i--;
                        }
                    }
                }
                ;
                break;
            case 'moof':
                {
                    this.currentFragment = {
                        moofOffset: startPos,
                        moofSize: boxInfo.totalSize,
                        implicitBaseDataOffset: startPos,
                        trackData: new Map()
                    };
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    this.lastReadFragment = this.currentFragment;
                    this.currentFragment = null;
                }
                ;
                break;
            case 'traf':
                {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentFragment);
                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    // It is possible that there is no current track, for example when we don't care about the track
                    // referenced in the track fragment header.
                    if (this.currentTrack) {
                        const trackData = this.currentFragment.trackData.get(this.currentTrack.id);
                        if (trackData) {
                            const { currentFragmentState } = this.currentTrack;
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(currentFragmentState);
                            if (currentFragmentState.startTimestamp !== null) {
                                offsetFragmentTrackDataByTimestamp(trackData, currentFragmentState.startTimestamp);
                                trackData.startTimestampIsFinal = true;
                            }
                        }
                        this.currentTrack.currentFragmentState = null;
                        this.currentTrack = null;
                    }
                }
                ;
                break;
            case 'tfhd':
                {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentFragment);
                    slice.skip(1); // Version
                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU24Be"])(slice);
                    const baseDataOffsetPresent = Boolean(flags & 0x000001);
                    const sampleDescriptionIndexPresent = Boolean(flags & 0x000002);
                    const defaultSampleDurationPresent = Boolean(flags & 0x000008);
                    const defaultSampleSizePresent = Boolean(flags & 0x000010);
                    const defaultSampleFlagsPresent = Boolean(flags & 0x000020);
                    const durationIsEmpty = Boolean(flags & 0x010000);
                    const defaultBaseIsMoof = Boolean(flags & 0x020000);
                    const trackId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const track = this.tracks.find((x)=>x.id === trackId);
                    if (!track) {
                        break;
                    }
                    const defaults = this.fragmentTrackDefaults.find((x)=>x.trackId === trackId);
                    this.currentTrack = track;
                    track.currentFragmentState = {
                        baseDataOffset: this.currentFragment.implicitBaseDataOffset,
                        sampleDescriptionIndex: defaults?.defaultSampleDescriptionIndex ?? null,
                        defaultSampleDuration: defaults?.defaultSampleDuration ?? null,
                        defaultSampleSize: defaults?.defaultSampleSize ?? null,
                        defaultSampleFlags: defaults?.defaultSampleFlags ?? null,
                        startTimestamp: null
                    };
                    if (baseDataOffsetPresent) {
                        track.currentFragmentState.baseDataOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                    } else if (defaultBaseIsMoof) {
                        track.currentFragmentState.baseDataOffset = this.currentFragment.moofOffset;
                    }
                    if (sampleDescriptionIndexPresent) {
                        track.currentFragmentState.sampleDescriptionIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                    if (defaultSampleDurationPresent) {
                        track.currentFragmentState.defaultSampleDuration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                    if (defaultSampleSizePresent) {
                        track.currentFragmentState.defaultSampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                    if (defaultSampleFlagsPresent) {
                        track.currentFragmentState.defaultSampleFlags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                    if (durationIsEmpty) {
                        track.currentFragmentState.defaultSampleDuration = 0;
                    }
                }
                ;
                break;
            case 'tfdt':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.currentFragmentState);
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    slice.skip(3); // Flags
                    const baseMediaDecodeTime = version === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU64Be"])(slice);
                    track.currentFragmentState.startTimestamp = baseMediaDecodeTime;
                }
                ;
                break;
            case 'trun':
                {
                    const track = this.currentTrack;
                    if (!track) {
                        break;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentFragment);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.currentFragmentState);
                    if (this.currentFragment.trackData.has(track.id)) {
                        console.warn('Can\'t have two trun boxes for the same track in one fragment. Ignoring...');
                        break;
                    }
                    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU24Be"])(slice);
                    const dataOffsetPresent = Boolean(flags & 0x000001);
                    const firstSampleFlagsPresent = Boolean(flags & 0x000004);
                    const sampleDurationPresent = Boolean(flags & 0x000100);
                    const sampleSizePresent = Boolean(flags & 0x000200);
                    const sampleFlagsPresent = Boolean(flags & 0x000400);
                    const sampleCompositionTimeOffsetsPresent = Boolean(flags & 0x000800);
                    const sampleCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    let dataOffset = track.currentFragmentState.baseDataOffset;
                    if (dataOffsetPresent) {
                        dataOffset += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice);
                    }
                    let firstSampleFlags = null;
                    if (firstSampleFlagsPresent) {
                        firstSampleFlags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    }
                    let currentOffset = dataOffset;
                    if (sampleCount === 0) {
                        // Don't associate the fragment with the track if it has no samples, this simplifies other code
                        this.currentFragment.implicitBaseDataOffset = currentOffset;
                        break;
                    }
                    let currentTimestamp = 0;
                    const trackData = {
                        track,
                        startTimestamp: 0,
                        endTimestamp: 0,
                        firstKeyFrameTimestamp: null,
                        samples: [],
                        presentationTimestamps: [],
                        startTimestampIsFinal: false
                    };
                    this.currentFragment.trackData.set(track.id, trackData);
                    for(let i = 0; i < sampleCount; i++){
                        let sampleDuration;
                        if (sampleDurationPresent) {
                            sampleDuration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        } else {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.currentFragmentState.defaultSampleDuration !== null);
                            sampleDuration = track.currentFragmentState.defaultSampleDuration;
                        }
                        let sampleSize;
                        if (sampleSizePresent) {
                            sampleSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        } else {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.currentFragmentState.defaultSampleSize !== null);
                            sampleSize = track.currentFragmentState.defaultSampleSize;
                        }
                        let sampleFlags;
                        if (sampleFlagsPresent) {
                            sampleFlags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        } else {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.currentFragmentState.defaultSampleFlags !== null);
                            sampleFlags = track.currentFragmentState.defaultSampleFlags;
                        }
                        if (i === 0 && firstSampleFlags !== null) {
                            sampleFlags = firstSampleFlags;
                        }
                        let sampleCompositionTimeOffset = 0;
                        if (sampleCompositionTimeOffsetsPresent) {
                            if (version === 0) {
                                sampleCompositionTimeOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                            } else {
                                sampleCompositionTimeOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI32Be"])(slice);
                            }
                        }
                        const isKeyFrame = !(sampleFlags & 0x00010000);
                        trackData.samples.push({
                            presentationTimestamp: currentTimestamp + sampleCompositionTimeOffset,
                            duration: sampleDuration,
                            byteOffset: currentOffset,
                            byteSize: sampleSize,
                            isKeyFrame
                        });
                        currentOffset += sampleSize;
                        currentTimestamp += sampleDuration;
                    }
                    trackData.presentationTimestamps = trackData.samples.map((x, i)=>({
                            presentationTimestamp: x.presentationTimestamp,
                            sampleIndex: i
                        })).sort((a, b)=>a.presentationTimestamp - b.presentationTimestamp);
                    for(let i = 0; i < trackData.presentationTimestamps.length; i++){
                        const currentEntry = trackData.presentationTimestamps[i];
                        const currentSample = trackData.samples[currentEntry.sampleIndex];
                        if (trackData.firstKeyFrameTimestamp === null && currentSample.isKeyFrame) {
                            trackData.firstKeyFrameTimestamp = currentSample.presentationTimestamp;
                        }
                        if (i < trackData.presentationTimestamps.length - 1) {
                            // Update sample durations based on presentation order
                            const nextEntry = trackData.presentationTimestamps[i + 1];
                            currentSample.duration = nextEntry.presentationTimestamp - currentEntry.presentationTimestamp;
                        }
                    }
                    const firstSample = trackData.samples[trackData.presentationTimestamps[0].sampleIndex];
                    const lastSample = trackData.samples[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.presentationTimestamps).sampleIndex];
                    trackData.startTimestamp = firstSample.presentationTimestamp;
                    trackData.endTimestamp = lastSample.presentationTimestamp + lastSample.duration;
                    this.currentFragment.implicitBaseDataOffset = currentOffset;
                }
                ;
                break;
            // Metadata section
            // https://exiftool.org/TagNames/QuickTime.html
            // https://mp4workshop.com/about
            case 'udta':
                {
                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    for (const { boxInfo, slice } of iterator){
                        if (boxInfo.name !== 'meta' && !this.currentTrack) {
                            const startPos = slice.filePos;
                            this.metadataTags.raw ??= {};
                            if (boxInfo.name[0] === '') {
                                // https://mp4workshop.com/about
                                // Box name starting with  indicates "international text"
                                this.metadataTags.raw[boxInfo.name] ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                            } else {
                                this.metadataTags.raw[boxInfo.name] ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, boxInfo.contentSize);
                            }
                            slice.filePos = startPos;
                        }
                        switch(boxInfo.name){
                            case 'meta':
                                {
                                    slice.skip(-boxInfo.headerSize);
                                    this.traverseBox(slice);
                                }
                                ;
                                break;
                            case 'nam':
                            case 'name':
                                {
                                    if (this.currentTrack) {
                                        this.currentTrack.name = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecoder"].decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, boxInfo.contentSize));
                                    } else {
                                        this.metadataTags.title ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'des':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.description ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'ART':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.artist ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'alb':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.album ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'albr':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.albumArtist ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'gen':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.genre ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'day':
                                {
                                    if (!this.currentTrack) {
                                        const date = new Date((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice));
                                        if (!Number.isNaN(date.getTime())) {
                                            this.metadataTags.date ??= date;
                                        }
                                    }
                                }
                                ;
                                break;
                            case 'cmt':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.comment ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                            case 'lyr':
                                {
                                    if (!this.currentTrack) {
                                        this.metadataTags.lyrics ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readMetadataStringShort"])(slice);
                                    }
                                }
                                ;
                                break;
                        }
                    }
                }
                ;
                break;
            case 'meta':
                {
                    if (this.currentTrack) {
                        break; // Only care about movie-level metadata for now
                    }
                    // The 'meta' box comes in two flavors, one with flags/version and one without. To know which is which,
                    // let's read the next 4 bytes, which are either the version or the size of the first subbox.
                    const word = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    const isQuickTime = word !== 0;
                    this.currentMetadataKeys = new Map();
                    if (isQuickTime) {
                        this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    } else {
                        this.readContiguousBoxes(slice.slice(contentStartPos + 4, boxInfo.contentSize - 4));
                    }
                    this.currentMetadataKeys = null;
                }
                ;
                break;
            case 'keys':
                {
                    if (!this.currentMetadataKeys) {
                        break;
                    }
                    slice.skip(4); // Version + flags
                    const entryCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                    for(let i = 0; i < entryCount; i++){
                        const keySize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU32Be"])(slice);
                        slice.skip(4); // Key namespace
                        const keyName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecoder"].decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, keySize - 8));
                        this.currentMetadataKeys.set(i + 1, keyName);
                    }
                }
                ;
                break;
            case 'ilst':
                {
                    if (!this.currentMetadataKeys) {
                        break;
                    }
                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));
                    for (const { boxInfo, slice } of iterator){
                        let metadataKey = boxInfo.name;
                        // Interpret the box name as a u32be
                        const nameAsNumber = (metadataKey.charCodeAt(0) << 24) + (metadataKey.charCodeAt(1) << 16) + (metadataKey.charCodeAt(2) << 8) + metadataKey.charCodeAt(3);
                        if (this.currentMetadataKeys.has(nameAsNumber)) {
                            // An entry exists for this number
                            metadataKey = this.currentMetadataKeys.get(nameAsNumber);
                        }
                        const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readDataBox"])(slice);
                        this.metadataTags.raw ??= {};
                        this.metadataTags.raw[metadataKey] ??= data;
                        switch(metadataKey){
                            case 'nam':
                            case 'titl':
                            case 'com.apple.quicktime.title':
                            case 'title':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.title ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'des':
                            case 'desc':
                            case 'dscp':
                            case 'com.apple.quicktime.description':
                            case 'description':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.description ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'ART':
                            case 'com.apple.quicktime.artist':
                            case 'artist':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.artist ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'alb':
                            case 'albm':
                            case 'com.apple.quicktime.album':
                            case 'album':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.album ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'aART':
                            case 'album_artist':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.albumArtist ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'cmt':
                            case 'com.apple.quicktime.comment':
                            case 'comment':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.comment ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'gen':
                            case 'gnre':
                            case 'com.apple.quicktime.genre':
                            case 'genre':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.genre ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'lyr':
                            case 'lyrics':
                                {
                                    if (typeof data === 'string') {
                                        this.metadataTags.lyrics ??= data;
                                    }
                                }
                                ;
                                break;
                            case 'day':
                            case 'rldt':
                            case 'com.apple.quicktime.creationdate':
                            case 'date':
                                {
                                    if (typeof data === 'string') {
                                        const date = new Date(data);
                                        if (!Number.isNaN(date.getTime())) {
                                            this.metadataTags.date ??= date;
                                        }
                                    }
                                }
                                ;
                                break;
                            case 'covr':
                            case 'com.apple.quicktime.artwork':
                                {
                                    if (data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RichImageData"]) {
                                        this.metadataTags.images ??= [];
                                        this.metadataTags.images.push({
                                            data: data.data,
                                            kind: 'coverFront',
                                            mimeType: data.mimeType
                                        });
                                    } else if (data instanceof Uint8Array) {
                                        this.metadataTags.images ??= [];
                                        this.metadataTags.images.push({
                                            data,
                                            kind: 'coverFront',
                                            mimeType: 'image/*'
                                        });
                                    }
                                }
                                ;
                                break;
                            case 'track':
                                {
                                    if (typeof data === 'string') {
                                        const parts = data.split('/');
                                        const trackNum = Number.parseInt(parts[0], 10);
                                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);
                                        if (Number.isInteger(trackNum) && trackNum > 0) {
                                            this.metadataTags.trackNumber ??= trackNum;
                                        }
                                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {
                                            this.metadataTags.tracksTotal ??= tracksTotal;
                                        }
                                    }
                                }
                                ;
                                break;
                            case 'trkn':
                                {
                                    if (data instanceof Uint8Array && data.length >= 6) {
                                        const view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDataView"])(data);
                                        const trackNumber = view.getUint16(2, false);
                                        const tracksTotal = view.getUint16(4, false);
                                        if (trackNumber > 0) {
                                            this.metadataTags.trackNumber ??= trackNumber;
                                        }
                                        if (tracksTotal > 0) {
                                            this.metadataTags.tracksTotal ??= tracksTotal;
                                        }
                                    }
                                }
                                ;
                                break;
                            case 'disc':
                            case 'disk':
                                {
                                    if (data instanceof Uint8Array && data.length >= 6) {
                                        const view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDataView"])(data);
                                        const discNumber = view.getUint16(2, false);
                                        const discNumberMax = view.getUint16(4, false);
                                        if (discNumber > 0) {
                                            this.metadataTags.discNumber ??= discNumber;
                                        }
                                        if (discNumberMax > 0) {
                                            this.metadataTags.discsTotal ??= discNumberMax;
                                        }
                                    }
                                }
                                ;
                                break;
                        }
                    }
                }
                ;
                break;
        }
        slice.filePos = boxEndPos;
        return true;
    }
}
class IsobmffTrackBacking {
    constructor(internalTrack){
        this.internalTrack = internalTrack;
        this.packetToSampleIndex = new WeakMap();
        this.packetToFragmentLocation = new WeakMap();
    }
    getId() {
        return this.internalTrack.id;
    }
    getCodec() {
        throw new Error('Not implemented on base class.');
    }
    getInternalCodecId() {
        return this.internalTrack.internalCodecId;
    }
    getName() {
        return this.internalTrack.name;
    }
    getLanguageCode() {
        return this.internalTrack.languageCode;
    }
    getTimeResolution() {
        return this.internalTrack.timescale;
    }
    getDisposition() {
        return this.internalTrack.disposition;
    }
    async computeDuration() {
        const lastPacket = await this.getPacket(Infinity, {
            metadataOnly: true
        });
        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);
    }
    async getFirstTimestamp() {
        const firstPacket = await this.getFirstPacket({
            metadataOnly: true
        });
        return firstPacket?.timestamp ?? 0;
    }
    async getFirstPacket(options) {
        const regularPacket = await this.fetchPacketForSampleIndex(0, options);
        if (regularPacket || !this.internalTrack.demuxer.isFragmented) {
            // If there's a non-fragmented packet, always prefer that
            return regularPacket;
        }
        return this.performFragmentedLookup(null, (fragment)=>{
            const trackData = fragment.trackData.get(this.internalTrack.id);
            if (trackData) {
                return {
                    sampleIndex: 0,
                    correctSampleFound: true
                };
            }
            return {
                sampleIndex: -1,
                correctSampleFound: false
            };
        }, -Infinity, Infinity, options);
    }
    mapTimestampIntoTimescale(timestamp) {
        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely
        // that the number was originally an integer divided by the timescale. For stability, it's best
        // to return the integer in this case.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["roundIfAlmostInteger"])(timestamp * this.internalTrack.timescale) + this.internalTrack.editListOffset;
    }
    async getPacket(timestamp, options) {
        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);
        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);
        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timestampInTimescale);
        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);
        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {
            // Prefer the non-fragmented packet
            return regularPacket;
        }
        return this.performFragmentedLookup(null, (fragment)=>{
            const trackData = fragment.trackData.get(this.internalTrack.id);
            if (!trackData) {
                return {
                    sampleIndex: -1,
                    correctSampleFound: false
                };
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(trackData.presentationTimestamps, timestampInTimescale, (x)=>x.presentationTimestamp);
            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;
            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;
            return {
                sampleIndex,
                correctSampleFound
            };
        }, timestampInTimescale, timestampInTimescale, options);
    }
    async getNextPacket(packet, options) {
        const regularSampleIndex = this.packetToSampleIndex.get(packet);
        if (regularSampleIndex !== undefined) {
            // Prefer the non-fragmented packet
            return this.fetchPacketForSampleIndex(regularSampleIndex + 1, options);
        }
        const locationInFragment = this.packetToFragmentLocation.get(packet);
        if (locationInFragment === undefined) {
            throw new Error('Packet was not created from this track.');
        }
        return this.performFragmentedLookup(locationInFragment.fragment, (fragment)=>{
            if (fragment === locationInFragment.fragment) {
                const trackData = fragment.trackData.get(this.internalTrack.id);
                if (locationInFragment.sampleIndex + 1 < trackData.samples.length) {
                    // We can simply take the next sample in the fragment
                    return {
                        sampleIndex: locationInFragment.sampleIndex + 1,
                        correctSampleFound: true
                    };
                }
            } else {
                const trackData = fragment.trackData.get(this.internalTrack.id);
                if (trackData) {
                    return {
                        sampleIndex: 0,
                        correctSampleFound: true
                    };
                }
            }
            return {
                sampleIndex: -1,
                correctSampleFound: false
            };
        }, -Infinity, Infinity, options);
    }
    async getKeyPacket(timestamp, options) {
        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);
        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);
        const sampleIndex = getKeyframeSampleIndexForTimestamp(sampleTable, timestampInTimescale);
        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);
        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {
            // Prefer the non-fragmented packet
            return regularPacket;
        }
        return this.performFragmentedLookup(null, (fragment)=>{
            const trackData = fragment.trackData.get(this.internalTrack.id);
            if (!trackData) {
                return {
                    sampleIndex: -1,
                    correctSampleFound: false
                };
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findLastIndex"])(trackData.presentationTimestamps, (x)=>{
                const sample = trackData.samples[x.sampleIndex];
                return sample.isKeyFrame && x.presentationTimestamp <= timestampInTimescale;
            });
            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;
            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;
            return {
                sampleIndex,
                correctSampleFound
            };
        }, timestampInTimescale, timestampInTimescale, options);
    }
    async getNextKeyPacket(packet, options) {
        const regularSampleIndex = this.packetToSampleIndex.get(packet);
        if (regularSampleIndex !== undefined) {
            // Prefer the non-fragmented packet
            const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);
            const nextKeyFrameSampleIndex = getNextKeyframeIndexForSample(sampleTable, regularSampleIndex);
            return this.fetchPacketForSampleIndex(nextKeyFrameSampleIndex, options);
        }
        const locationInFragment = this.packetToFragmentLocation.get(packet);
        if (locationInFragment === undefined) {
            throw new Error('Packet was not created from this track.');
        }
        return this.performFragmentedLookup(locationInFragment.fragment, (fragment)=>{
            if (fragment === locationInFragment.fragment) {
                const trackData = fragment.trackData.get(this.internalTrack.id);
                const nextKeyFrameIndex = trackData.samples.findIndex((x, i)=>x.isKeyFrame && i > locationInFragment.sampleIndex);
                if (nextKeyFrameIndex !== -1) {
                    // We can simply take the next key frame in the fragment
                    return {
                        sampleIndex: nextKeyFrameIndex,
                        correctSampleFound: true
                    };
                }
            } else {
                const trackData = fragment.trackData.get(this.internalTrack.id);
                if (trackData && trackData.firstKeyFrameTimestamp !== null) {
                    const keyFrameIndex = trackData.samples.findIndex((x)=>x.isKeyFrame);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(keyFrameIndex !== -1); // There must be one
                    return {
                        sampleIndex: keyFrameIndex,
                        correctSampleFound: true
                    };
                }
            }
            return {
                sampleIndex: -1,
                correctSampleFound: false
            };
        }, -Infinity, Infinity, options);
    }
    async fetchPacketForSampleIndex(sampleIndex, options) {
        if (sampleIndex === -1) {
            return null;
        }
        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);
        const sampleInfo = getSampleInfo(sampleTable, sampleIndex);
        if (!sampleInfo) {
            return null;
        }
        let data;
        if (options.metadataOnly) {
            data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PLACEHOLDER_DATA"];
        } else {
            let slice = this.internalTrack.demuxer.reader.requestSlice(sampleInfo.sampleOffset, sampleInfo.sampleSize);
            if (slice instanceof Promise) slice = await slice;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(slice);
            data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, sampleInfo.sampleSize);
        }
        const timestamp = (sampleInfo.presentationTimestamp - this.internalTrack.editListOffset) / this.internalTrack.timescale;
        const duration = sampleInfo.duration / this.internalTrack.timescale;
        const packet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EncodedPacket"](data, sampleInfo.isKeyFrame ? 'key' : 'delta', timestamp, duration, sampleIndex, sampleInfo.sampleSize);
        this.packetToSampleIndex.set(packet, sampleIndex);
        return packet;
    }
    async fetchPacketInFragment(fragment, sampleIndex, options) {
        if (sampleIndex === -1) {
            return null;
        }
        const trackData = fragment.trackData.get(this.internalTrack.id);
        const fragmentSample = trackData.samples[sampleIndex];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(fragmentSample);
        let data;
        if (options.metadataOnly) {
            data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PLACEHOLDER_DATA"];
        } else {
            let slice = this.internalTrack.demuxer.reader.requestSlice(fragmentSample.byteOffset, fragmentSample.byteSize);
            if (slice instanceof Promise) slice = await slice;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(slice);
            data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, fragmentSample.byteSize);
        }
        const timestamp = (fragmentSample.presentationTimestamp - this.internalTrack.editListOffset) / this.internalTrack.timescale;
        const duration = fragmentSample.duration / this.internalTrack.timescale;
        const packet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EncodedPacket"](data, fragmentSample.isKeyFrame ? 'key' : 'delta', timestamp, duration, fragment.moofOffset + sampleIndex, fragmentSample.byteSize);
        this.packetToFragmentLocation.set(packet, {
            fragment,
            sampleIndex
        });
        return packet;
    }
    /** Looks for a packet in the fragments while trying to load as few fragments as possible to retrieve it. */ async performFragmentedLookup(// The fragment where we start looking
    startFragment, // This function returns the best-matching sample in a given fragment
    getMatchInFragment, // The timestamp with which we can search the lookup table
    searchTimestamp, // The timestamp for which we know the correct sample will not come after it
    latestTimestamp, options) {
        const demuxer = this.internalTrack.demuxer;
        let currentFragment = null;
        let bestFragment = null;
        let bestSampleIndex = -1;
        if (startFragment) {
            const { sampleIndex, correctSampleFound } = getMatchInFragment(startFragment);
            if (correctSampleFound) {
                return this.fetchPacketInFragment(startFragment, sampleIndex, options);
            }
            if (sampleIndex !== -1) {
                bestFragment = startFragment;
                bestSampleIndex = sampleIndex;
            }
        }
        // Search for a lookup entry; this way, we won't need to start searching from the start of the file
        // but can jump right into the correct fragment (or at least nearby).
        const lookupEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(this.internalTrack.fragmentLookupTable, searchTimestamp, (x)=>x.timestamp);
        const lookupEntry = lookupEntryIndex !== -1 ? this.internalTrack.fragmentLookupTable[lookupEntryIndex] : null;
        const positionCacheIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(this.internalTrack.fragmentPositionCache, searchTimestamp, (x)=>x.startTimestamp);
        const positionCacheEntry = positionCacheIndex !== -1 ? this.internalTrack.fragmentPositionCache[positionCacheIndex] : null;
        const lookupEntryPosition = Math.max(lookupEntry?.moofOffset ?? 0, positionCacheEntry?.moofOffset ?? 0) || null;
        let currentPos;
        if (!startFragment) {
            currentPos = lookupEntryPosition ?? 0;
        } else {
            if (lookupEntryPosition === null || startFragment.moofOffset >= lookupEntryPosition) {
                currentPos = startFragment.moofOffset + startFragment.moofSize;
                currentFragment = startFragment;
            } else {
                // Use the lookup entry
                currentPos = lookupEntryPosition;
            }
        }
        while(true){
            if (currentFragment) {
                const trackData = currentFragment.trackData.get(this.internalTrack.id);
                if (trackData && trackData.startTimestamp > latestTimestamp) {
                    break;
                }
            }
            // Load the header
            let slice = demuxer.reader.requestSliceRange(currentPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"]);
            if (slice instanceof Promise) slice = await slice;
            if (!slice) break;
            const boxStartPos = currentPos;
            const boxInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBoxHeader"])(slice);
            if (!boxInfo) {
                break;
            }
            if (boxInfo.name === 'moof') {
                currentFragment = await demuxer.readFragment(boxStartPos);
                const { sampleIndex, correctSampleFound } = getMatchInFragment(currentFragment);
                if (correctSampleFound) {
                    return this.fetchPacketInFragment(currentFragment, sampleIndex, options);
                }
                if (sampleIndex !== -1) {
                    bestFragment = currentFragment;
                    bestSampleIndex = sampleIndex;
                }
            }
            currentPos = boxStartPos + boxInfo.totalSize;
        }
        // Catch faulty lookup table entries
        if (lookupEntry && (!bestFragment || bestFragment.moofOffset < lookupEntry.moofOffset)) {
            // The lookup table entry lied to us! We found a lookup entry but no fragment there that satisfied
            // the match. In this case, let's search again but using the lookup entry before that.
            const previousLookupEntry = this.internalTrack.fragmentLookupTable[lookupEntryIndex - 1];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(!previousLookupEntry || previousLookupEntry.timestamp < lookupEntry.timestamp);
            const newSearchTimestamp = previousLookupEntry?.timestamp ?? -Infinity;
            return this.performFragmentedLookup(null, getMatchInFragment, newSearchTimestamp, latestTimestamp, options);
        }
        if (bestFragment) {
            // If we finished looping but didn't find a perfect match, still return the best match we found
            return this.fetchPacketInFragment(bestFragment, bestSampleIndex, options);
        }
        return null;
    }
}
class IsobmffVideoTrackBacking extends IsobmffTrackBacking {
    constructor(internalTrack){
        super(internalTrack);
        this.decoderConfigPromise = null;
        this.internalTrack = internalTrack;
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getCodedWidth() {
        return this.internalTrack.info.width;
    }
    getCodedHeight() {
        return this.internalTrack.info.height;
    }
    getRotation() {
        return this.internalTrack.rotation;
    }
    async getColorSpace() {
        return {
            primaries: this.internalTrack.info.colorSpace?.primaries,
            transfer: this.internalTrack.info.colorSpace?.transfer,
            matrix: this.internalTrack.info.colorSpace?.matrix,
            fullRange: this.internalTrack.info.colorSpace?.fullRange
        };
    }
    async canBeTransparent() {
        return false;
    }
    async getDecoderConfig() {
        if (!this.internalTrack.info.codec) {
            return null;
        }
        return this.decoderConfigPromise ??= (async ()=>{
            if (this.internalTrack.info.codec === 'vp9' && !this.internalTrack.info.vp9CodecInfo) {
                const firstPacket = await this.getFirstPacket({});
                this.internalTrack.info.vp9CodecInfo = firstPacket && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractVp9CodecInfoFromPacket"])(firstPacket.data);
            } else if (this.internalTrack.info.codec === 'av1' && !this.internalTrack.info.av1CodecInfo) {
                const firstPacket = await this.getFirstPacket({});
                this.internalTrack.info.av1CodecInfo = firstPacket && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAv1CodecInfoFromPacket"])(firstPacket.data);
            }
            return {
                codec: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractVideoCodecString"])(this.internalTrack.info),
                codedWidth: this.internalTrack.info.width,
                codedHeight: this.internalTrack.info.height,
                description: this.internalTrack.info.codecDescription ?? undefined,
                colorSpace: this.internalTrack.info.colorSpace ?? undefined
            };
        })();
    }
}
class IsobmffAudioTrackBacking extends IsobmffTrackBacking {
    constructor(internalTrack){
        super(internalTrack);
        this.decoderConfig = null;
        this.internalTrack = internalTrack;
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getNumberOfChannels() {
        return this.internalTrack.info.numberOfChannels;
    }
    getSampleRate() {
        return this.internalTrack.info.sampleRate;
    }
    async getDecoderConfig() {
        if (!this.internalTrack.info.codec) {
            return null;
        }
        return this.decoderConfig ??= {
            codec: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAudioCodecString"])(this.internalTrack.info),
            numberOfChannels: this.internalTrack.info.numberOfChannels,
            sampleRate: this.internalTrack.info.sampleRate,
            description: this.internalTrack.info.codecDescription ?? undefined
        };
    }
}
const getSampleIndexForTimestamp = (sampleTable, timescaleUnits)=>{
    if (sampleTable.presentationTimestamps) {
        const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.presentationTimestamps, timescaleUnits, (x)=>x.presentationTimestamp);
        if (index === -1) {
            return -1;
        }
        return sampleTable.presentationTimestamps[index].sampleIndex;
    } else {
        const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleTimingEntries, timescaleUnits, (x)=>x.startDecodeTimestamp);
        if (index === -1) {
            return -1;
        }
        const entry = sampleTable.sampleTimingEntries[index];
        return entry.startIndex + Math.min(Math.floor((timescaleUnits - entry.startDecodeTimestamp) / entry.delta), entry.count - 1);
    }
};
const getKeyframeSampleIndexForTimestamp = (sampleTable, timescaleUnits)=>{
    if (!sampleTable.keySampleIndices) {
        // Every sample is a keyframe
        return getSampleIndexForTimestamp(sampleTable, timescaleUnits);
    }
    if (sampleTable.presentationTimestamps) {
        const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.presentationTimestamps, timescaleUnits, (x)=>x.presentationTimestamp);
        if (index === -1) {
            return -1;
        }
        // Walk the samples in presentation order until we find one that's a keyframe
        for(let i = index; i >= 0; i--){
            const sampleIndex = sampleTable.presentationTimestamps[i].sampleIndex;
            const isKeyFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchExact"])(sampleTable.keySampleIndices, sampleIndex, (x)=>x) !== -1;
            if (isKeyFrame) {
                return sampleIndex;
            }
        }
        return -1;
    } else {
        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timescaleUnits);
        const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.keySampleIndices, sampleIndex, (x)=>x);
        return sampleTable.keySampleIndices[index] ?? -1;
    }
};
const getSampleInfo = (sampleTable, sampleIndex)=>{
    const timingEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleTimingEntries, sampleIndex, (x)=>x.startIndex);
    const timingEntry = sampleTable.sampleTimingEntries[timingEntryIndex];
    if (!timingEntry || timingEntry.startIndex + timingEntry.count <= sampleIndex) {
        return null;
    }
    const decodeTimestamp = timingEntry.startDecodeTimestamp + (sampleIndex - timingEntry.startIndex) * timingEntry.delta;
    let presentationTimestamp = decodeTimestamp;
    const offsetEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleCompositionTimeOffsets, sampleIndex, (x)=>x.startIndex);
    const offsetEntry = sampleTable.sampleCompositionTimeOffsets[offsetEntryIndex];
    if (offsetEntry && sampleIndex - offsetEntry.startIndex < offsetEntry.count) {
        presentationTimestamp += offsetEntry.offset;
    }
    const sampleSize = sampleTable.sampleSizes[Math.min(sampleIndex, sampleTable.sampleSizes.length - 1)];
    const chunkEntryIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.sampleToChunk, sampleIndex, (x)=>x.startSampleIndex);
    const chunkEntry = sampleTable.sampleToChunk[chunkEntryIndex];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(chunkEntry);
    const chunkIndex = chunkEntry.startChunkIndex + Math.floor((sampleIndex - chunkEntry.startSampleIndex) / chunkEntry.samplesPerChunk);
    const chunkOffset = sampleTable.chunkOffsets[chunkIndex];
    const startSampleIndexOfChunk = chunkEntry.startSampleIndex + (chunkIndex - chunkEntry.startChunkIndex) * chunkEntry.samplesPerChunk;
    let chunkSize = 0;
    let sampleOffset = chunkOffset;
    if (sampleTable.sampleSizes.length === 1) {
        sampleOffset += sampleSize * (sampleIndex - startSampleIndexOfChunk);
        chunkSize += sampleSize * chunkEntry.samplesPerChunk;
    } else {
        for(let i = startSampleIndexOfChunk; i < startSampleIndexOfChunk + chunkEntry.samplesPerChunk; i++){
            const sampleSize = sampleTable.sampleSizes[i];
            if (i < sampleIndex) {
                sampleOffset += sampleSize;
            }
            chunkSize += sampleSize;
        }
    }
    let duration = timingEntry.delta;
    if (sampleTable.presentationTimestamps) {
        // In order to accurately compute the duration, we need to take the duration to the next sample in presentation
        // order, not in decode order
        const presentationIndex = sampleTable.presentationTimestampIndexMap[sampleIndex];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(presentationIndex !== undefined);
        if (presentationIndex < sampleTable.presentationTimestamps.length - 1) {
            const nextEntry = sampleTable.presentationTimestamps[presentationIndex + 1];
            const nextPresentationTimestamp = nextEntry.presentationTimestamp;
            duration = nextPresentationTimestamp - presentationTimestamp;
        }
    }
    return {
        presentationTimestamp,
        duration,
        sampleOffset,
        sampleSize,
        chunkOffset,
        chunkSize,
        isKeyFrame: sampleTable.keySampleIndices ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchExact"])(sampleTable.keySampleIndices, sampleIndex, (x)=>x) !== -1 : true
    };
};
const getNextKeyframeIndexForSample = (sampleTable, sampleIndex)=>{
    if (!sampleTable.keySampleIndices) {
        return sampleIndex + 1;
    }
    const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(sampleTable.keySampleIndices, sampleIndex, (x)=>x);
    return sampleTable.keySampleIndices[index + 1] ?? -1;
};
const offsetFragmentTrackDataByTimestamp = (trackData, timestamp)=>{
    trackData.startTimestamp += timestamp;
    trackData.endTimestamp += timestamp;
    for (const sample of trackData.samples){
        sample.presentationTimestamp += timestamp;
    }
    for (const entry of trackData.presentationTimestamps){
        entry.presentationTimestamp += timestamp;
    }
};
/** Extracts the rotation component from a transformation matrix, in degrees. */ const extractRotationFromMatrix = (matrix)=>{
    const [m11, , , m21] = matrix;
    const scaleX = Math.hypot(m11, m21);
    const cosTheta = m11 / scaleX;
    const sinTheta = m21 / scaleX;
    // Invert the rotation because matrices are post-multiplied in ISOBMFF
    const result = -Math.atan2(sinTheta, cosTheta) * (180 / Math.PI);
    if (!Number.isFinite(result)) {
        // Can happen if the entire matrix is 0, for example
        return 0;
    }
    return result;
};
const sampleTableIsEmpty = (sampleTable)=>{
    return sampleTable.sampleSizes.length === 0;
};
}),
"[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "IsobmffBoxWriter",
    ()=>IsobmffBoxWriter,
    "av1C",
    ()=>av1C,
    "avcC",
    ()=>avcC,
    "box",
    ()=>box,
    "colr",
    ()=>colr,
    "cslg",
    ()=>cslg,
    "ctts",
    ()=>ctts,
    "dOps",
    ()=>dOps,
    "dfLa",
    ()=>dfLa,
    "dinf",
    ()=>dinf,
    "dref",
    ()=>dref,
    "enda",
    ()=>enda,
    "esds",
    ()=>esds,
    "free",
    ()=>free,
    "frma",
    ()=>frma,
    "ftyp",
    ()=>ftyp,
    "fullBox",
    ()=>fullBox,
    "hdlr",
    ()=>hdlr,
    "hvcC",
    ()=>hvcC,
    "mdat",
    ()=>mdat,
    "mdhd",
    ()=>mdhd,
    "mdia",
    ()=>mdia,
    "mfhd",
    ()=>mfhd,
    "mfra",
    ()=>mfra,
    "mfro",
    ()=>mfro,
    "minf",
    ()=>minf,
    "moof",
    ()=>moof,
    "moov",
    ()=>moov,
    "mvex",
    ()=>mvex,
    "mvhd",
    ()=>mvhd,
    "nmhd",
    ()=>nmhd,
    "smhd",
    ()=>smhd,
    "soundSampleDescription",
    ()=>soundSampleDescription,
    "stbl",
    ()=>stbl,
    "stco",
    ()=>stco,
    "stsc",
    ()=>stsc,
    "stsd",
    ()=>stsd,
    "stss",
    ()=>stss,
    "stsz",
    ()=>stsz,
    "stts",
    ()=>stts,
    "subtitleSampleDescription",
    ()=>subtitleSampleDescription,
    "tfdt",
    ()=>tfdt,
    "tfhd",
    ()=>tfhd,
    "tfra",
    ()=>tfra,
    "tkhd",
    ()=>tkhd,
    "traf",
    ()=>traf,
    "trak",
    ()=>trak,
    "trex",
    ()=>trex,
    "trun",
    ()=>trun,
    "txtC",
    ()=>txtC,
    "url",
    ()=>url,
    "videoSampleDescription",
    ()=>videoSampleDescription,
    "vmhd",
    ()=>vmhd,
    "vpcC",
    ()=>vpcC,
    "vttC",
    ()=>vttC,
    "vtta",
    ()=>vtta,
    "vttc",
    ()=>vttc,
    "vtte",
    ()=>vtte,
    "wave",
    ()=>wave
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/subtitles.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec-data.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/metadata.js [app-route] (ecmascript)");
;
;
;
;
;
;
class IsobmffBoxWriter {
    constructor(writer){
        this.writer = writer;
        this.helper = new Uint8Array(8);
        this.helperView = new DataView(this.helper.buffer);
        /**
         * Stores the position from the start of the file to where boxes elements have been written. This is used to
         * rewrite/edit elements that were already added before, and to measure sizes of things.
         */ this.offsets = new WeakMap();
    }
    writeU32(value) {
        this.helperView.setUint32(0, value, false);
        this.writer.write(this.helper.subarray(0, 4));
    }
    writeU64(value) {
        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);
        this.helperView.setUint32(4, value, false);
        this.writer.write(this.helper.subarray(0, 8));
    }
    writeAscii(text) {
        for(let i = 0; i < text.length; i++){
            this.helperView.setUint8(i % 8, text.charCodeAt(i));
            if (i % 8 === 7) this.writer.write(this.helper);
        }
        if (text.length % 8 !== 0) {
            this.writer.write(this.helper.subarray(0, text.length % 8));
        }
    }
    writeBox(box) {
        this.offsets.set(box, this.writer.getPos());
        if (box.contents && !box.children) {
            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);
            this.writer.write(box.contents);
        } else {
            const startPos = this.writer.getPos();
            this.writeBoxHeader(box, 0);
            if (box.contents) this.writer.write(box.contents);
            if (box.children) {
                for (const child of box.children)if (child) this.writeBox(child);
            }
            const endPos = this.writer.getPos();
            const size = box.size ?? endPos - startPos;
            this.writer.seek(startPos);
            this.writeBoxHeader(box, size);
            this.writer.seek(endPos);
        }
    }
    writeBoxHeader(box, size) {
        this.writeU32(box.largeSize ? 1 : size);
        this.writeAscii(box.type);
        if (box.largeSize) this.writeU64(size);
    }
    measureBoxHeader(box) {
        return 8 + (box.largeSize ? 8 : 0);
    }
    patchBox(box) {
        const boxOffset = this.offsets.get(box);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(boxOffset !== undefined);
        const endPos = this.writer.getPos();
        this.writer.seek(boxOffset);
        this.writeBox(box);
        this.writer.seek(endPos);
    }
    measureBox(box) {
        if (box.contents && !box.children) {
            const headerSize = this.measureBoxHeader(box);
            return headerSize + box.contents.byteLength;
        } else {
            let result = this.measureBoxHeader(box);
            if (box.contents) result += box.contents.byteLength;
            if (box.children) {
                for (const child of box.children)if (child) result += this.measureBox(child);
            }
            return result;
        }
    }
}
const bytes = /* #__PURE__ */ new Uint8Array(8);
const view = /* #__PURE__ */ new DataView(bytes.buffer);
const u8 = (value)=>{
    return [
        (value % 0x100 + 0x100) % 0x100
    ];
};
const u16 = (value)=>{
    view.setUint16(0, value, false);
    return [
        bytes[0],
        bytes[1]
    ];
};
const i16 = (value)=>{
    view.setInt16(0, value, false);
    return [
        bytes[0],
        bytes[1]
    ];
};
const u24 = (value)=>{
    view.setUint32(0, value, false);
    return [
        bytes[1],
        bytes[2],
        bytes[3]
    ];
};
const u32 = (value)=>{
    view.setUint32(0, value, false);
    return [
        bytes[0],
        bytes[1],
        bytes[2],
        bytes[3]
    ];
};
const i32 = (value)=>{
    view.setInt32(0, value, false);
    return [
        bytes[0],
        bytes[1],
        bytes[2],
        bytes[3]
    ];
};
const u64 = (value)=>{
    view.setUint32(0, Math.floor(value / 2 ** 32), false);
    view.setUint32(4, value, false);
    return [
        bytes[0],
        bytes[1],
        bytes[2],
        bytes[3],
        bytes[4],
        bytes[5],
        bytes[6],
        bytes[7]
    ];
};
const fixed_8_8 = (value)=>{
    view.setInt16(0, 2 ** 8 * value, false);
    return [
        bytes[0],
        bytes[1]
    ];
};
const fixed_16_16 = (value)=>{
    view.setInt32(0, 2 ** 16 * value, false);
    return [
        bytes[0],
        bytes[1],
        bytes[2],
        bytes[3]
    ];
};
const fixed_2_30 = (value)=>{
    view.setInt32(0, 2 ** 30 * value, false);
    return [
        bytes[0],
        bytes[1],
        bytes[2],
        bytes[3]
    ];
};
const variableUnsignedInt = (value, byteLength)=>{
    const bytes = [];
    let remaining = value;
    do {
        let byte = remaining & 0x7f;
        remaining >>= 7;
        // If this isn't the first byte we're adding (meaning there will be more bytes after it
        // when we reverse the array), set the continuation bit
        if (bytes.length > 0) {
            byte |= 0x80;
        }
        bytes.push(byte);
        if (byteLength !== undefined) {
            byteLength--;
        }
    }while (remaining > 0 || byteLength)
    // Reverse the array since we built it backwards
    return bytes.reverse();
};
const ascii = (text, nullTerminated = false)=>{
    const bytes = Array(text.length).fill(null).map((_, i)=>text.charCodeAt(i));
    if (nullTerminated) bytes.push(0x00);
    return bytes;
};
const lastPresentedSample = (samples)=>{
    let result = null;
    for (const sample of samples){
        if (!result || sample.timestamp > result.timestamp) {
            result = sample;
        }
    }
    return result;
};
const rotationMatrix = (rotationInDegrees)=>{
    const theta = rotationInDegrees * (Math.PI / 180);
    const cosTheta = Math.round(Math.cos(theta));
    const sinTheta = Math.round(Math.sin(theta));
    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix
    return [
        cosTheta,
        sinTheta,
        0,
        -sinTheta,
        cosTheta,
        0,
        0,
        0,
        1
    ];
};
const IDENTITY_MATRIX = /* #__PURE__ */ rotationMatrix(0);
const matrixToBytes = (matrix)=>{
    return [
        fixed_16_16(matrix[0]),
        fixed_16_16(matrix[1]),
        fixed_2_30(matrix[2]),
        fixed_16_16(matrix[3]),
        fixed_16_16(matrix[4]),
        fixed_2_30(matrix[5]),
        fixed_16_16(matrix[6]),
        fixed_16_16(matrix[7]),
        fixed_2_30(matrix[8])
    ];
};
const box = (type, contents, children)=>({
        type,
        contents: contents && new Uint8Array(contents.flat(10)),
        children
    });
const fullBox = (type, version, flags, contents, children)=>box(type, [
        u8(version),
        u24(flags),
        contents ?? []
    ], children);
const ftyp = (details)=>{
    // You can find the full logic for this at
    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518
    // Obviously, this lib only needs a small subset of that logic.
    const minorVersion = 0x200;
    if (details.isQuickTime) {
        return box('ftyp', [
            ascii('qt  '),
            u32(minorVersion),
            // Compatible brands
            ascii('qt  ')
        ]);
    }
    if (details.fragmented) {
        return box('ftyp', [
            ascii('iso5'),
            u32(minorVersion),
            // Compatible brands
            ascii('iso5'),
            ascii('iso6'),
            ascii('mp41')
        ]);
    }
    return box('ftyp', [
        ascii('isom'),
        u32(minorVersion),
        // Compatible brands
        ascii('isom'),
        details.holdsAvc ? ascii('avc1') : [],
        ascii('mp41')
    ]);
};
const mdat = (reserveLargeSize)=>({
        type: 'mdat',
        largeSize: reserveLargeSize
    });
const free = (size)=>({
        type: 'free',
        size
    });
const moov = (muxer)=>box('moov', undefined, [
        mvhd(muxer.creationTime, muxer.trackDatas),
        ...muxer.trackDatas.map((x)=>trak(x, muxer.creationTime)),
        muxer.isFragmented ? mvex(muxer.trackDatas) : null,
        udta(muxer)
    ]);
const mvhd = (creationTime, trackDatas)=>{
    const duration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(Math.max(0, ...trackDatas.filter((x)=>x.samples.length > 0).map((x)=>{
        const lastSample = lastPresentedSample(x.samples);
        return lastSample.timestamp + lastSample.duration;
    })), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GLOBAL_TIMESCALE"]);
    const nextTrackId = Math.max(0, ...trackDatas.map((x)=>x.track.id)) + 1;
    // Conditionally use u64 if u32 isn't enough
    const needsU64 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(creationTime) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(duration);
    const u32OrU64 = needsU64 ? u64 : u32;
    return fullBox('mvhd', +needsU64, 0, [
        u32OrU64(creationTime),
        u32OrU64(creationTime),
        u32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GLOBAL_TIMESCALE"]),
        u32OrU64(duration),
        fixed_16_16(1),
        fixed_8_8(1),
        Array(10).fill(0),
        matrixToBytes(IDENTITY_MATRIX),
        Array(24).fill(0),
        u32(nextTrackId)
    ]);
};
const trak = (trackData, creationTime)=>{
    const trackMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTrackMetadata"])(trackData);
    return box('trak', undefined, [
        tkhd(trackData, creationTime),
        mdia(trackData, creationTime),
        trackMetadata.name !== undefined ? box('udta', undefined, [
            box('name', [
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(trackMetadata.name)
            ])
        ]) : null
    ]);
};
const tkhd = (trackData, creationTime)=>{
    const lastSample = lastPresentedSample(trackData.samples);
    const durationInGlobalTimescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(lastSample ? lastSample.timestamp + lastSample.duration : 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GLOBAL_TIMESCALE"]);
    const needsU64 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(creationTime) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(durationInGlobalTimescale);
    const u32OrU64 = needsU64 ? u64 : u32;
    let matrix;
    if (trackData.type === 'video') {
        const rotation = trackData.track.metadata.rotation;
        matrix = rotationMatrix(rotation ?? 0);
    } else {
        matrix = IDENTITY_MATRIX;
    }
    let flags = 0x2; // Track in movie
    if (trackData.track.metadata.disposition?.default !== false) {
        flags |= 0x1; // Track enabled
    }
    return fullBox('tkhd', +needsU64, flags, [
        u32OrU64(creationTime),
        u32OrU64(creationTime),
        u32(trackData.track.id),
        u32(0),
        u32OrU64(durationInGlobalTimescale),
        Array(8).fill(0),
        u16(0),
        u16(trackData.track.id),
        fixed_8_8(trackData.type === 'audio' ? 1 : 0),
        u16(0),
        matrixToBytes(matrix),
        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0),
        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0)
    ]);
};
const mdia = (trackData, creationTime)=>box('mdia', undefined, [
        mdhd(trackData, creationTime),
        hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),
        minf(trackData)
    ]);
const mdhd = (trackData, creationTime)=>{
    const lastSample = lastPresentedSample(trackData.samples);
    const localDuration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);
    const needsU64 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(creationTime) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isU32"])(localDuration);
    const u32OrU64 = needsU64 ? u64 : u32;
    return fullBox('mdhd', +needsU64, 0, [
        u32OrU64(creationTime),
        u32OrU64(creationTime),
        u32(trackData.timescale),
        u32OrU64(localDuration),
        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"])),
        u16(0)
    ]);
};
const TRACK_TYPE_TO_COMPONENT_SUBTYPE = {
    video: 'vide',
    audio: 'soun',
    subtitle: 'text'
};
const TRACK_TYPE_TO_HANDLER_NAME = {
    video: 'MediabunnyVideoHandler',
    audio: 'MediabunnySoundHandler',
    subtitle: 'MediabunnyTextHandler'
};
const hdlr = (hasComponentType, handlerType, name, manufacturer = '\0\0\0\0')=>fullBox('hdlr', 0, 0, [
        hasComponentType ? ascii('mhlr') : u32(0),
        ascii(handlerType),
        ascii(manufacturer),
        u32(0),
        u32(0),
        ascii(name, true)
    ]);
const minf = (trackData)=>box('minf', undefined, [
        TRACK_TYPE_TO_HEADER_BOX[trackData.type](),
        dinf(),
        stbl(trackData)
    ]);
const vmhd = ()=>fullBox('vmhd', 0, 1, [
        u16(0),
        u16(0),
        u16(0),
        u16(0)
    ]);
const smhd = ()=>fullBox('smhd', 0, 0, [
        u16(0),
        u16(0)
    ]);
const nmhd = ()=>fullBox('nmhd', 0, 0);
const TRACK_TYPE_TO_HEADER_BOX = {
    video: vmhd,
    audio: smhd,
    subtitle: nmhd
};
const dinf = ()=>box('dinf', undefined, [
        dref()
    ]);
const dref = ()=>fullBox('dref', 0, 0, [
        u32(1)
    ], [
        url()
    ]);
const url = ()=>fullBox('url ', 0, 1); // Self-reference flag enabled
const stbl = (trackData)=>{
    const needsCtts = trackData.compositionTimeOffsetTable.length > 1 || trackData.compositionTimeOffsetTable.some((x)=>x.sampleCompositionTimeOffset !== 0);
    return box('stbl', undefined, [
        stsd(trackData),
        stts(trackData),
        needsCtts ? ctts(trackData) : null,
        needsCtts ? cslg(trackData) : null,
        stsc(trackData),
        stsz(trackData),
        stco(trackData),
        stss(trackData)
    ]);
};
const stsd = (trackData)=>{
    let sampleDescription;
    if (trackData.type === 'video') {
        sampleDescription = videoSampleDescription(videoCodecToBoxName(trackData.track.source._codec, trackData.info.decoderConfig.codec), trackData);
    } else if (trackData.type === 'audio') {
        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(boxName);
        sampleDescription = soundSampleDescription(boxName, trackData);
    } else if (trackData.type === 'subtitle') {
        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(sampleDescription);
    return fullBox('stsd', 0, 0, [
        u32(1)
    ], [
        sampleDescription
    ]);
};
const videoSampleDescription = (compressionType, trackData)=>box(compressionType, [
        Array(6).fill(0),
        u16(1),
        u16(0),
        u16(0),
        Array(12).fill(0),
        u16(trackData.info.width),
        u16(trackData.info.height),
        u32(0x00480000),
        u32(0x00480000),
        u32(0),
        u16(1),
        Array(32).fill(0),
        u16(0x0018),
        i16(0xffff)
    ], [
        VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["colorSpaceIsComplete"])(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null
    ]);
const colr = (trackData)=>box('colr', [
        ascii('nclx'),
        u16(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COLOR_PRIMARIES_MAP"][trackData.info.decoderConfig.colorSpace.primaries]),
        u16(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TRANSFER_CHARACTERISTICS_MAP"][trackData.info.decoderConfig.colorSpace.transfer]),
        u16(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MATRIX_COEFFICIENTS_MAP"][trackData.info.decoderConfig.colorSpace.matrix]),
        u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7)
    ]);
const avcC = (trackData)=>trackData.info.decoderConfig && box('avcC', [
        // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(trackData.info.decoderConfig.description)
    ]);
const hvcC = (trackData)=>trackData.info.decoderConfig && box('hvcC', [
        // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(trackData.info.decoderConfig.description)
    ]);
const vpcC = (trackData)=>{
    // Reference: https://www.webmproject.org/vp9/mp4/
    if (!trackData.info.decoderConfig) {
        return null;
    }
    const decoderConfig = trackData.info.decoderConfig;
    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string
    const profile = Number(parts[1]);
    const level = Number(parts[2]);
    const bitDepth = Number(parts[3]);
    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)
    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);
    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;
    const colourPrimaries = parts[5] ? Number(parts[5]) : decoderConfig.colorSpace?.primaries ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COLOR_PRIMARIES_MAP"][decoderConfig.colorSpace.primaries] : 2; // Default to undetermined
    const transferCharacteristics = parts[6] ? Number(parts[6]) : decoderConfig.colorSpace?.transfer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TRANSFER_CHARACTERISTICS_MAP"][decoderConfig.colorSpace.transfer] : 2;
    const matrixCoefficients = parts[7] ? Number(parts[7]) : decoderConfig.colorSpace?.matrix ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MATRIX_COEFFICIENTS_MAP"][decoderConfig.colorSpace.matrix] : 2;
    return fullBox('vpcC', 1, 0, [
        u8(profile),
        u8(level),
        u8(thirdByte),
        u8(colourPrimaries),
        u8(transferCharacteristics),
        u8(matrixCoefficients),
        u16(0)
    ]);
};
const av1C = (trackData)=>{
    return box('av1C', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateAv1CodecConfigurationFromCodecString"])(trackData.info.decoderConfig.codec));
};
const soundSampleDescription = (compressionType, trackData)=>{
    let version = 0;
    let contents;
    let sampleSizeInBits = 16;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PCM_AUDIO_CODECS"].includes(trackData.track.source._codec)) {
        const codec = trackData.track.source._codec;
        const { sampleSize } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(codec);
        sampleSizeInBits = 8 * sampleSize;
        if (sampleSizeInBits > 16) {
            version = 1;
        }
    }
    if (version === 0) {
        contents = [
            Array(6).fill(0),
            u16(1),
            u16(version),
            u16(0),
            u32(0),
            u16(trackData.info.numberOfChannels),
            u16(sampleSizeInBits),
            u16(0),
            u16(0),
            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0),
            u16(0)
        ];
    } else {
        contents = [
            Array(6).fill(0),
            u16(1),
            u16(version),
            u16(0),
            u32(0),
            u16(trackData.info.numberOfChannels),
            u16(Math.min(sampleSizeInBits, 16)),
            u16(0),
            u16(0),
            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0),
            u16(0),
            u32(1),
            u32(sampleSizeInBits / 8),
            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8),
            u32(2)
        ];
    }
    return box(compressionType, contents, [
        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null
    ]);
};
const esds = (trackData)=>{
    // We build up the bytes in a layered way which reflects the nested structure
    let objectTypeIndication;
    switch(trackData.track.source._codec){
        case 'aac':
            {
                objectTypeIndication = 0x40;
            }
            ;
            break;
        case 'mp3':
            {
                objectTypeIndication = 0x6b;
            }
            ;
            break;
        case 'vorbis':
            {
                objectTypeIndication = 0xdd;
            }
            ;
            break;
        default:
            throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);
    }
    let bytes = [
        ...u8(objectTypeIndication),
        ...u8(0x15),
        ...u24(0),
        ...u32(0),
        ...u32(0)
    ];
    if (trackData.info.decoderConfig.description) {
        const description = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(trackData.info.decoderConfig.description);
        // Add the decoder description to the end
        bytes = [
            ...bytes,
            ...u8(0x05),
            ...variableUnsignedInt(description.byteLength),
            ...description
        ];
    }
    bytes = [
        ...u16(1),
        ...u8(0x00),
        ...u8(0x04),
        ...variableUnsignedInt(bytes.length),
        ...bytes,
        ...u8(0x06),
        ...u8(0x01),
        ...u8(0x02)
    ];
    bytes = [
        ...u8(0x03),
        ...variableUnsignedInt(bytes.length),
        ...bytes
    ];
    return fullBox('esds', 0, 0, bytes);
};
const wave = (trackData)=>{
    return box('wave', undefined, [
        frma(trackData),
        enda(trackData),
        box('\x00\x00\x00\x00')
    ]);
};
const frma = (trackData)=>{
    return box('frma', [
        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime))
    ]);
};
const enda = (trackData)=>{
    const { littleEndian } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(trackData.track.source._codec);
    return box('enda', [
        u16(+littleEndian)
    ]);
};
const dOps = (trackData)=>{
    let outputChannelCount = trackData.info.numberOfChannels;
    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples
    let preSkip = 3840;
    let inputSampleRate = trackData.info.sampleRate;
    let outputGain = 0;
    let channelMappingFamily = 0;
    let channelMappingTable = new Uint8Array(0);
    // Read preskip and from codec private data from the encoder
    // https://www.rfc-editor.org/rfc/rfc7845#section-5
    const description = trackData.info.decoderConfig?.description;
    if (description) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(description.byteLength >= 18);
        const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(description);
        const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseOpusIdentificationHeader"])(bytes);
        outputChannelCount = header.outputChannelCount;
        preSkip = header.preSkip;
        inputSampleRate = header.inputSampleRate;
        outputGain = header.outputGain;
        channelMappingFamily = header.channelMappingFamily;
        if (header.channelMappingTable) {
            channelMappingTable = header.channelMappingTable;
        }
    }
    // https://www.opus-codec.org/docs/opus_in_isobmff.html
    return box('dOps', [
        u8(0),
        u8(outputChannelCount),
        u16(preSkip),
        u32(inputSampleRate),
        i16(outputGain),
        u8(channelMappingFamily),
        ...channelMappingTable
    ]);
};
const dfLa = (trackData)=>{
    const description = trackData.info.decoderConfig?.description;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(description);
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(description);
    return fullBox('dfLa', 0, 0, [
        ...bytes.subarray(4)
    ]);
};
/** PCM Configuration Box, ISO/IEC 23003-5. */ const pcmC = (trackData)=>{
    const { littleEndian, sampleSize } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(trackData.track.source._codec);
    const formatFlags = +littleEndian;
    return fullBox('pcmC', 0, 0, [
        u8(formatFlags),
        u8(8 * sampleSize)
    ]);
};
const subtitleSampleDescription = (compressionType, trackData)=>box(compressionType, [
        Array(6).fill(0),
        u16(1)
    ], [
        SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData)
    ]);
const vttC = (trackData)=>box('vttC', [
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(trackData.info.config.description)
    ]);
const txtC = (textConfig)=>fullBox('txtC', 0, 0, [
        ...textConfig,
        0
    ]);
const stts = (trackData)=>{
    return fullBox('stts', 0, 0, [
        u32(trackData.timeToSampleTable.length),
        trackData.timeToSampleTable.map((x)=>[
                u32(x.sampleCount),
                u32(x.sampleDelta)
            ])
    ]);
};
const stss = (trackData)=>{
    if (trackData.samples.every((x)=>x.type === 'key')) return null; // No stss box -> every frame is a key frame
    const keySamples = [
        ...trackData.samples.entries()
    ].filter(([, sample])=>sample.type === 'key');
    return fullBox('stss', 0, 0, [
        u32(keySamples.length),
        keySamples.map(([index])=>u32(index + 1))
    ]);
};
const stsc = (trackData)=>{
    return fullBox('stsc', 0, 0, [
        u32(trackData.compactlyCodedChunkTable.length),
        trackData.compactlyCodedChunkTable.map((x)=>[
                u32(x.firstChunk),
                u32(x.samplesPerChunk),
                u32(1)
            ])
    ]);
};
const stsz = (trackData)=>{
    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {
        const { sampleSize } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(trackData.track.source._codec);
        // With PCM, every sample has the same size
        return fullBox('stsz', 0, 0, [
            u32(sampleSize * trackData.info.numberOfChannels),
            u32(trackData.samples.reduce((acc, x)=>acc + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(x.duration, trackData.timescale), 0))
        ]);
    }
    return fullBox('stsz', 0, 0, [
        u32(0),
        u32(trackData.samples.length),
        trackData.samples.map((x)=>u32(x.size))
    ]);
};
const stco = (trackData)=>{
    if (trackData.finalizedChunks.length > 0 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.finalizedChunks).offset >= 2 ** 32) {
        // If the file is large, use the co64 box
        return fullBox('co64', 0, 0, [
            u32(trackData.finalizedChunks.length),
            trackData.finalizedChunks.map((x)=>u64(x.offset))
        ]);
    }
    return fullBox('stco', 0, 0, [
        u32(trackData.finalizedChunks.length),
        trackData.finalizedChunks.map((x)=>u32(x.offset))
    ]);
};
const ctts = (trackData)=>{
    return fullBox('ctts', 1, 0, [
        u32(trackData.compositionTimeOffsetTable.length),
        trackData.compositionTimeOffsetTable.map((x)=>[
                u32(x.sampleCount),
                i32(x.sampleCompositionTimeOffset)
            ])
    ]);
};
const cslg = (trackData)=>{
    let leastDecodeToDisplayDelta = Infinity;
    let greatestDecodeToDisplayDelta = -Infinity;
    let compositionStartTime = Infinity;
    let compositionEndTime = -Infinity;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.compositionTimeOffsetTable.length > 0);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.samples.length > 0);
    for(let i = 0; i < trackData.compositionTimeOffsetTable.length; i++){
        const entry = trackData.compositionTimeOffsetTable[i];
        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);
        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);
    }
    for(let i = 0; i < trackData.samples.length; i++){
        const sample = trackData.samples[i];
        compositionStartTime = Math.min(compositionStartTime, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(sample.timestamp, trackData.timescale));
        compositionEndTime = Math.max(compositionEndTime, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(sample.timestamp + sample.duration, trackData.timescale));
    }
    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);
    if (compositionEndTime >= 2 ** 31) {
        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in
        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an
        // option.
        return null;
    }
    return fullBox('cslg', 0, 0, [
        i32(compositionToDtsShift),
        i32(leastDecodeToDisplayDelta),
        i32(greatestDecodeToDisplayDelta),
        i32(compositionStartTime),
        i32(compositionEndTime)
    ]);
};
const mvex = (trackDatas)=>{
    return box('mvex', undefined, trackDatas.map(trex));
};
const trex = (trackData)=>{
    return fullBox('trex', 0, 0, [
        u32(trackData.track.id),
        u32(1),
        u32(0),
        u32(0),
        u32(0)
    ]);
};
const moof = (sequenceNumber, trackDatas)=>{
    return box('moof', undefined, [
        mfhd(sequenceNumber),
        ...trackDatas.map(traf)
    ]);
};
const mfhd = (sequenceNumber)=>{
    return fullBox('mfhd', 0, 0, [
        u32(sequenceNumber)
    ]);
};
const fragmentSampleFlags = (sample)=>{
    let byte1 = 0;
    let byte2 = 0;
    const byte3 = 0;
    const byte4 = 0;
    const sampleIsDifferenceSample = sample.type === 'delta';
    byte2 |= +sampleIsDifferenceSample;
    if (sampleIsDifferenceSample) {
        byte1 |= 1; // There is redundant coding in this sample
    } else {
        byte1 |= 2; // There is no redundant coding in this sample
    }
    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary
    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;
};
const traf = (trackData)=>{
    return box('traf', undefined, [
        tfhd(trackData),
        tfdt(trackData),
        trun(trackData)
    ]);
};
const tfhd = (trackData)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.currentChunk);
    let tfFlags = 0;
    tfFlags |= 0x00008; // Default sample duration present
    tfFlags |= 0x00010; // Default sample size present
    tfFlags |= 0x00020; // Default sample flags present
    tfFlags |= 0x20000; // Default base is moof
    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the "odd one out"
    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];
    const referenceSampleInfo = {
        duration: referenceSample.timescaleUnitsToNextSample,
        size: referenceSample.size,
        flags: fragmentSampleFlags(referenceSample)
    };
    return fullBox('tfhd', 0, tfFlags, [
        u32(trackData.track.id),
        u32(referenceSampleInfo.duration),
        u32(referenceSampleInfo.size),
        u32(referenceSampleInfo.flags)
    ]);
};
const tfdt = (trackData)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.currentChunk);
    return fullBox('tfdt', 1, 0, [
        u64((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(trackData.currentChunk.startTimestamp, trackData.timescale))
    ]);
};
const trun = (trackData)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.currentChunk);
    const allSampleDurations = trackData.currentChunk.samples.map((x)=>x.timescaleUnitsToNextSample);
    const allSampleSizes = trackData.currentChunk.samples.map((x)=>x.size);
    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);
    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(x.timestamp - x.decodeTimestamp, trackData.timescale));
    const uniqueSampleDurations = new Set(allSampleDurations);
    const uniqueSampleSizes = new Set(allSampleSizes);
    const uniqueSampleFlags = new Set(allSampleFlags);
    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);
    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];
    const sampleDurationPresent = uniqueSampleDurations.size > 1;
    const sampleSizePresent = uniqueSampleSizes.size > 1;
    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;
    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [
        ...uniqueSampleCompositionTimeOffsets
    ].some((x)=>x !== 0);
    let flags = 0;
    flags |= 0x0001; // Data offset present
    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present
    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present
    flags |= 0x0200 * +sampleSizePresent; // Sample size present
    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present
    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present
    return fullBox('trun', 1, flags, [
        u32(trackData.currentChunk.samples.length),
        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0),
        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],
        trackData.currentChunk.samples.map((_, i)=>[
                sampleDurationPresent ? u32(allSampleDurations[i]) : [],
                sampleSizePresent ? u32(allSampleSizes[i]) : [],
                sampleFlagsPresent ? u32(allSampleFlags[i]) : [],
                // Sample composition time offsets
                sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : []
            ])
    ]);
};
const mfra = (trackDatas)=>{
    return box('mfra', undefined, [
        ...trackDatas.map(tfra),
        mfro()
    ]);
};
const tfra = (trackData, trackIndex)=>{
    const version = 1; // Using this version allows us to use 64-bit time and offset values
    return fullBox('tfra', version, 0, [
        u32(trackData.track.id),
        u32(0b111111),
        u32(trackData.finalizedChunks.length),
        trackData.finalizedChunks.map((chunk)=>[
                u64((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["intoTimescale"])(chunk.samples[0].timestamp, trackData.timescale)),
                u64(chunk.moofOffset),
                u32(trackIndex + 1),
                u32(1),
                u32(1)
            ])
    ]);
};
const mfro = ()=>{
    return fullBox('mfro', 0, 0, [
        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box
        // is known
        u32(0)
    ]);
};
const vtte = ()=>box('vtte');
const vttc = (payload, timestamp, identifier, settings, sourceId)=>box('vttc', undefined, [
        sourceId !== null ? box('vsid', [
            i32(sourceId)
        ]) : null,
        identifier !== null ? box('iden', [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(identifier)
        ]) : null,
        timestamp !== null ? box('ctim', [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatSubtitleTimestamp"])(timestamp))
        ]) : null,
        settings !== null ? box('sttg', [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(settings)
        ]) : null,
        box('payl', [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(payload)
        ])
    ]);
const vtta = (notes)=>box('vtta', [
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(notes)
    ]);
/** User Data Box */ const udta = (muxer)=>{
    const boxes = [];
    const metadataFormat = muxer.format._options.metadataFormat ?? 'auto';
    const metadataTags = muxer.output._metadataTags;
    // Depending on the format, metadata tags are written differently
    if (metadataFormat === 'mdir' || metadataFormat === 'auto' && !muxer.isQuickTime) {
        const metaBox = metaMdir(metadataTags);
        if (metaBox) boxes.push(metaBox);
    } else if (metadataFormat === 'mdta') {
        const metaBox = metaMdta(metadataTags);
        if (metaBox) boxes.push(metaBox);
    } else if (metadataFormat === 'udta' || metadataFormat === 'auto' && muxer.isQuickTime) {
        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);
    }
    if (boxes.length === 0) {
        return null;
    }
    return box('udta', undefined, boxes);
};
const addQuickTimeMetadataTagBoxes = (boxes, tags)=>{
    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)
    // For QuickTime files, metadata tags are dumped into the udta box
    for (const { key, value } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keyValueIterator"])(tags)){
        switch(key){
            case 'title':
                {
                    boxes.push(metadataTagStringBoxShort('nam', value));
                }
                ;
                break;
            case 'description':
                {
                    boxes.push(metadataTagStringBoxShort('des', value));
                }
                ;
                break;
            case 'artist':
                {
                    boxes.push(metadataTagStringBoxShort('ART', value));
                }
                ;
                break;
            case 'album':
                {
                    boxes.push(metadataTagStringBoxShort('alb', value));
                }
                ;
                break;
            case 'albumArtist':
                {
                    boxes.push(metadataTagStringBoxShort('albr', value));
                }
                ;
                break;
            case 'genre':
                {
                    boxes.push(metadataTagStringBoxShort('gen', value));
                }
                ;
                break;
            case 'date':
                {
                    boxes.push(metadataTagStringBoxShort('day', value.toISOString().slice(0, 10)));
                }
                ;
                break;
            case 'comment':
                {
                    boxes.push(metadataTagStringBoxShort('cmt', value));
                }
                ;
                break;
            case 'lyrics':
                {
                    boxes.push(metadataTagStringBoxShort('lyr', value));
                }
                ;
                break;
            case 'raw':
                {
                // Handled later
                }
                ;
                break;
            case 'discNumber':
            case 'discsTotal':
            case 'trackNumber':
            case 'tracksTotal':
            case 'images':
                {
                // Not written for QuickTime (common Apple L)
                }
                ;
                break;
            default:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertNever"])(key);
        }
    }
    if (tags.raw) {
        for(const key in tags.raw){
            const value = tags.raw[key];
            if (value == null || key.length !== 4 || boxes.some((x)=>x.type === key)) {
                continue;
            }
            if (typeof value === 'string') {
                boxes.push(metadataTagStringBoxShort(key, value));
            } else if (value instanceof Uint8Array) {
                boxes.push(box(key, Array.from(value)));
            }
        }
    }
};
const metadataTagStringBoxShort = (name, value)=>{
    const encoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(value);
    return box(name, [
        u16(encoded.length),
        u16(getLanguageCodeInt('und')),
        Array.from(encoded)
    ]);
};
const DATA_BOX_MIME_TYPE_MAP = {
    'image/jpeg': 13,
    'image/png': 14,
    'image/bmp': 27
};
/**
 * Generates key-value metadata for inclusion in the "meta" box.
 */ const generateMetadataPairs = (tags, isMdta)=>{
    const pairs = [];
    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)
    // This is the metadata format used for MP4 files
    for (const { key, value } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keyValueIterator"])(tags)){
        switch(key){
            case 'title':
                {
                    pairs.push({
                        key: isMdta ? 'title' : 'nam',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'description':
                {
                    pairs.push({
                        key: isMdta ? 'description' : 'des',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'artist':
                {
                    pairs.push({
                        key: isMdta ? 'artist' : 'ART',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'album':
                {
                    pairs.push({
                        key: isMdta ? 'album' : 'alb',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'albumArtist':
                {
                    pairs.push({
                        key: isMdta ? 'album_artist' : 'aART',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'comment':
                {
                    pairs.push({
                        key: isMdta ? 'comment' : 'cmt',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'genre':
                {
                    pairs.push({
                        key: isMdta ? 'genre' : 'gen',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'lyrics':
                {
                    pairs.push({
                        key: isMdta ? 'lyrics' : 'lyr',
                        value: dataStringBoxLong(value)
                    });
                }
                ;
                break;
            case 'date':
                {
                    pairs.push({
                        key: isMdta ? 'date' : 'day',
                        value: dataStringBoxLong(value.toISOString().slice(0, 10))
                    });
                }
                ;
                break;
            case 'images':
                {
                    for (const image of value){
                        if (image.kind !== 'coverFront') {
                            continue;
                        }
                        pairs.push({
                            key: 'covr',
                            value: box('data', [
                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0),
                                u32(0),
                                Array.from(image.data)
                            ])
                        });
                    }
                }
                ;
                break;
            case 'trackNumber':
                {
                    if (isMdta) {
                        const string = tags.tracksTotal !== undefined ? `${value}/${tags.tracksTotal}` : value.toString();
                        pairs.push({
                            key: 'track',
                            value: dataStringBoxLong(string)
                        });
                    } else {
                        pairs.push({
                            key: 'trkn',
                            value: box('data', [
                                u32(0),
                                u32(0),
                                u16(0),
                                u16(value),
                                u16(tags.tracksTotal ?? 0),
                                u16(0)
                            ])
                        });
                    }
                }
                ;
                break;
            case 'discNumber':
                {
                    if (!isMdta) {
                        // Only written for mdir
                        pairs.push({
                            key: 'disc',
                            value: box('data', [
                                u32(0),
                                u32(0),
                                u16(0),
                                u16(value),
                                u16(tags.discsTotal ?? 0),
                                u16(0)
                            ])
                        });
                    }
                }
                ;
                break;
            case 'tracksTotal':
            case 'discsTotal':
                {
                // These are included with 'trackNumber' and 'discNumber' respectively
                }
                ;
                break;
            case 'raw':
                {
                // Handled later
                }
                ;
                break;
            default:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertNever"])(key);
        }
    }
    if (tags.raw) {
        for(const key in tags.raw){
            const value = tags.raw[key];
            if (value == null || !isMdta && key.length !== 4 || pairs.some((x)=>x.key === key)) {
                continue;
            }
            if (typeof value === 'string') {
                pairs.push({
                    key,
                    value: dataStringBoxLong(value)
                });
            } else if (value instanceof Uint8Array) {
                pairs.push({
                    key,
                    value: box('data', [
                        u32(0),
                        u32(0),
                        Array.from(value)
                    ])
                });
            } else if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RichImageData"]) {
                pairs.push({
                    key,
                    value: box('data', [
                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0),
                        u32(0),
                        Array.from(value.data)
                    ])
                });
            }
        }
    }
    return pairs;
};
/** Metadata Box (mdir format) */ const metaMdir = (tags)=>{
    const pairs = generateMetadataPairs(tags, false);
    if (pairs.length === 0) {
        return null;
    }
    // fullBox format
    return fullBox('meta', 0, 0, undefined, [
        hdlr(false, 'mdir', '', 'appl'),
        box('ilst', undefined, pairs.map((pair)=>box(pair.key, undefined, [
                pair.value
            ])))
    ]);
};
/** Metadata Box (mdta format with keys box) */ const metaMdta = (tags)=>{
    const pairs = generateMetadataPairs(tags, true);
    if (pairs.length === 0) {
        return null;
    }
    // box without version and flags
    return box('meta', undefined, [
        hdlr(false, 'mdta', ''),
        fullBox('keys', 0, 0, [
            u32(pairs.length)
        ], pairs.map((pair)=>box('mdta', [
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(pair.key)
            ]))),
        box('ilst', undefined, pairs.map((pair, i)=>{
            const boxName = String.fromCharCode(...u32(i + 1));
            return box(boxName, undefined, [
                pair.value
            ]);
        }))
    ]);
};
const dataStringBoxLong = (value)=>{
    return box('data', [
        u32(1),
        u32(0),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(value)
    ]);
};
const videoCodecToBoxName = (codec, fullCodecString)=>{
    switch(codec){
        case 'avc':
            return fullCodecString.startsWith('avc3') ? 'avc3' : 'avc1';
        case 'hevc':
            return 'hvc1';
        case 'vp8':
            return 'vp08';
        case 'vp9':
            return 'vp09';
        case 'av1':
            return 'av01';
    }
};
const VIDEO_CODEC_TO_CONFIGURATION_BOX = {
    avc: avcC,
    hevc: hvcC,
    vp8: vpcC,
    vp9: vpcC,
    av1: av1C
};
const audioCodecToBoxName = (codec, isQuickTime)=>{
    switch(codec){
        case 'aac':
            return 'mp4a';
        case 'mp3':
            return 'mp4a';
        case 'opus':
            return 'Opus';
        case 'vorbis':
            return 'mp4a';
        case 'flac':
            return 'fLaC';
        case 'ulaw':
            return 'ulaw';
        case 'alaw':
            return 'alaw';
        case 'pcm-u8':
            return 'raw ';
        case 'pcm-s8':
            return 'sowt';
    }
    // Logic diverges here
    if (isQuickTime) {
        switch(codec){
            case 'pcm-s16':
                return 'sowt';
            case 'pcm-s16be':
                return 'twos';
            case 'pcm-s24':
                return 'in24';
            case 'pcm-s24be':
                return 'in24';
            case 'pcm-s32':
                return 'in32';
            case 'pcm-s32be':
                return 'in32';
            case 'pcm-f32':
                return 'fl32';
            case 'pcm-f32be':
                return 'fl32';
            case 'pcm-f64':
                return 'fl64';
            case 'pcm-f64be':
                return 'fl64';
        }
    } else {
        switch(codec){
            case 'pcm-s16':
                return 'ipcm';
            case 'pcm-s16be':
                return 'ipcm';
            case 'pcm-s24':
                return 'ipcm';
            case 'pcm-s24be':
                return 'ipcm';
            case 'pcm-s32':
                return 'ipcm';
            case 'pcm-s32be':
                return 'ipcm';
            case 'pcm-f32':
                return 'fpcm';
            case 'pcm-f32be':
                return 'fpcm';
            case 'pcm-f64':
                return 'fpcm';
            case 'pcm-f64be':
                return 'fpcm';
        }
    }
};
const audioCodecToConfigurationBox = (codec, isQuickTime)=>{
    switch(codec){
        case 'aac':
            return esds;
        case 'mp3':
            return esds;
        case 'opus':
            return dOps;
        case 'vorbis':
            return esds;
        case 'flac':
            return dfLa;
    }
    // Logic diverges here
    if (isQuickTime) {
        switch(codec){
            case 'pcm-s24':
                return wave;
            case 'pcm-s24be':
                return wave;
            case 'pcm-s32':
                return wave;
            case 'pcm-s32be':
                return wave;
            case 'pcm-f32':
                return wave;
            case 'pcm-f32be':
                return wave;
            case 'pcm-f64':
                return wave;
            case 'pcm-f64be':
                return wave;
        }
    } else {
        switch(codec){
            case 'pcm-s16':
                return pcmC;
            case 'pcm-s16be':
                return pcmC;
            case 'pcm-s24':
                return pcmC;
            case 'pcm-s24be':
                return pcmC;
            case 'pcm-s32':
                return pcmC;
            case 'pcm-s32be':
                return pcmC;
            case 'pcm-f32':
                return pcmC;
            case 'pcm-f32be':
                return pcmC;
            case 'pcm-f64':
                return pcmC;
            case 'pcm-f64be':
                return pcmC;
        }
    }
    return null;
};
const SUBTITLE_CODEC_TO_BOX_NAME = {
    webvtt: 'wvtt'
};
const SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {
    webvtt: vttC
};
const getLanguageCodeInt = (code)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(code.length === 3);
    ;
    let language = 0;
    for(let i = 0; i < 3; i++){
        language <<= 5;
        language += code.charCodeAt(i) - 0x60;
    }
    return language;
};
}),
"[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "GLOBAL_TIMESCALE",
    ()=>GLOBAL_TIMESCALE,
    "IsobmffMuxer",
    ()=>IsobmffMuxer,
    "getTrackMetadata",
    ()=>getTrackMetadata,
    "intoTimescale",
    ()=>intoTimescale
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/muxer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$writer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/writer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/output-format.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/subtitles.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/target.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec-data.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const GLOBAL_TIMESCALE = 1000;
const TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970
const getTrackMetadata = (trackData)=>{
    const metadata = {};
    const track = trackData.track;
    if (track.metadata.name !== undefined) {
        metadata.name = track.metadata.name;
    }
    return metadata;
};
const intoTimescale = (timeInSeconds, timescale, round = true)=>{
    const value = timeInSeconds * timescale;
    return round ? Math.round(value) : value;
};
class IsobmffMuxer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Muxer"] {
    constructor(output, format){
        super(output);
        this.auxTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$target$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BufferTarget"]();
        this.auxWriter = this.auxTarget._createWriter();
        this.auxBoxWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IsobmffBoxWriter"](this.auxWriter);
        this.mdat = null;
        this.ftypSize = null;
        this.trackDatas = [];
        this.allTracksKnown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["promiseWithResolvers"])();
        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;
        this.finalizedChunks = [];
        this.nextFragmentNumber = 1;
        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far
        this.maxWrittenTimestamp = -Infinity;
        this.format = format;
        this.writer = output._writer;
        this.boxWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IsobmffBoxWriter"](this.writer);
        this.isQuickTime = format instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MovOutputFormat"];
        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the
        // memory usage remains identical
        const fastStartDefault = this.writer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$writer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BufferTargetWriter"] ? 'in-memory' : false;
        this.fastStart = format._options.fastStart ?? fastStartDefault;
        this.isFragmented = this.fastStart === 'fragmented';
        if (this.fastStart === 'in-memory' || this.isFragmented) {
            this.writer.ensureMonotonicity = true;
        }
        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;
    }
    async start() {
        const release = await this.mutex.acquire();
        const holdsAvc = this.output._tracks.some((x)=>x.type === 'video' && x.source._codec === 'avc');
        // Write the header
        {
            if (this.format._options.onFtyp) {
                this.writer.startTrackingWrites();
            }
            this.boxWriter.writeBox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ftyp"])({
                isQuickTime: this.isQuickTime,
                holdsAvc: holdsAvc,
                fragmented: this.isFragmented
            }));
            if (this.format._options.onFtyp) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onFtyp(data, start);
            }
        }
        this.ftypSize = this.writer.getPos();
        if (this.fastStart === 'in-memory') {
        // We're write at finalization
        } else if (this.fastStart === 'reserve') {
            // Validate that all tracks have set maximumPacketCount
            for (const track of this.output._tracks){
                if (track.metadata.maximumPacketCount === undefined) {
                    throw new Error('All tracks must specify maximumPacketCount in their metadata when using' + ' fastStart: \'reserve\'.');
                }
            }
        // We'll start writing once we know all tracks
        } else if (this.isFragmented) {
        // We write the moov box once we write out the first fragment to make sure we get the decoder configs
        } else {
            if (this.format._options.onMdat) {
                this.writer.startTrackingWrites();
            }
            this.mdat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mdat"])(true); // Reserve large size by default, can refine this when finalizing.
            this.boxWriter.writeBox(this.mdat);
        }
        await this.writer.flush();
        release();
    }
    allTracksAreKnown() {
        for (const track of this.output._tracks){
            if (!track.source._closed && !this.trackDatas.some((x)=>x.track === track)) {
                return false; // We haven't seen a sample from this open track yet
            }
        }
        return true;
    }
    async getMimeType() {
        await this.allTracksKnown.promise;
        const codecStrings = this.trackDatas.map((trackData)=>{
            if (trackData.type === 'video') {
                return trackData.info.decoderConfig.codec;
            } else if (trackData.type === 'audio') {
                return trackData.info.decoderConfig.codec;
            } else {
                const map = {
                    webvtt: 'wvtt'
                };
                return map[trackData.track.source._codec];
            }
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildIsobmffMimeType"])({
            isQuickTime: this.isQuickTime,
            hasVideo: this.trackDatas.some((x)=>x.type === 'video'),
            hasAudio: this.trackDatas.some((x)=>x.type === 'audio'),
            codecStrings
        });
    }
    getVideoTrackData(track, packet, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateVideoChunkMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig);
        const decoderConfig = {
            ...meta.decoderConfig
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(decoderConfig.codedWidth !== undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(decoderConfig.codedHeight !== undefined);
        let requiresAnnexBTransformation = false;
        if (track.source._codec === 'avc' && !decoderConfig.description) {
            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates
            // Annex B. This means we'll need to do some converterino.
            const decoderConfigurationRecord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAvcDecoderConfigurationRecord"])(packet.data);
            if (!decoderConfigurationRecord) {
                throw new Error('Couldn\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are' + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or' + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)' + ' and ensure the packets are in AVCC format.');
            }
            decoderConfig.description = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeAvcDecoderConfigurationRecord"])(decoderConfigurationRecord);
            requiresAnnexBTransformation = true;
        } else if (track.source._codec === 'hevc' && !decoderConfig.description) {
            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates
            // Annex B. This means we'll need to do some converterino.
            const decoderConfigurationRecord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractHevcDecoderConfigurationRecord"])(packet.data);
            if (!decoderConfigurationRecord) {
                throw new Error('Couldn\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets' + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or' + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)' + ' and ensure the packets are in HEVC format.');
            }
            decoderConfig.description = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeHevcDecoderConfigurationRecord"])(decoderConfigurationRecord);
            requiresAnnexBTransformation = true;
        }
        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the
        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator
        // as the timescale.
        const timescale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["computeRationalApproximation"])(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;
        const newTrackData = {
            muxer: this,
            track,
            type: 'video',
            info: {
                width: decoderConfig.codedWidth,
                height: decoderConfig.codedHeight,
                decoderConfig: decoderConfig,
                requiresAnnexBTransformation
            },
            timescale,
            samples: [],
            sampleQueue: [],
            timestampProcessingQueue: [],
            timeToSampleTable: [],
            compositionTimeOffsetTable: [],
            lastTimescaleUnits: null,
            lastSample: null,
            finalizedChunks: [],
            currentChunk: null,
            compactlyCodedChunkTable: []
        };
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    getAudioTrackData(track, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateAudioChunkMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig);
        const newTrackData = {
            muxer: this,
            track,
            type: 'audio',
            info: {
                numberOfChannels: meta.decoderConfig.numberOfChannels,
                sampleRate: meta.decoderConfig.sampleRate,
                decoderConfig: meta.decoderConfig,
                requiresPcmTransformation: !this.isFragmented && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PCM_AUDIO_CODECS"].includes(track.source._codec)
            },
            timescale: meta.decoderConfig.sampleRate,
            samples: [],
            sampleQueue: [],
            timestampProcessingQueue: [],
            timeToSampleTable: [],
            compositionTimeOffsetTable: [],
            lastTimescaleUnits: null,
            lastSample: null,
            finalizedChunks: [],
            currentChunk: null,
            compactlyCodedChunkTable: []
        };
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    getSubtitleTrackData(track, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateSubtitleMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.config);
        const newTrackData = {
            muxer: this,
            track,
            type: 'subtitle',
            info: {
                config: meta.config
            },
            timescale: 1000,
            samples: [],
            sampleQueue: [],
            timestampProcessingQueue: [],
            timeToSampleTable: [],
            compositionTimeOffsetTable: [],
            lastTimescaleUnits: null,
            lastSample: null,
            finalizedChunks: [],
            currentChunk: null,
            compactlyCodedChunkTable: [],
            lastCueEndTimestamp: 0,
            cueQueue: [],
            nextSourceId: 0,
            cueToSourceId: new WeakMap()
        };
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    async addEncodedVideoPacket(track, packet, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getVideoTrackData(track, packet, meta);
            let packetData = packet.data;
            if (trackData.info.requiresAnnexBTransformation) {
                const transformedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["transformAnnexBToLengthPrefixed"])(packetData);
                if (!transformedData) {
                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as' + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');
                }
                packetData = transformedData;
            }
            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');
            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);
            await this.registerSample(trackData, internalSample);
        } finally{
            release();
        }
    }
    async addEncodedAudioPacket(track, packet, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getAudioTrackData(track, meta);
            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');
            const internalSample = this.createSampleForTrack(trackData, packet.data, timestamp, packet.duration, packet.type);
            if (trackData.info.requiresPcmTransformation) {
                await this.maybePadWithSilence(trackData, timestamp);
            }
            await this.registerSample(trackData, internalSample);
        } finally{
            release();
        }
    }
    async maybePadWithSilence(trackData, untilTimestamp) {
        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so
        // we need to pad the "holes" in between samples (and before the first sample) with additional
        // "silence samples".
        const lastSample = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.samples);
        const lastEndTimestamp = lastSample ? lastSample.timestamp + lastSample.duration : 0;
        const delta = untilTimestamp - lastEndTimestamp;
        const deltaInTimescale = intoTimescale(delta, trackData.timescale);
        if (deltaInTimescale > 0) {
            const { sampleSize, silentValue } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(trackData.info.decoderConfig.codec);
            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;
            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);
            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');
            await this.registerSample(trackData, paddingSample);
        }
    }
    async addSubtitleCue(track, cue, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getSubtitleTrackData(track, meta);
            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);
            if (track.source._codec === 'webvtt') {
                trackData.cueQueue.push(cue);
                await this.processWebVTTCues(trackData, cue.timestamp);
            } else {
            // TODO
            }
        } finally{
            release();
        }
    }
    async processWebVTTCues(trackData, until) {
        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and
        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.
        while(trackData.cueQueue.length > 0){
            const timestamps = new Set([]);
            for (const cue of trackData.cueQueue){
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(cue.timestamp <= until);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);
                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp
                timestamps.add(cue.timestamp + cue.duration); // End timestamp
            }
            const sortedTimestamps = [
                ...timestamps
            ].sort((a, b)=>a - b);
            // These are the timestamps of the next sample we'll create:
            const sampleStart = sortedTimestamps[0];
            const sampleEnd = sortedTimestamps[1] ?? sampleStart;
            if (until < sampleEnd) {
                break;
            }
            // We may need to pad out empty space with an vtte box
            if (trackData.lastCueEndTimestamp < sampleStart) {
                this.auxWriter.seek(0);
                const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["vtte"])();
                this.auxBoxWriter.writeBox(box);
                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());
                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');
                await this.registerSample(trackData, sample);
                trackData.lastCueEndTimestamp = sampleStart;
            }
            this.auxWriter.seek(0);
            for(let i = 0; i < trackData.cueQueue.length; i++){
                const cue = trackData.cueQueue[i];
                if (cue.timestamp >= sampleEnd) {
                    break;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlineTimestampRegex"].lastIndex = 0;
                const containsTimestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlineTimestampRegex"].test(cue.text);
                const endTimestamp = cue.timestamp + cue.duration;
                let sourceId = trackData.cueToSourceId.get(cue);
                if (sourceId === undefined && sampleEnd < endTimestamp) {
                    // We know this cue will appear in more than one sample, therefore we need to mark it with a
                    // unique ID
                    sourceId = trackData.nextSourceId++;
                    trackData.cueToSourceId.set(cue, sourceId);
                }
                if (cue.notes) {
                    // Any notes/comments are included in a special vtta box
                    const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["vtta"])(cue.notes);
                    this.auxBoxWriter.writeBox(box);
                }
                const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["vttc"])(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);
                this.auxBoxWriter.writeBox(box);
                if (endTimestamp === sampleEnd) {
                    // The cue won't appear in any future sample, so we're done with it
                    trackData.cueQueue.splice(i--, 1);
                }
            }
            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());
            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');
            await this.registerSample(trackData, sample);
            trackData.lastCueEndTimestamp = sampleEnd;
        }
    }
    createSampleForTrack(trackData, data, timestamp, duration, type) {
        const sample = {
            timestamp,
            decodeTimestamp: timestamp,
            duration,
            data,
            size: data.byteLength,
            type,
            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale)
        };
        return sample;
    }
    processTimestamps(trackData, nextSample) {
        if (trackData.timestampProcessingQueue.length === 0) {
            return;
        }
        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {
            let totalDuration = 0;
            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)
            // and simply say that's how many new samples there are.
            for(let i = 0; i < trackData.timestampProcessingQueue.length; i++){
                const sample = trackData.timestampProcessingQueue[i];
                const duration = intoTimescale(sample.duration, trackData.timescale);
                totalDuration += duration;
            }
            if (trackData.timeToSampleTable.length === 0) {
                trackData.timeToSampleTable.push({
                    sampleCount: totalDuration,
                    sampleDelta: 1
                });
            } else {
                const lastEntry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.timeToSampleTable);
                lastEntry.sampleCount += totalDuration;
            }
            trackData.timestampProcessingQueue.length = 0;
            return;
        }
        const sortedTimestamps = trackData.timestampProcessingQueue.map((x)=>x.timestamp).sort((a, b)=>a - b);
        for(let i = 0; i < trackData.timestampProcessingQueue.length; i++){
            const sample = trackData.timestampProcessingQueue[i];
            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from
            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense
            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to
            // model it.
            sample.decodeTimestamp = sortedTimestamps[i];
            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {
                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation
                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.
                sample.decodeTimestamp = 0;
            }
            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);
            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);
            if (trackData.lastTimescaleUnits !== null) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.lastSample);
                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);
                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(delta >= 0);
                trackData.lastTimescaleUnits += delta;
                trackData.lastSample.timescaleUnitsToNextSample = delta;
                if (!this.isFragmented) {
                    let lastTableEntry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.timeToSampleTable);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(lastTableEntry);
                    if (lastTableEntry.sampleCount === 1) {
                        lastTableEntry.sampleDelta = delta;
                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];
                        if (entryBefore && entryBefore.sampleDelta === delta) {
                            // If the delta is the same as the previous one, merge the two entries
                            entryBefore.sampleCount++;
                            trackData.timeToSampleTable.pop();
                            lastTableEntry = entryBefore;
                        }
                    } else if (lastTableEntry.sampleDelta !== delta) {
                        // The delta has changed, so we need a new entry to reach the current sample
                        lastTableEntry.sampleCount--;
                        trackData.timeToSampleTable.push(lastTableEntry = {
                            sampleCount: 1,
                            sampleDelta: delta
                        });
                    }
                    if (lastTableEntry.sampleDelta === durationInTimescale) {
                        // The sample's duration matches the delta, so we can increment the count
                        lastTableEntry.sampleCount++;
                    } else {
                        // Add a new entry in order to maintain the last sample's true duration
                        trackData.timeToSampleTable.push({
                            sampleCount: 1,
                            sampleDelta: durationInTimescale
                        });
                    }
                    const lastCompositionTimeOffsetTableEntry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.compositionTimeOffsetTable);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(lastCompositionTimeOffsetTableEntry);
                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {
                        // Simply increment the count
                        lastCompositionTimeOffsetTableEntry.sampleCount++;
                    } else {
                        // The composition time offset has changed, so create a new entry with the new composition time
                        // offset
                        trackData.compositionTimeOffsetTable.push({
                            sampleCount: 1,
                            sampleCompositionTimeOffset: sampleCompositionTimeOffset
                        });
                    }
                }
            } else {
                // Decode timestamp of the first sample
                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);
                if (!this.isFragmented) {
                    trackData.timeToSampleTable.push({
                        sampleCount: 1,
                        sampleDelta: durationInTimescale
                    });
                    trackData.compositionTimeOffsetTable.push({
                        sampleCount: 1,
                        sampleCompositionTimeOffset: sampleCompositionTimeOffset
                    });
                }
            }
            trackData.lastSample = sample;
        }
        trackData.timestampProcessingQueue.length = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.lastSample);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.lastTimescaleUnits !== null);
        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(nextSample.type === 'key');
            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having
            // the last sample's duration in each fragment be "0" for fragmented files. The guess we make here is
            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key
            // frame (although it can happen).
            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);
            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);
            trackData.lastSample.timescaleUnitsToNextSample = delta;
        }
    }
    async registerSample(trackData, sample) {
        if (sample.type === 'key') {
            this.processTimestamps(trackData, sample);
        }
        trackData.timestampProcessingQueue.push(sample);
        if (this.isFragmented) {
            trackData.sampleQueue.push(sample);
            await this.interleaveSamples();
        } else if (this.fastStart === 'reserve') {
            await this.registerSampleFastStartReserve(trackData, sample);
        } else {
            await this.addSampleToTrack(trackData, sample);
        }
    }
    async addSampleToTrack(trackData, sample) {
        if (!this.isFragmented) {
            trackData.samples.push(sample);
            if (this.fastStart === 'reserve') {
                const maximumPacketCount = trackData.track.metadata.maximumPacketCount;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(maximumPacketCount !== undefined);
                if (trackData.samples.length > maximumPacketCount) {
                    throw new Error(`Track #${trackData.track.id} has already reached the maximum packet count` + ` (${maximumPacketCount}). Either add less packets or increase the maximum packet count.`);
                }
            }
        }
        let beginNewChunk = false;
        if (!trackData.currentChunk) {
            beginNewChunk = true;
        } else {
            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of
            // the chunk
            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);
            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;
            if (this.isFragmented) {
                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to
                // start the new one with a key frame.
                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData)=>{
                    if (trackData === otherTrackData) {
                        return sample.type === 'key';
                    }
                    const firstQueuedSample = otherTrackData.sampleQueue[0];
                    if (firstQueuedSample) {
                        return firstQueuedSample.type === 'key';
                    }
                    return otherTrackData.track.source._closed;
                });
                if (currentChunkDuration >= this.minimumFragmentDuration && keyFrameQueuedEverywhere && sample.timestamp > this.maxWrittenTimestamp) {
                    beginNewChunk = true;
                    await this.finalizeFragment();
                }
            } else {
                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one
            }
        }
        if (beginNewChunk) {
            if (trackData.currentChunk) {
                await this.finalizeCurrentChunk(trackData);
            }
            trackData.currentChunk = {
                startTimestamp: sample.timestamp,
                samples: [],
                offset: null,
                moofOffset: null
            };
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.currentChunk);
        trackData.currentChunk.samples.push(sample);
        if (this.isFragmented) {
            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);
        }
    }
    async finalizeCurrentChunk(trackData) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(!this.isFragmented);
        if (!trackData.currentChunk) return;
        trackData.finalizedChunks.push(trackData.currentChunk);
        this.finalizedChunks.push(trackData.currentChunk);
        let sampleCount = trackData.currentChunk.samples.length;
        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {
            sampleCount = trackData.currentChunk.samples.reduce((acc, sample)=>acc + intoTimescale(sample.duration, trackData.timescale), 0);
        }
        if (trackData.compactlyCodedChunkTable.length === 0 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {
            trackData.compactlyCodedChunkTable.push({
                firstChunk: trackData.finalizedChunks.length,
                samplesPerChunk: sampleCount
            });
        }
        if (this.fastStart === 'in-memory') {
            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing
            return;
        }
        // Write out the data
        trackData.currentChunk.offset = this.writer.getPos();
        for (const sample of trackData.currentChunk.samples){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(sample.data);
            this.writer.write(sample.data);
            sample.data = null; // Can be GC'd
        }
        await this.writer.flush();
    }
    async interleaveSamples(isFinalCall = false) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.isFragmented);
        if (!isFinalCall && !this.allTracksAreKnown()) {
            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have
        }
        outer: while(true){
            let trackWithMinTimestamp = null;
            let minTimestamp = Infinity;
            for (const trackData of this.trackDatas){
                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {
                    break outer;
                }
                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {
                    trackWithMinTimestamp = trackData;
                    minTimestamp = trackData.sampleQueue[0].timestamp;
                }
            }
            if (!trackWithMinTimestamp) {
                break;
            }
            const sample = trackWithMinTimestamp.sampleQueue.shift();
            await this.addSampleToTrack(trackWithMinTimestamp, sample);
        }
    }
    async finalizeFragment(flushWriter = true) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.isFragmented);
        const fragmentNumber = this.nextFragmentNumber++;
        if (fragmentNumber === 1) {
            if (this.format._options.onMoov) {
                this.writer.startTrackingWrites();
            }
            // Write the moov box now that we have all decoder configs
            const movieBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moov"])(this);
            this.boxWriter.writeBox(movieBox);
            if (this.format._options.onMoov) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(data, start);
            }
        }
        // Not all tracks need to be present in every fragment
        const tracksInFragment = this.trackDatas.filter((x)=>x.currentChunk);
        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin
        const moofBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moof"])(fragmentNumber, tracksInFragment);
        const moofOffset = this.writer.getPos();
        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);
        let currentPos = mdatStartPos + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"];
        let fragmentStartTimestamp = Infinity;
        for (const trackData of tracksInFragment){
            trackData.currentChunk.offset = currentPos;
            trackData.currentChunk.moofOffset = moofOffset;
            for (const sample of trackData.currentChunk.samples){
                currentPos += sample.size;
            }
            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);
        }
        const mdatSize = currentPos - mdatStartPos;
        const needsLargeMdatSize = mdatSize >= 2 ** 32;
        if (needsLargeMdatSize) {
            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what
            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).
            for (const trackData of tracksInFragment){
                trackData.currentChunk.offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"] - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"];
            }
        }
        if (this.format._options.onMoof) {
            this.writer.startTrackingWrites();
        }
        const newMoofBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moof"])(fragmentNumber, tracksInFragment);
        this.boxWriter.writeBox(newMoofBox);
        if (this.format._options.onMoof) {
            const { data, start } = this.writer.stopTrackingWrites();
            this.format._options.onMoof(data, start, fragmentStartTimestamp);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.writer.getPos() === mdatStartPos);
        if (this.format._options.onMdat) {
            this.writer.startTrackingWrites();
        }
        const mdatBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mdat"])(needsLargeMdatSize);
        mdatBox.size = mdatSize;
        this.boxWriter.writeBox(mdatBox);
        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_BOX_HEADER_SIZE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_BOX_HEADER_SIZE"]));
        // Write sample data
        for (const trackData of tracksInFragment){
            for (const sample of trackData.currentChunk.samples){
                this.writer.write(sample.data);
                sample.data = null; // Can be GC'd
            }
        }
        if (this.format._options.onMdat) {
            const { data, start } = this.writer.stopTrackingWrites();
            this.format._options.onMdat(data, start);
        }
        for (const trackData of tracksInFragment){
            trackData.finalizedChunks.push(trackData.currentChunk);
            this.finalizedChunks.push(trackData.currentChunk);
            trackData.currentChunk = null;
        }
        if (flushWriter) {
            await this.writer.flush();
        }
    }
    async registerSampleFastStartReserve(trackData, sample) {
        if (this.allTracksAreKnown()) {
            if (!this.mdat) {
                // We finally know all tracks, let's reserve space for the moov box
                const moovBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moov"])(this);
                const moovSize = this.boxWriter.measureBox(moovBox);
                const reservedSize = moovSize + this.computeSampleTableSizeUpperBound() + 4096; // Just a little extra headroom
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.ftypSize !== null);
                this.writer.seek(this.ftypSize + reservedSize);
                if (this.format._options.onMdat) {
                    this.writer.startTrackingWrites();
                }
                this.mdat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mdat"])(true);
                this.boxWriter.writeBox(this.mdat);
                // Now write everything that was queued
                for (const trackData of this.trackDatas){
                    for (const sample of trackData.sampleQueue){
                        await this.addSampleToTrack(trackData, sample);
                    }
                    trackData.sampleQueue.length = 0;
                }
            }
            await this.addSampleToTrack(trackData, sample);
        } else {
            // Queue it for when we know all tracks
            trackData.sampleQueue.push(sample);
        }
    }
    computeSampleTableSizeUpperBound() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.fastStart === 'reserve');
        let upperBound = 0;
        for (const trackData of this.trackDatas){
            const n = trackData.track.metadata.maximumPacketCount;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(n !== undefined); // We validated this earlier
            // Given the max allowed packet count, compute the space they'll take up in the Sample Table Box, assuming
            // the worst case for each individual box:
            // stts box - since it is compactly coded, the maximum length of this table will be 2/3n
            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);
            // stss box - 1 entry per sample
            upperBound += 4 * n;
            // ctts box - since it is compactly coded, the maximum length of this table will be 2/3n
            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);
            // stsc box - since it is compactly coded, the maximum length of this table will be 2/3n
            upperBound += (4 + 4 + 4) * Math.ceil(2 / 3 * n);
            // stsz box - 1 entry per sample
            upperBound += 4 * n;
            // co64 box - we assume 1 sample per chunk and 64-bit chunk offsets (co64 instead of stco)
            upperBound += 8 * n;
        }
        return upperBound;
    }
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    async onTrackClose(track) {
        const release = await this.mutex.acquire();
        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {
            const trackData = this.trackDatas.find((x)=>x.track === track);
            if (trackData) {
                await this.processWebVTTCues(trackData, Infinity);
            }
        }
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        if (this.isFragmented) {
            // Since a track is now closed, we may be able to write out chunks that were previously waiting
            await this.interleaveSamples();
        }
        release();
    }
    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */ async finalize() {
        const release = await this.mutex.acquire();
        this.allTracksKnown.resolve();
        for (const trackData of this.trackDatas){
            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {
                await this.processWebVTTCues(trackData, Infinity);
            }
        }
        if (this.isFragmented) {
            await this.interleaveSamples(true);
            for (const trackData of this.trackDatas){
                this.processTimestamps(trackData);
            }
            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box
        } else {
            for (const trackData of this.trackDatas){
                this.processTimestamps(trackData);
                await this.finalizeCurrentChunk(trackData);
            }
        }
        if (this.fastStart === 'in-memory') {
            this.mdat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mdat"])(false);
            let mdatSize;
            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:
            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we
            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative
            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then
            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box
            // being used in the moov box instead, which will make it larger. After that, we definitely know the final
            // size of the moov box and can compute the proper chunk positions.
            for(let i = 0; i < 2; i++){
                const movieBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moov"])(this);
                const movieBoxSize = this.boxWriter.measureBox(movieBox);
                mdatSize = this.boxWriter.measureBox(this.mdat);
                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;
                for (const chunk of this.finalizedChunks){
                    chunk.offset = currentChunkPos;
                    for (const { data } of chunk.samples){
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(data);
                        currentChunkPos += data.byteLength;
                        mdatSize += data.byteLength;
                    }
                }
                if (currentChunkPos < 2 ** 32) break;
                if (mdatSize >= 2 ** 32) this.mdat.largeSize = true;
            }
            if (this.format._options.onMoov) {
                this.writer.startTrackingWrites();
            }
            const movieBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moov"])(this);
            this.boxWriter.writeBox(movieBox);
            if (this.format._options.onMoov) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(data, start);
            }
            if (this.format._options.onMdat) {
                this.writer.startTrackingWrites();
            }
            this.mdat.size = mdatSize;
            this.boxWriter.writeBox(this.mdat);
            for (const chunk of this.finalizedChunks){
                for (const sample of chunk.samples){
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(sample.data);
                    this.writer.write(sample.data);
                    sample.data = null;
                }
            }
            if (this.format._options.onMdat) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onMdat(data, start);
            }
        } else if (this.isFragmented) {
            // Append the mfra box to the end of the file for better random access
            const startPos = this.writer.getPos();
            const mfraBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mfra"])(this.trackDatas);
            this.boxWriter.writeBox(mfraBox);
            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size
            const mfraBoxSize = this.writer.getPos() - startPos;
            this.writer.seek(this.writer.getPos() - 4);
            this.boxWriter.writeU32(mfraBoxSize);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.mdat);
            const mdatPos = this.boxWriter.offsets.get(this.mdat);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(mdatPos !== undefined);
            const mdatSize = this.writer.getPos() - mdatPos;
            this.mdat.size = mdatSize;
            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it
            this.boxWriter.patchBox(this.mdat);
            if (this.format._options.onMdat) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onMdat(data, start);
            }
            const movieBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moov"])(this);
            if (this.fastStart === 'reserve') {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.ftypSize !== null);
                this.writer.seek(this.ftypSize);
                if (this.format._options.onMoov) {
                    this.writer.startTrackingWrites();
                }
                this.boxWriter.writeBox(movieBox);
                // Fill the remaining space with a free box. If there are less than 8 bytes left, sucks I guess
                const remainingSpace = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();
                this.boxWriter.writeBox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$isobmff$2f$isobmff$2d$boxes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["free"])(remainingSpace));
            } else {
                if (this.format._options.onMoov) {
                    this.writer.startTrackingWrites();
                }
                this.boxWriter.writeBox(movieBox);
            }
            if (this.format._options.onMoov) {
                const { data, start } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(data, start);
            }
        }
        release();
    }
}
}),
];

//# sourceMappingURL=node_modules_mediabunny_dist_modules_src_isobmff_13b8761c._.js.map