{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AACM,MAAM,uBAAuB,CAAC;IACjC,MAAM,OAAO,KAAK,QAAQ,GACpB,WACA,KAAK,QAAQ,GACT,WACA;IACV,IAAI,SAAS,OAAO,CAAC,KAAK,WAAW,GAAG,cAAc,KAAK;IAC3D,IAAI,KAAK,YAAY,CAAC,MAAM,GAAG,GAAG;QAC9B,MAAM,uBAAuB;eAAI,IAAI,IAAI,KAAK,YAAY;SAAE;QAC5D,UAAU,CAAC,UAAU,EAAE,qBAAqB,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { RichImageData } from '../metadata.js';\nimport { textDecoder } from '../misc.js';\nimport { readAscii, readBytes, readI32Be, readU16Be, readU32Be, readU64Be, readU8 } from '../reader.js';\nexport const MIN_BOX_HEADER_SIZE = 8;\nexport const MAX_BOX_HEADER_SIZE = 16;\nexport const readBoxHeader = (slice) => {\n    let totalSize = readU32Be(slice);\n    const name = readAscii(slice, 4);\n    let headerSize = 8;\n    const hasLargeSize = totalSize === 1;\n    if (hasLargeSize) {\n        totalSize = readU64Be(slice);\n        headerSize = 16;\n    }\n    const contentSize = totalSize - headerSize;\n    if (contentSize < 0) {\n        return null; // Hardly a box is it\n    }\n    return { name, totalSize, headerSize, contentSize };\n};\nexport const readFixed_16_16 = (slice) => {\n    return readI32Be(slice) / 0x10000;\n};\nexport const readFixed_2_30 = (slice) => {\n    return readI32Be(slice) / 0x40000000;\n};\nexport const readIsomVariableInteger = (slice) => {\n    let result = 0;\n    for (let i = 0; i < 4; i++) {\n        result <<= 7;\n        const nextByte = readU8(slice);\n        result |= nextByte & 0x7f;\n        if ((nextByte & 0x80) === 0) {\n            break;\n        }\n    }\n    return result;\n};\nexport const readMetadataStringShort = (slice) => {\n    let stringLength = readU16Be(slice);\n    slice.skip(2); // Language\n    stringLength = Math.min(stringLength, slice.remainingLength);\n    return textDecoder.decode(readBytes(slice, stringLength));\n};\nexport const readDataBox = (slice) => {\n    const header = readBoxHeader(slice);\n    if (!header || header.name !== 'data') {\n        return null;\n    }\n    if (slice.remainingLength < 8) {\n        // Box is too small\n        return null;\n    }\n    const typeIndicator = readU32Be(slice);\n    slice.skip(4); // Locale indicator\n    const data = readBytes(slice, header.contentSize - 8);\n    switch (typeIndicator) {\n        case 1: return textDecoder.decode(data); // UTF-8\n        case 2: return new TextDecoder('utf-16be').decode(data); // UTF-16-BE\n        case 13: return new RichImageData(data, 'image/jpeg');\n        case 14: return new RichImageData(data, 'image/png');\n        case 27: return new RichImageData(data, 'image/bmp');\n        default: return data;\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;;;;;;;;;AACD;AACA;AACA;;;;AACO,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;AAC5B,MAAM,gBAAgB,CAAC;IAC1B,IAAI,YAAY,IAAA,6KAAS,EAAC;IAC1B,MAAM,OAAO,IAAA,6KAAS,EAAC,OAAO;IAC9B,IAAI,aAAa;IACjB,MAAM,eAAe,cAAc;IACnC,IAAI,cAAc;QACd,YAAY,IAAA,6KAAS,EAAC;QACtB,aAAa;IACjB;IACA,MAAM,cAAc,YAAY;IAChC,IAAI,cAAc,GAAG;QACjB,OAAO,MAAM,qBAAqB;IACtC;IACA,OAAO;QAAE;QAAM;QAAW;QAAY;IAAY;AACtD;AACO,MAAM,kBAAkB,CAAC;IAC5B,OAAO,IAAA,6KAAS,EAAC,SAAS;AAC9B;AACO,MAAM,iBAAiB,CAAC;IAC3B,OAAO,IAAA,6KAAS,EAAC,SAAS;AAC9B;AACO,MAAM,0BAA0B,CAAC;IACpC,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QACxB,WAAW;QACX,MAAM,WAAW,IAAA,0KAAM,EAAC;QACxB,UAAU,WAAW;QACrB,IAAI,CAAC,WAAW,IAAI,MAAM,GAAG;YACzB;QACJ;IACJ;IACA,OAAO;AACX;AACO,MAAM,0BAA0B,CAAC;IACpC,IAAI,eAAe,IAAA,6KAAS,EAAC;IAC7B,MAAM,IAAI,CAAC,IAAI,WAAW;IAC1B,eAAe,KAAK,GAAG,CAAC,cAAc,MAAM,eAAe;IAC3D,OAAO,6KAAW,CAAC,MAAM,CAAC,IAAA,6KAAS,EAAC,OAAO;AAC/C;AACO,MAAM,cAAc,CAAC;IACxB,MAAM,SAAS,cAAc;IAC7B,IAAI,CAAC,UAAU,OAAO,IAAI,KAAK,QAAQ;QACnC,OAAO;IACX;IACA,IAAI,MAAM,eAAe,GAAG,GAAG;QAC3B,mBAAmB;QACnB,OAAO;IACX;IACA,MAAM,gBAAgB,IAAA,6KAAS,EAAC;IAChC,MAAM,IAAI,CAAC,IAAI,mBAAmB;IAClC,MAAM,OAAO,IAAA,6KAAS,EAAC,OAAO,OAAO,WAAW,GAAG;IACnD,OAAQ;QACJ,KAAK;YAAG,OAAO,6KAAW,CAAC,MAAM,CAAC,OAAO,QAAQ;QACjD,KAAK;YAAG,OAAO,IAAI,YAAY,YAAY,MAAM,CAAC,OAAO,YAAY;QACrE,KAAK;YAAI,OAAO,IAAI,mLAAa,CAAC,MAAM;QACxC,KAAK;YAAI,OAAO,IAAI,mLAAa,CAAC,MAAM;QACxC,KAAK;YAAI,OAAO,IAAI,mLAAa,CAAC,MAAM;QACxC;YAAS,OAAO;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAudioCodecString, extractVideoCodecString, OPUS_SAMPLE_RATE, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { extractAv1CodecInfoFromPacket, extractVp9CodecInfoFromPacket, FlacBlockType, } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { assert, binarySearchExact, binarySearchLessOrEqual, Bitstream, COLOR_PRIMARIES_MAP_INVERSE, findLastIndex, isIso639Dash2LanguageCode, last, MATRIX_COEFFICIENTS_MAP_INVERSE, normalizeRotation, roundToMultiple, textDecoder, TRANSFER_CHARACTERISTICS_MAP_INVERSE, UNDETERMINED_LANGUAGE, toDataView, roundIfAlmostInteger, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE, readBoxHeader, readDataBox, readFixed_16_16, readFixed_2_30, readIsomVariableInteger, readMetadataStringShort, } from './isobmff-reader.js';\nimport { readBytes, readF64Be, readI16Be, readI32Be, readI64Be, readU16Be, readU24Be, readU32Be, readU64Be, readU8, readAscii, } from '../reader.js';\nimport { DEFAULT_TRACK_DISPOSITION, RichImageData } from '../metadata.js';\nexport class IsobmffDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.moovSlice = null;\n        this.currentTrack = null;\n        this.tracks = [];\n        this.metadataPromise = null;\n        this.movieTimescale = -1;\n        this.movieDurationInTimescale = -1;\n        this.isQuickTime = false;\n        this.metadataTags = {};\n        this.currentMetadataKeys = null;\n        this.isFragmented = false;\n        this.fragmentTrackDefaults = [];\n        this.currentFragment = null;\n        /**\n         * Caches the last fragment that was read. Based on the assumption that there will be multiple reads to the\n         * same fragment in quick succession.\n         */\n        this.lastReadFragment = null;\n        this.reader = input._reader;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks.map(track => track.inputTrack);\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const codecStrings = await Promise.all(this.tracks.map(x => x.inputTrack.getCodecParameterString()));\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.tracks.some(x => x.info?.type === 'video'),\n            hasAudio: this.tracks.some(x => x.info?.type === 'audio'),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n    readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            let currentPos = 0;\n            while (true) {\n                let slice = this.reader.requestSliceRange(currentPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const startPos = currentPos;\n                const boxInfo = readBoxHeader(slice);\n                if (!boxInfo) {\n                    break;\n                }\n                if (boxInfo.name === 'ftyp') {\n                    const majorBrand = readAscii(slice, 4);\n                    this.isQuickTime = majorBrand === 'qt  ';\n                }\n                else if (boxInfo.name === 'moov') {\n                    // Found moov, load it\n                    let moovSlice = this.reader.requestSlice(slice.filePos, boxInfo.contentSize);\n                    if (moovSlice instanceof Promise)\n                        moovSlice = await moovSlice;\n                    if (!moovSlice)\n                        break;\n                    this.moovSlice = moovSlice;\n                    this.readContiguousBoxes(this.moovSlice);\n                    // Put default tracks first\n                    this.tracks.sort((a, b) => Number(b.disposition.default) - Number(a.disposition.default));\n                    for (const track of this.tracks) {\n                        // Modify the edit list offset based on the previous segment durations. They are in different\n                        // timescales, so we first convert to seconds and then into the track timescale.\n                        const previousSegmentDurationsInSeconds = track.editListPreviousSegmentDurations / this.movieTimescale;\n                        track.editListOffset -= Math.round(previousSegmentDurationsInSeconds * track.timescale);\n                    }\n                    break;\n                }\n                currentPos = startPos + boxInfo.totalSize;\n            }\n            if (this.isFragmented && this.reader.fileSize !== null) {\n                // The last 4 bytes may contain the size of the mfra box at the end of the file\n                let lastWordSlice = this.reader.requestSlice(this.reader.fileSize - 4, 4);\n                if (lastWordSlice instanceof Promise)\n                    lastWordSlice = await lastWordSlice;\n                assert(lastWordSlice);\n                const lastWord = readU32Be(lastWordSlice);\n                const potentialMfraPos = this.reader.fileSize - lastWord;\n                if (potentialMfraPos >= 0 && potentialMfraPos <= this.reader.fileSize - MAX_BOX_HEADER_SIZE) {\n                    let mfraHeaderSlice = this.reader.requestSliceRange(potentialMfraPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n                    if (mfraHeaderSlice instanceof Promise)\n                        mfraHeaderSlice = await mfraHeaderSlice;\n                    if (mfraHeaderSlice) {\n                        const boxInfo = readBoxHeader(mfraHeaderSlice);\n                        if (boxInfo && boxInfo.name === 'mfra') {\n                            // We found the mfra box, allowing for much better random access. Let's parse it.\n                            let mfraSlice = this.reader.requestSlice(mfraHeaderSlice.filePos, boxInfo.contentSize);\n                            if (mfraSlice instanceof Promise)\n                                mfraSlice = await mfraSlice;\n                            if (mfraSlice) {\n                                this.readContiguousBoxes(mfraSlice);\n                            }\n                        }\n                    }\n                }\n            }\n        })();\n    }\n    getSampleTableForTrack(internalTrack) {\n        if (internalTrack.sampleTable) {\n            return internalTrack.sampleTable;\n        }\n        const sampleTable = {\n            sampleTimingEntries: [],\n            sampleCompositionTimeOffsets: [],\n            sampleSizes: [],\n            keySampleIndices: null,\n            chunkOffsets: [],\n            sampleToChunk: [],\n            presentationTimestamps: null,\n            presentationTimestampIndexMap: null,\n        };\n        internalTrack.sampleTable = sampleTable;\n        assert(this.moovSlice);\n        const stblContainerSlice = this.moovSlice.slice(internalTrack.sampleTableByteOffset);\n        this.currentTrack = internalTrack;\n        this.traverseBox(stblContainerSlice);\n        this.currentTrack = null;\n        const isPcmCodec = internalTrack.info?.type === 'audio'\n            && internalTrack.info.codec\n            && PCM_AUDIO_CODECS.includes(internalTrack.info.codec);\n        if (isPcmCodec && sampleTable.sampleCompositionTimeOffsets.length === 0) {\n            // If the audio has PCM samples, the way the samples are defined in the sample table is somewhat\n            // suboptimal: Each individual audio sample is its own sample, meaning we can have 48000 samples per second.\n            // Because we treat each sample as its own atomic unit that can be decoded, this would lead to a huge\n            // amount of very short samples for PCM audio. So instead, we make a transformation: If the audio is in PCM,\n            // we say that each chunk (that normally holds many samples) now is one big sample. We can this because\n            // the samples in the chunk are contiguous and the format is PCM, so the entire chunk as one thing still\n            // encodes valid audio information.\n            assert(internalTrack.info?.type === 'audio');\n            const pcmInfo = parsePcmCodec(internalTrack.info.codec);\n            const newSampleTimingEntries = [];\n            const newSampleSizes = [];\n            for (let i = 0; i < sampleTable.sampleToChunk.length; i++) {\n                const chunkEntry = sampleTable.sampleToChunk[i];\n                const nextEntry = sampleTable.sampleToChunk[i + 1];\n                const chunkCount = (nextEntry ? nextEntry.startChunkIndex : sampleTable.chunkOffsets.length)\n                    - chunkEntry.startChunkIndex;\n                for (let j = 0; j < chunkCount; j++) {\n                    const startSampleIndex = chunkEntry.startSampleIndex + j * chunkEntry.samplesPerChunk;\n                    const endSampleIndex = startSampleIndex + chunkEntry.samplesPerChunk; // Exclusive, outside of chunk\n                    const startTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, startSampleIndex, x => x.startIndex);\n                    const startTimingEntry = sampleTable.sampleTimingEntries[startTimingEntryIndex];\n                    const endTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, endSampleIndex, x => x.startIndex);\n                    const endTimingEntry = sampleTable.sampleTimingEntries[endTimingEntryIndex];\n                    const firstSampleTimestamp = startTimingEntry.startDecodeTimestamp\n                        + (startSampleIndex - startTimingEntry.startIndex) * startTimingEntry.delta;\n                    const lastSampleTimestamp = endTimingEntry.startDecodeTimestamp\n                        + (endSampleIndex - endTimingEntry.startIndex) * endTimingEntry.delta;\n                    const delta = lastSampleTimestamp - firstSampleTimestamp;\n                    const lastSampleTimingEntry = last(newSampleTimingEntries);\n                    if (lastSampleTimingEntry && lastSampleTimingEntry.delta === delta) {\n                        lastSampleTimingEntry.count++;\n                    }\n                    else {\n                        // One sample for the entire chunk\n                        newSampleTimingEntries.push({\n                            startIndex: chunkEntry.startChunkIndex + j,\n                            startDecodeTimestamp: firstSampleTimestamp,\n                            count: 1,\n                            delta,\n                        });\n                    }\n                    // Instead of determining the chunk's size by looping over the samples sizes in the sample table, we\n                    // can directly compute it as we know how many PCM frames are in this chunk, and the size of each\n                    // PCM frame. This also improves compatibility with some files which fail to write proper sample\n                    // size values into their sample tables in the PCM case.\n                    const chunkSize = chunkEntry.samplesPerChunk\n                        * pcmInfo.sampleSize\n                        * internalTrack.info.numberOfChannels;\n                    newSampleSizes.push(chunkSize);\n                }\n                chunkEntry.startSampleIndex = chunkEntry.startChunkIndex;\n                chunkEntry.samplesPerChunk = 1;\n            }\n            sampleTable.sampleTimingEntries = newSampleTimingEntries;\n            sampleTable.sampleSizes = newSampleSizes;\n        }\n        if (sampleTable.sampleCompositionTimeOffsets.length > 0) {\n            // If composition time offsets are defined, we must build a list of all presentation timestamps and then\n            // sort them\n            sampleTable.presentationTimestamps = [];\n            for (const entry of sampleTable.sampleTimingEntries) {\n                for (let i = 0; i < entry.count; i++) {\n                    sampleTable.presentationTimestamps.push({\n                        presentationTimestamp: entry.startDecodeTimestamp + i * entry.delta,\n                        sampleIndex: entry.startIndex + i,\n                    });\n                }\n            }\n            for (const entry of sampleTable.sampleCompositionTimeOffsets) {\n                for (let i = 0; i < entry.count; i++) {\n                    const sampleIndex = entry.startIndex + i;\n                    const sample = sampleTable.presentationTimestamps[sampleIndex];\n                    if (!sample) {\n                        continue;\n                    }\n                    sample.presentationTimestamp += entry.offset;\n                }\n            }\n            sampleTable.presentationTimestamps.sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n            sampleTable.presentationTimestampIndexMap = Array(sampleTable.presentationTimestamps.length).fill(-1);\n            for (let i = 0; i < sampleTable.presentationTimestamps.length; i++) {\n                sampleTable.presentationTimestampIndexMap[sampleTable.presentationTimestamps[i].sampleIndex] = i;\n            }\n        }\n        else {\n            // If they're not defined, we can simply use the decode timestamps as presentation timestamps\n        }\n        return sampleTable;\n    }\n    async readFragment(startPos) {\n        if (this.lastReadFragment?.moofOffset === startPos) {\n            return this.lastReadFragment;\n        }\n        let headerSlice = this.reader.requestSliceRange(startPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n        if (headerSlice instanceof Promise)\n            headerSlice = await headerSlice;\n        assert(headerSlice);\n        const moofBoxInfo = readBoxHeader(headerSlice);\n        assert(moofBoxInfo?.name === 'moof');\n        let entireSlice = this.reader.requestSlice(startPos, moofBoxInfo.totalSize);\n        if (entireSlice instanceof Promise)\n            entireSlice = await entireSlice;\n        assert(entireSlice);\n        this.traverseBox(entireSlice);\n        const fragment = this.lastReadFragment;\n        assert(fragment && fragment.moofOffset === startPos);\n        for (const [, trackData] of fragment.trackData) {\n            const track = trackData.track;\n            const { fragmentPositionCache } = track;\n            if (!trackData.startTimestampIsFinal) {\n                // It may be that some tracks don't define the base decode time, i.e. when the fragment begins. This\n                // we'll need to figure out the start timestamp another way. We'll compute the timestamp by accessing\n                // the lookup entries and fragment cache, which works out nicely with the lookup algorithm: If these\n                // exist, then the lookup will automatically start at the furthest possible point. If they don't, the\n                // lookup starts sequentially from the start, incrementally summing up all fragment durations. It's sort\n                // of implicit, but it ends up working nicely.\n                const lookupEntry = track.fragmentLookupTable.find(x => x.moofOffset === fragment.moofOffset);\n                if (lookupEntry) {\n                    // There's a lookup entry, let's use its timestamp\n                    offsetFragmentTrackDataByTimestamp(trackData, lookupEntry.timestamp);\n                }\n                else {\n                    const lastCacheIndex = binarySearchLessOrEqual(fragmentPositionCache, fragment.moofOffset - 1, x => x.moofOffset);\n                    if (lastCacheIndex !== -1) {\n                        // Let's use the timestamp of the previous fragment in the cache\n                        const lastCache = fragmentPositionCache[lastCacheIndex];\n                        offsetFragmentTrackDataByTimestamp(trackData, lastCache.endTimestamp);\n                    }\n                    else {\n                        // We're the first fragment I guess, \"offset by 0\"\n                    }\n                }\n                trackData.startTimestampIsFinal = true;\n            }\n            // Let's remember that a fragment with a given timestamp is here, speeding up future lookups if no\n            // lookup table exists\n            const insertionIndex = binarySearchLessOrEqual(fragmentPositionCache, trackData.startTimestamp, x => x.startTimestamp);\n            if (insertionIndex === -1\n                || fragmentPositionCache[insertionIndex].moofOffset !== fragment.moofOffset) {\n                fragmentPositionCache.splice(insertionIndex + 1, 0, {\n                    moofOffset: fragment.moofOffset,\n                    startTimestamp: trackData.startTimestamp,\n                    endTimestamp: trackData.endTimestamp,\n                });\n            }\n        }\n        return fragment;\n    }\n    readContiguousBoxes(slice) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_BOX_HEADER_SIZE) {\n            const foundBox = this.traverseBox(slice);\n            if (!foundBox) {\n                break;\n            }\n        }\n    }\n    // eslint-disable-next-line @stylistic/generator-star-spacing\n    *iterateContiguousBoxes(slice) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_BOX_HEADER_SIZE) {\n            const startPos = slice.filePos;\n            const boxInfo = readBoxHeader(slice);\n            if (!boxInfo) {\n                break;\n            }\n            yield { boxInfo, slice };\n            slice.filePos = startPos + boxInfo.totalSize;\n        }\n    }\n    traverseBox(slice) {\n        const startPos = slice.filePos;\n        const boxInfo = readBoxHeader(slice);\n        if (!boxInfo) {\n            return false;\n        }\n        const contentStartPos = slice.filePos;\n        const boxEndPos = startPos + boxInfo.totalSize;\n        switch (boxInfo.name) {\n            case 'mdia':\n            case 'minf':\n            case 'dinf':\n            case 'mfra':\n            case 'edts':\n                {\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'mvhd':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    if (version === 1) {\n                        slice.skip(8 + 8);\n                        this.movieTimescale = readU32Be(slice);\n                        this.movieDurationInTimescale = readU64Be(slice);\n                    }\n                    else {\n                        slice.skip(4 + 4);\n                        this.movieTimescale = readU32Be(slice);\n                        this.movieDurationInTimescale = readU32Be(slice);\n                    }\n                }\n                ;\n                break;\n            case 'trak':\n                {\n                    const track = {\n                        id: -1,\n                        demuxer: this,\n                        inputTrack: null,\n                        disposition: {\n                            ...DEFAULT_TRACK_DISPOSITION,\n                        },\n                        info: null,\n                        timescale: -1,\n                        durationInMovieTimescale: -1,\n                        durationInMediaTimescale: -1,\n                        rotation: 0,\n                        internalCodecId: null,\n                        name: null,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        sampleTableByteOffset: -1,\n                        sampleTable: null,\n                        fragmentLookupTable: [],\n                        currentFragmentState: null,\n                        fragmentPositionCache: [],\n                        editListPreviousSegmentDurations: 0,\n                        editListOffset: 0,\n                    };\n                    this.currentTrack = track;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    if (track.id !== -1 && track.timescale !== -1 && track.info !== null) {\n                        if (track.info.type === 'video' && track.info.width !== -1) {\n                            const videoTrack = track;\n                            track.inputTrack = new InputVideoTrack(this.input, new IsobmffVideoTrackBacking(videoTrack));\n                            this.tracks.push(track);\n                        }\n                        else if (track.info.type === 'audio' && track.info.numberOfChannels !== -1) {\n                            const audioTrack = track;\n                            track.inputTrack = new InputAudioTrack(this.input, new IsobmffAudioTrackBacking(audioTrack));\n                            this.tracks.push(track);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case 'tkhd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    const flags = readU24Be(slice);\n                    // Spec says disabled tracks are to be treated like they don't exist, but in practice, they are treated\n                    // more like non-default tracks.\n                    const trackEnabled = !!(flags & 0x1);\n                    track.disposition.default = trackEnabled;\n                    // Skip over creation & modification time to reach the track ID\n                    if (version === 0) {\n                        slice.skip(8);\n                        track.id = readU32Be(slice);\n                        slice.skip(4);\n                        track.durationInMovieTimescale = readU32Be(slice);\n                    }\n                    else if (version === 1) {\n                        slice.skip(16);\n                        track.id = readU32Be(slice);\n                        slice.skip(4);\n                        track.durationInMovieTimescale = readU64Be(slice);\n                    }\n                    else {\n                        throw new Error(`Incorrect track header version ${version}.`);\n                    }\n                    slice.skip(2 * 4 + 2 + 2 + 2 + 2);\n                    const matrix = [\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                    ];\n                    const rotation = normalizeRotation(roundToMultiple(extractRotationFromMatrix(matrix), 90));\n                    assert(rotation === 0 || rotation === 90 || rotation === 180 || rotation === 270);\n                    track.rotation = rotation;\n                }\n                ;\n                break;\n            case 'elst':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    let relevantEntryFound = false;\n                    let previousSegmentDurations = 0;\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const segmentDuration = version === 1\n                            ? readU64Be(slice)\n                            : readU32Be(slice);\n                        const mediaTime = version === 1\n                            ? readI64Be(slice)\n                            : readI32Be(slice);\n                        const mediaRate = readFixed_16_16(slice);\n                        if (segmentDuration === 0) {\n                            // Don't care\n                            continue;\n                        }\n                        if (relevantEntryFound) {\n                            console.warn('Unsupported edit list: multiple edits are not currently supported. Only using first edit.');\n                            break;\n                        }\n                        if (mediaTime === -1) {\n                            previousSegmentDurations += segmentDuration;\n                            continue;\n                        }\n                        if (mediaRate !== 1) {\n                            console.warn('Unsupported edit list entry: media rate must be 1.');\n                            break;\n                        }\n                        track.editListPreviousSegmentDurations = previousSegmentDurations;\n                        track.editListOffset = mediaTime;\n                        relevantEntryFound = true;\n                    }\n                }\n                ;\n                break;\n            case 'mdhd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    if (version === 0) {\n                        slice.skip(8);\n                        track.timescale = readU32Be(slice);\n                        track.durationInMediaTimescale = readU32Be(slice);\n                    }\n                    else if (version === 1) {\n                        slice.skip(16);\n                        track.timescale = readU32Be(slice);\n                        track.durationInMediaTimescale = readU64Be(slice);\n                    }\n                    let language = readU16Be(slice);\n                    if (language > 0) {\n                        track.languageCode = '';\n                        for (let i = 0; i < 3; i++) {\n                            track.languageCode = String.fromCharCode(0x60 + (language & 0b11111)) + track.languageCode;\n                            language >>= 5;\n                        }\n                        if (!isIso639Dash2LanguageCode(track.languageCode)) {\n                            // Sometimes the bytes are garbage\n                            track.languageCode = UNDETERMINED_LANGUAGE;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'hdlr':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    slice.skip(8); // Version + flags + pre-defined\n                    const handlerType = readAscii(slice, 4);\n                    if (handlerType === 'vide') {\n                        track.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                            avcType: null,\n                            avcCodecInfo: null,\n                            hevcCodecInfo: null,\n                            vp9CodecInfo: null,\n                            av1CodecInfo: null,\n                        };\n                    }\n                    else if (handlerType === 'soun') {\n                        track.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case 'stbl':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    track.sampleTableByteOffset = startPos;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'stsd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (track.info === null || track.sampleTable) {\n                        break;\n                    }\n                    const stsdVersion = readU8(slice);\n                    slice.skip(3); // Flags\n                    const entries = readU32Be(slice);\n                    for (let i = 0; i < entries; i++) {\n                        const sampleBoxStartPos = slice.filePos;\n                        const sampleBoxInfo = readBoxHeader(slice);\n                        if (!sampleBoxInfo) {\n                            break;\n                        }\n                        track.internalCodecId = sampleBoxInfo.name;\n                        const lowercaseBoxName = sampleBoxInfo.name.toLowerCase();\n                        if (track.info.type === 'video') {\n                            if (lowercaseBoxName === 'avc1' || lowercaseBoxName === 'avc3') {\n                                track.info.codec = 'avc';\n                                track.info.avcType = lowercaseBoxName === 'avc1' ? 1 : 3;\n                            }\n                            else if (lowercaseBoxName === 'hvc1' || lowercaseBoxName === 'hev1') {\n                                track.info.codec = 'hevc';\n                            }\n                            else if (lowercaseBoxName === 'vp08') {\n                                track.info.codec = 'vp8';\n                            }\n                            else if (lowercaseBoxName === 'vp09') {\n                                track.info.codec = 'vp9';\n                            }\n                            else if (lowercaseBoxName === 'av01') {\n                                track.info.codec = 'av1';\n                            }\n                            else {\n                                console.warn(`Unsupported video codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            slice.skip(6 * 1 + 2 + 2 + 2 + 3 * 4);\n                            track.info.width = readU16Be(slice);\n                            track.info.height = readU16Be(slice);\n                            slice.skip(4 + 4 + 4 + 2 + 32 + 2 + 2);\n                            this.readContiguousBoxes(slice.slice(slice.filePos, (sampleBoxStartPos + sampleBoxInfo.totalSize) - slice.filePos));\n                        }\n                        else {\n                            if (lowercaseBoxName === 'mp4a') {\n                                // We don't know the codec yet (might be AAC, might be MP3), need to read the esds box\n                            }\n                            else if (lowercaseBoxName === 'opus') {\n                                track.info.codec = 'opus';\n                            }\n                            else if (lowercaseBoxName === 'flac') {\n                                track.info.codec = 'flac';\n                            }\n                            else if (lowercaseBoxName === 'twos'\n                                || lowercaseBoxName === 'sowt'\n                                || lowercaseBoxName === 'raw '\n                                || lowercaseBoxName === 'in24'\n                                || lowercaseBoxName === 'in32'\n                                || lowercaseBoxName === 'fl32'\n                                || lowercaseBoxName === 'fl64'\n                                || lowercaseBoxName === 'lpcm'\n                                || lowercaseBoxName === 'ipcm' // ISO/IEC 23003-5\n                                || lowercaseBoxName === 'fpcm' // \"\n                            ) {\n                                // It's PCM\n                                // developer.apple.com/documentation/quicktime-file-format/sound_sample_descriptions/\n                            }\n                            else if (lowercaseBoxName === 'ulaw') {\n                                track.info.codec = 'ulaw';\n                            }\n                            else if (lowercaseBoxName === 'alaw') {\n                                track.info.codec = 'alaw';\n                            }\n                            else {\n                                console.warn(`Unsupported audio codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            slice.skip(6 * 1 + 2);\n                            const version = readU16Be(slice);\n                            slice.skip(3 * 2);\n                            let channelCount = readU16Be(slice);\n                            let sampleSize = readU16Be(slice);\n                            slice.skip(2 * 2);\n                            // Can't use fixed16_16 as that's signed\n                            let sampleRate = readU32Be(slice) / 0x10000;\n                            if (stsdVersion === 0 && version > 0) {\n                                // Additional QuickTime fields\n                                if (version === 1) {\n                                    slice.skip(4);\n                                    sampleSize = 8 * readU32Be(slice);\n                                    slice.skip(2 * 4);\n                                }\n                                else if (version === 2) {\n                                    slice.skip(4);\n                                    sampleRate = readF64Be(slice);\n                                    channelCount = readU32Be(slice);\n                                    slice.skip(4); // Always 0x7f000000\n                                    sampleSize = readU32Be(slice);\n                                    const flags = readU32Be(slice);\n                                    slice.skip(2 * 4);\n                                    if (lowercaseBoxName === 'lpcm') {\n                                        const bytesPerSample = (sampleSize + 7) >> 3;\n                                        const isFloat = Boolean(flags & 1);\n                                        const isBigEndian = Boolean(flags & 2);\n                                        const sFlags = flags & 4 ? -1 : 0; // I guess it means \"signed flags\" or something?\n                                        if (sampleSize > 0 && sampleSize <= 64) {\n                                            if (isFloat) {\n                                                if (sampleSize === 32) {\n                                                    track.info.codec = isBigEndian ? 'pcm-f32be' : 'pcm-f32';\n                                                }\n                                            }\n                                            else {\n                                                if (sFlags & (1 << (bytesPerSample - 1))) {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-s8';\n                                                    }\n                                                    else if (bytesPerSample === 2) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s16be' : 'pcm-s16';\n                                                    }\n                                                    else if (bytesPerSample === 3) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s24be' : 'pcm-s24';\n                                                    }\n                                                    else if (bytesPerSample === 4) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s32be' : 'pcm-s32';\n                                                    }\n                                                }\n                                                else {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-u8';\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (track.info.codec === null) {\n                                            console.warn('Unsupported PCM format.');\n                                        }\n                                    }\n                                }\n                            }\n                            if (track.info.codec === 'opus') {\n                                sampleRate = OPUS_SAMPLE_RATE; // Always the same\n                            }\n                            track.info.numberOfChannels = channelCount;\n                            track.info.sampleRate = sampleRate;\n                            // PCM codec assignments\n                            if (lowercaseBoxName === 'twos') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16be';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'twos'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'sowt') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'sowt'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'raw ') {\n                                track.info.codec = 'pcm-u8';\n                            }\n                            else if (lowercaseBoxName === 'in24') {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (lowercaseBoxName === 'in32') {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else if (lowercaseBoxName === 'fl32') {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (lowercaseBoxName === 'fl64') {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else if (lowercaseBoxName === 'ipcm') {\n                                track.info.codec = 'pcm-s16be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            else if (lowercaseBoxName === 'fpcm') {\n                                track.info.codec = 'pcm-f32be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            this.readContiguousBoxes(slice.slice(slice.filePos, (sampleBoxStartPos + sampleBoxInfo.totalSize) - slice.filePos));\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'avcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info);\n                    track.info.codecDescription = readBytes(slice, boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'hvcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info);\n                    track.info.codecDescription = readBytes(slice, boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'vpcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    slice.skip(4); // Version + flags\n                    const profile = readU8(slice);\n                    const level = readU8(slice);\n                    const thirdByte = readU8(slice);\n                    const bitDepth = thirdByte >> 4;\n                    const chromaSubsampling = (thirdByte >> 1) & 0b111;\n                    const videoFullRangeFlag = thirdByte & 1;\n                    const colourPrimaries = readU8(slice);\n                    const transferCharacteristics = readU8(slice);\n                    const matrixCoefficients = readU8(slice);\n                    track.info.vp9CodecInfo = {\n                        profile,\n                        level,\n                        bitDepth,\n                        chromaSubsampling,\n                        videoFullRangeFlag,\n                        colourPrimaries,\n                        transferCharacteristics,\n                        matrixCoefficients,\n                    };\n                }\n                ;\n                break;\n            case 'av1C':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    slice.skip(1); // Marker + version\n                    const secondByte = readU8(slice);\n                    const profile = secondByte >> 5;\n                    const level = secondByte & 0b11111;\n                    const thirdByte = readU8(slice);\n                    const tier = thirdByte >> 7;\n                    const highBitDepth = (thirdByte >> 6) & 1;\n                    const twelveBit = (thirdByte >> 5) & 1;\n                    const monochrome = (thirdByte >> 4) & 1;\n                    const chromaSubsamplingX = (thirdByte >> 3) & 1;\n                    const chromaSubsamplingY = (thirdByte >> 2) & 1;\n                    const chromaSamplePosition = thirdByte & 0b11;\n                    // Logic from https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n                    const bitDepth = profile === 2 && highBitDepth ? (twelveBit ? 12 : 10) : (highBitDepth ? 10 : 8);\n                    track.info.av1CodecInfo = {\n                        profile,\n                        level,\n                        tier,\n                        bitDepth,\n                        monochrome,\n                        chromaSubsamplingX,\n                        chromaSubsamplingY,\n                        chromaSamplePosition,\n                    };\n                }\n                ;\n                break;\n            case 'colr':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    const colourType = readAscii(slice, 4);\n                    if (colourType !== 'nclx') {\n                        break;\n                    }\n                    const colourPrimaries = readU16Be(slice);\n                    const transferCharacteristics = readU16Be(slice);\n                    const matrixCoefficients = readU16Be(slice);\n                    const fullRangeFlag = Boolean(readU8(slice) & 0x80);\n                    track.info.colorSpace = {\n                        primaries: COLOR_PRIMARIES_MAP_INVERSE[colourPrimaries],\n                        transfer: TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics],\n                        matrix: MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients],\n                        fullRange: fullRangeFlag,\n                    };\n                }\n                ;\n                break;\n            case 'wave':\n                {\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'esds':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(4); // Version + flags\n                    const tag = readU8(slice);\n                    assert(tag === 0x03); // ES Descriptor\n                    readIsomVariableInteger(slice); // Length\n                    slice.skip(2); // ES ID\n                    const mixed = readU8(slice);\n                    const streamDependenceFlag = (mixed & 0x80) !== 0;\n                    const urlFlag = (mixed & 0x40) !== 0;\n                    const ocrStreamFlag = (mixed & 0x20) !== 0;\n                    if (streamDependenceFlag) {\n                        slice.skip(2);\n                    }\n                    if (urlFlag) {\n                        const urlLength = readU8(slice);\n                        slice.skip(urlLength);\n                    }\n                    if (ocrStreamFlag) {\n                        slice.skip(2);\n                    }\n                    const decoderConfigTag = readU8(slice);\n                    assert(decoderConfigTag === 0x04); // DecoderConfigDescriptor\n                    const decoderConfigDescriptorLength = readIsomVariableInteger(slice); // Length\n                    const payloadStart = slice.filePos;\n                    const objectTypeIndication = readU8(slice);\n                    if (objectTypeIndication === 0x40 || objectTypeIndication === 0x67) {\n                        track.info.codec = 'aac';\n                        track.info.aacCodecInfo = { isMpeg2: objectTypeIndication === 0x67 };\n                    }\n                    else if (objectTypeIndication === 0x69 || objectTypeIndication === 0x6b) {\n                        track.info.codec = 'mp3';\n                    }\n                    else if (objectTypeIndication === 0xdd) {\n                        track.info.codec = 'vorbis'; // \"nonstandard, gpac uses it\" - FFmpeg\n                    }\n                    else {\n                        console.warn(`Unsupported audio codec (objectTypeIndication ${objectTypeIndication}) - discarding track.`);\n                    }\n                    slice.skip(1 + 3 + 4 + 4);\n                    if (decoderConfigDescriptorLength > slice.filePos - payloadStart) {\n                        // There's a DecoderSpecificInfo at the end, let's read it\n                        const decoderSpecificInfoTag = readU8(slice);\n                        assert(decoderSpecificInfoTag === 0x05); // DecoderSpecificInfo\n                        const decoderSpecificInfoLength = readIsomVariableInteger(slice);\n                        track.info.codecDescription = readBytes(slice, decoderSpecificInfoLength);\n                        if (track.info.codec === 'aac') {\n                            // Let's try to deduce more accurate values directly from the AudioSpecificConfig:\n                            const audioSpecificConfig = parseAacAudioSpecificConfig(track.info.codecDescription);\n                            if (audioSpecificConfig.numberOfChannels !== null) {\n                                track.info.numberOfChannels = audioSpecificConfig.numberOfChannels;\n                            }\n                            if (audioSpecificConfig.sampleRate !== null) {\n                                track.info.sampleRate = audioSpecificConfig.sampleRate;\n                            }\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'enda':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    const littleEndian = readU16Be(slice) & 0xff; // 0xff is from FFmpeg\n                    if (littleEndian) {\n                        if (track.info.codec === 'pcm-s16be') {\n                            track.info.codec = 'pcm-s16';\n                        }\n                        else if (track.info.codec === 'pcm-s24be') {\n                            track.info.codec = 'pcm-s24';\n                        }\n                        else if (track.info.codec === 'pcm-s32be') {\n                            track.info.codec = 'pcm-s32';\n                        }\n                        else if (track.info.codec === 'pcm-f32be') {\n                            track.info.codec = 'pcm-f32';\n                        }\n                        else if (track.info.codec === 'pcm-f64be') {\n                            track.info.codec = 'pcm-f64';\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'pcmC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(1 + 3); // Version + flags\n                    // ISO/IEC 23003-5\n                    const formatFlags = readU8(slice);\n                    const isLittleEndian = Boolean(formatFlags & 0x01);\n                    const pcmSampleSize = readU8(slice);\n                    if (track.info.codec === 'pcm-s16be') {\n                        // ipcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16be';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    else if (track.info.codec === 'pcm-f32be') {\n                        // fpcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    break;\n                }\n                ;\n            case 'dOps':\n                { // Used for Opus audio\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(1); // Version\n                    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n                    const outputChannelCount = readU8(slice);\n                    const preSkip = readU16Be(slice);\n                    const inputSampleRate = readU32Be(slice);\n                    const outputGain = readI16Be(slice);\n                    const channelMappingFamily = readU8(slice);\n                    let channelMappingTable;\n                    if (channelMappingFamily !== 0) {\n                        channelMappingTable = readBytes(slice, 2 + outputChannelCount);\n                    }\n                    else {\n                        channelMappingTable = new Uint8Array(0);\n                    }\n                    // https://datatracker.ietf.org/doc/html/draft-ietf-codec-oggopus-06\n                    const description = new Uint8Array(8 + 1 + 1 + 2 + 4 + 2 + 1 + channelMappingTable.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x4f707573, false); // 'Opus'\n                    view.setUint32(4, 0x48656164, false); // 'Head'\n                    view.setUint8(8, 1); // Version\n                    view.setUint8(9, outputChannelCount);\n                    view.setUint16(10, preSkip, true);\n                    view.setUint32(12, inputSampleRate, true);\n                    view.setInt16(16, outputGain, true);\n                    view.setUint8(18, channelMappingFamily);\n                    description.set(channelMappingTable, 19);\n                    track.info.codecDescription = description;\n                    track.info.numberOfChannels = outputChannelCount;\n                    // Don't copy the input sample rate, irrelevant, and output sample rate is fixed\n                }\n                ;\n                break;\n            case 'dfLa':\n                { // Used for FLAC audio\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(4); // Version + flags\n                    // https://datatracker.ietf.org/doc/rfc9639/\n                    const BLOCK_TYPE_MASK = 0x7f;\n                    const LAST_METADATA_BLOCK_FLAG_MASK = 0x80;\n                    const startPos = slice.filePos;\n                    while (slice.filePos < boxEndPos) {\n                        const flagAndType = readU8(slice);\n                        const metadataBlockLength = readU24Be(slice);\n                        const type = flagAndType & BLOCK_TYPE_MASK;\n                        // It's a STREAMINFO block; let's extract the actual sample rate and channel count\n                        if (type === FlacBlockType.STREAMINFO) {\n                            slice.skip(10);\n                            // Extract sample rate and channel count\n                            const word = readU32Be(slice);\n                            const sampleRate = word >>> 12;\n                            const numberOfChannels = ((word >> 9) & 0b111) + 1;\n                            track.info.sampleRate = sampleRate;\n                            track.info.numberOfChannels = numberOfChannels;\n                            slice.skip(20);\n                        }\n                        else {\n                            // Simply skip ahead to the next block\n                            slice.skip(metadataBlockLength);\n                        }\n                        if (flagAndType & LAST_METADATA_BLOCK_FLAG_MASK) {\n                            break;\n                        }\n                    }\n                    const endPos = slice.filePos;\n                    slice.filePos = startPos;\n                    const bytes = readBytes(slice, endPos - startPos);\n                    const description = new Uint8Array(4 + bytes.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x664c6143, false); // 'fLaC'\n                    description.set(bytes, 4);\n                    // Set the codec description to be 'fLaC' + all metadata blocks\n                    track.info.codecDescription = description;\n                }\n                ;\n                break;\n            case 'stts':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    let currentIndex = 0;\n                    let currentTimestamp = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = readU32Be(slice);\n                        const sampleDelta = readU32Be(slice);\n                        track.sampleTable.sampleTimingEntries.push({\n                            startIndex: currentIndex,\n                            startDecodeTimestamp: currentTimestamp,\n                            count: sampleCount,\n                            delta: sampleDelta,\n                        });\n                        currentIndex += sampleCount;\n                        currentTimestamp += sampleCount * sampleDelta;\n                    }\n                }\n                ;\n                break;\n            case 'ctts':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(1 + 3); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    let sampleIndex = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = readU32Be(slice);\n                        const sampleOffset = readI32Be(slice);\n                        track.sampleTable.sampleCompositionTimeOffsets.push({\n                            startIndex: sampleIndex,\n                            count: sampleCount,\n                            offset: sampleOffset,\n                        });\n                        sampleIndex += sampleCount;\n                    }\n                }\n                ;\n                break;\n            case 'stsz':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const sampleSize = readU32Be(slice);\n                    const sampleCount = readU32Be(slice);\n                    if (sampleSize === 0) {\n                        for (let i = 0; i < sampleCount; i++) {\n                            const sampleSize = readU32Be(slice);\n                            track.sampleTable.sampleSizes.push(sampleSize);\n                        }\n                    }\n                    else {\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stz2':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    slice.skip(3); // Reserved\n                    const fieldSize = readU8(slice); // in bits\n                    const sampleCount = readU32Be(slice);\n                    const bytes = readBytes(slice, Math.ceil(sampleCount * fieldSize / 8));\n                    const bitstream = new Bitstream(bytes);\n                    for (let i = 0; i < sampleCount; i++) {\n                        const sampleSize = bitstream.readBits(fieldSize);\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stss':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    track.sampleTable.keySampleIndices = [];\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleIndex = readU32Be(slice) - 1; // Convert to 0-indexed\n                        track.sampleTable.keySampleIndices.push(sampleIndex);\n                    }\n                    if (track.sampleTable.keySampleIndices[0] !== 0) {\n                        // Some files don't mark the first sample a key sample, which is basically almost always incorrect.\n                        // Here, we correct for that mistake:\n                        track.sampleTable.keySampleIndices.unshift(0);\n                    }\n                }\n                ;\n                break;\n            case 'stsc':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4);\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const startChunkIndex = readU32Be(slice) - 1; // Convert to 0-indexed\n                        const samplesPerChunk = readU32Be(slice);\n                        const sampleDescriptionIndex = readU32Be(slice);\n                        track.sampleTable.sampleToChunk.push({\n                            startSampleIndex: -1,\n                            startChunkIndex,\n                            samplesPerChunk,\n                            sampleDescriptionIndex,\n                        });\n                    }\n                    let startSampleIndex = 0;\n                    for (let i = 0; i < track.sampleTable.sampleToChunk.length; i++) {\n                        track.sampleTable.sampleToChunk[i].startSampleIndex = startSampleIndex;\n                        if (i < track.sampleTable.sampleToChunk.length - 1) {\n                            const nextChunk = track.sampleTable.sampleToChunk[i + 1];\n                            const chunkCount = nextChunk.startChunkIndex\n                                - track.sampleTable.sampleToChunk[i].startChunkIndex;\n                            startSampleIndex += chunkCount * track.sampleTable.sampleToChunk[i].samplesPerChunk;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'stco':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = readU32Be(slice);\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'co64':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = readU64Be(slice);\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'mvex':\n                {\n                    this.isFragmented = true;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'mehd':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const fragmentDuration = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                    this.movieDurationInTimescale = fragmentDuration;\n                }\n                ;\n                break;\n            case 'trex':\n                {\n                    slice.skip(4); // Version + flags\n                    const trackId = readU32Be(slice);\n                    const defaultSampleDescriptionIndex = readU32Be(slice);\n                    const defaultSampleDuration = readU32Be(slice);\n                    const defaultSampleSize = readU32Be(slice);\n                    const defaultSampleFlags = readU32Be(slice);\n                    // We store these separately rather than in the tracks since the tracks may not exist yet\n                    this.fragmentTrackDefaults.push({\n                        trackId,\n                        defaultSampleDescriptionIndex,\n                        defaultSampleDuration,\n                        defaultSampleSize,\n                        defaultSampleFlags,\n                    });\n                }\n                ;\n                break;\n            case 'tfra':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const trackId = readU32Be(slice);\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        break;\n                    }\n                    const word = readU32Be(slice);\n                    const lengthSizeOfTrafNum = (word & 0b110000) >> 4;\n                    const lengthSizeOfTrunNum = (word & 0b001100) >> 2;\n                    const lengthSizeOfSampleNum = word & 0b000011;\n                    const functions = [readU8, readU16Be, readU24Be, readU32Be];\n                    const readTrafNum = functions[lengthSizeOfTrafNum];\n                    const readTrunNum = functions[lengthSizeOfTrunNum];\n                    const readSampleNum = functions[lengthSizeOfSampleNum];\n                    const numberOfEntries = readU32Be(slice);\n                    for (let i = 0; i < numberOfEntries; i++) {\n                        const time = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                        const moofOffset = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                        readTrafNum(slice);\n                        readTrunNum(slice);\n                        readSampleNum(slice);\n                        track.fragmentLookupTable.push({\n                            timestamp: time,\n                            moofOffset,\n                        });\n                    }\n                    // Sort by timestamp in case it's not naturally sorted\n                    track.fragmentLookupTable.sort((a, b) => a.timestamp - b.timestamp);\n                    // Remove multiple entries for the same time\n                    for (let i = 0; i < track.fragmentLookupTable.length - 1; i++) {\n                        const entry1 = track.fragmentLookupTable[i];\n                        const entry2 = track.fragmentLookupTable[i + 1];\n                        if (entry1.timestamp === entry2.timestamp) {\n                            track.fragmentLookupTable.splice(i + 1, 1);\n                            i--;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'moof':\n                {\n                    this.currentFragment = {\n                        moofOffset: startPos,\n                        moofSize: boxInfo.totalSize,\n                        implicitBaseDataOffset: startPos,\n                        trackData: new Map(),\n                    };\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    this.lastReadFragment = this.currentFragment;\n                    this.currentFragment = null;\n                }\n                ;\n                break;\n            case 'traf':\n                {\n                    assert(this.currentFragment);\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    // It is possible that there is no current track, for example when we don't care about the track\n                    // referenced in the track fragment header.\n                    if (this.currentTrack) {\n                        const trackData = this.currentFragment.trackData.get(this.currentTrack.id);\n                        if (trackData) {\n                            const { currentFragmentState } = this.currentTrack;\n                            assert(currentFragmentState);\n                            if (currentFragmentState.startTimestamp !== null) {\n                                offsetFragmentTrackDataByTimestamp(trackData, currentFragmentState.startTimestamp);\n                                trackData.startTimestampIsFinal = true;\n                            }\n                        }\n                        this.currentTrack.currentFragmentState = null;\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case 'tfhd':\n                {\n                    assert(this.currentFragment);\n                    slice.skip(1); // Version\n                    const flags = readU24Be(slice);\n                    const baseDataOffsetPresent = Boolean(flags & 0x000001);\n                    const sampleDescriptionIndexPresent = Boolean(flags & 0x000002);\n                    const defaultSampleDurationPresent = Boolean(flags & 0x000008);\n                    const defaultSampleSizePresent = Boolean(flags & 0x000010);\n                    const defaultSampleFlagsPresent = Boolean(flags & 0x000020);\n                    const durationIsEmpty = Boolean(flags & 0x010000);\n                    const defaultBaseIsMoof = Boolean(flags & 0x020000);\n                    const trackId = readU32Be(slice);\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        // We don't care about this track\n                        break;\n                    }\n                    const defaults = this.fragmentTrackDefaults.find(x => x.trackId === trackId);\n                    this.currentTrack = track;\n                    track.currentFragmentState = {\n                        baseDataOffset: this.currentFragment.implicitBaseDataOffset,\n                        sampleDescriptionIndex: defaults?.defaultSampleDescriptionIndex ?? null,\n                        defaultSampleDuration: defaults?.defaultSampleDuration ?? null,\n                        defaultSampleSize: defaults?.defaultSampleSize ?? null,\n                        defaultSampleFlags: defaults?.defaultSampleFlags ?? null,\n                        startTimestamp: null,\n                    };\n                    if (baseDataOffsetPresent) {\n                        track.currentFragmentState.baseDataOffset = readU64Be(slice);\n                    }\n                    else if (defaultBaseIsMoof) {\n                        track.currentFragmentState.baseDataOffset = this.currentFragment.moofOffset;\n                    }\n                    if (sampleDescriptionIndexPresent) {\n                        track.currentFragmentState.sampleDescriptionIndex = readU32Be(slice);\n                    }\n                    if (defaultSampleDurationPresent) {\n                        track.currentFragmentState.defaultSampleDuration = readU32Be(slice);\n                    }\n                    if (defaultSampleSizePresent) {\n                        track.currentFragmentState.defaultSampleSize = readU32Be(slice);\n                    }\n                    if (defaultSampleFlagsPresent) {\n                        track.currentFragmentState.defaultSampleFlags = readU32Be(slice);\n                    }\n                    if (durationIsEmpty) {\n                        track.currentFragmentState.defaultSampleDuration = 0;\n                    }\n                }\n                ;\n                break;\n            case 'tfdt':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.currentFragmentState);\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const baseMediaDecodeTime = version === 0 ? readU32Be(slice) : readU64Be(slice);\n                    track.currentFragmentState.startTimestamp = baseMediaDecodeTime;\n                }\n                ;\n                break;\n            case 'trun':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(this.currentFragment);\n                    assert(track.currentFragmentState);\n                    if (this.currentFragment.trackData.has(track.id)) {\n                        console.warn('Can\\'t have two trun boxes for the same track in one fragment. Ignoring...');\n                        break;\n                    }\n                    const version = readU8(slice);\n                    const flags = readU24Be(slice);\n                    const dataOffsetPresent = Boolean(flags & 0x000001);\n                    const firstSampleFlagsPresent = Boolean(flags & 0x000004);\n                    const sampleDurationPresent = Boolean(flags & 0x000100);\n                    const sampleSizePresent = Boolean(flags & 0x000200);\n                    const sampleFlagsPresent = Boolean(flags & 0x000400);\n                    const sampleCompositionTimeOffsetsPresent = Boolean(flags & 0x000800);\n                    const sampleCount = readU32Be(slice);\n                    let dataOffset = track.currentFragmentState.baseDataOffset;\n                    if (dataOffsetPresent) {\n                        dataOffset += readI32Be(slice);\n                    }\n                    let firstSampleFlags = null;\n                    if (firstSampleFlagsPresent) {\n                        firstSampleFlags = readU32Be(slice);\n                    }\n                    let currentOffset = dataOffset;\n                    if (sampleCount === 0) {\n                        // Don't associate the fragment with the track if it has no samples, this simplifies other code\n                        this.currentFragment.implicitBaseDataOffset = currentOffset;\n                        break;\n                    }\n                    let currentTimestamp = 0;\n                    const trackData = {\n                        track,\n                        startTimestamp: 0,\n                        endTimestamp: 0,\n                        firstKeyFrameTimestamp: null,\n                        samples: [],\n                        presentationTimestamps: [],\n                        startTimestampIsFinal: false,\n                    };\n                    this.currentFragment.trackData.set(track.id, trackData);\n                    for (let i = 0; i < sampleCount; i++) {\n                        let sampleDuration;\n                        if (sampleDurationPresent) {\n                            sampleDuration = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleDuration !== null);\n                            sampleDuration = track.currentFragmentState.defaultSampleDuration;\n                        }\n                        let sampleSize;\n                        if (sampleSizePresent) {\n                            sampleSize = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleSize !== null);\n                            sampleSize = track.currentFragmentState.defaultSampleSize;\n                        }\n                        let sampleFlags;\n                        if (sampleFlagsPresent) {\n                            sampleFlags = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleFlags !== null);\n                            sampleFlags = track.currentFragmentState.defaultSampleFlags;\n                        }\n                        if (i === 0 && firstSampleFlags !== null) {\n                            sampleFlags = firstSampleFlags;\n                        }\n                        let sampleCompositionTimeOffset = 0;\n                        if (sampleCompositionTimeOffsetsPresent) {\n                            if (version === 0) {\n                                sampleCompositionTimeOffset = readU32Be(slice);\n                            }\n                            else {\n                                sampleCompositionTimeOffset = readI32Be(slice);\n                            }\n                        }\n                        const isKeyFrame = !(sampleFlags & 0x00010000);\n                        trackData.samples.push({\n                            presentationTimestamp: currentTimestamp + sampleCompositionTimeOffset,\n                            duration: sampleDuration,\n                            byteOffset: currentOffset,\n                            byteSize: sampleSize,\n                            isKeyFrame,\n                        });\n                        currentOffset += sampleSize;\n                        currentTimestamp += sampleDuration;\n                    }\n                    trackData.presentationTimestamps = trackData.samples\n                        .map((x, i) => ({ presentationTimestamp: x.presentationTimestamp, sampleIndex: i }))\n                        .sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n                    for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                        const currentEntry = trackData.presentationTimestamps[i];\n                        const currentSample = trackData.samples[currentEntry.sampleIndex];\n                        if (trackData.firstKeyFrameTimestamp === null && currentSample.isKeyFrame) {\n                            trackData.firstKeyFrameTimestamp = currentSample.presentationTimestamp;\n                        }\n                        if (i < trackData.presentationTimestamps.length - 1) {\n                            // Update sample durations based on presentation order\n                            const nextEntry = trackData.presentationTimestamps[i + 1];\n                            currentSample.duration = nextEntry.presentationTimestamp - currentEntry.presentationTimestamp;\n                        }\n                    }\n                    const firstSample = trackData.samples[trackData.presentationTimestamps[0].sampleIndex];\n                    const lastSample = trackData.samples[last(trackData.presentationTimestamps).sampleIndex];\n                    trackData.startTimestamp = firstSample.presentationTimestamp;\n                    trackData.endTimestamp = lastSample.presentationTimestamp + lastSample.duration;\n                    this.currentFragment.implicitBaseDataOffset = currentOffset;\n                }\n                ;\n                break;\n            // Metadata section\n            // https://exiftool.org/TagNames/QuickTime.html\n            // https://mp4workshop.com/about\n            case 'udta':\n                { // Contains either movie metadata or track metadata\n                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    for (const { boxInfo, slice } of iterator) {\n                        if (boxInfo.name !== 'meta' && !this.currentTrack) {\n                            const startPos = slice.filePos;\n                            this.metadataTags.raw ??= {};\n                            if (boxInfo.name[0] === '') {\n                                // https://mp4workshop.com/about\n                                // Box name starting with  indicates \"international text\"\n                                this.metadataTags.raw[boxInfo.name] ??= readMetadataStringShort(slice);\n                            }\n                            else {\n                                this.metadataTags.raw[boxInfo.name] ??= readBytes(slice, boxInfo.contentSize);\n                            }\n                            slice.filePos = startPos;\n                        }\n                        switch (boxInfo.name) {\n                            case 'meta':\n                                {\n                                    slice.skip(-boxInfo.headerSize);\n                                    this.traverseBox(slice);\n                                }\n                                ;\n                                break;\n                            case 'nam':\n                            case 'name':\n                                {\n                                    if (this.currentTrack) {\n                                        this.currentTrack.name = textDecoder.decode(readBytes(slice, boxInfo.contentSize));\n                                    }\n                                    else {\n                                        this.metadataTags.title ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'des':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.description ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'ART':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.artist ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'alb':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.album ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'albr':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.albumArtist ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'gen':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.genre ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'day':\n                                {\n                                    if (!this.currentTrack) {\n                                        const date = new Date(readMetadataStringShort(slice));\n                                        if (!Number.isNaN(date.getTime())) {\n                                            this.metadataTags.date ??= date;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'cmt':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.comment ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'lyr':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.lyrics ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'meta':\n                {\n                    if (this.currentTrack) {\n                        break; // Only care about movie-level metadata for now\n                    }\n                    // The 'meta' box comes in two flavors, one with flags/version and one without. To know which is which,\n                    // let's read the next 4 bytes, which are either the version or the size of the first subbox.\n                    const word = readU32Be(slice);\n                    const isQuickTime = word !== 0;\n                    this.currentMetadataKeys = new Map();\n                    if (isQuickTime) {\n                        this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    }\n                    else {\n                        this.readContiguousBoxes(slice.slice(contentStartPos + 4, boxInfo.contentSize - 4));\n                    }\n                    this.currentMetadataKeys = null;\n                }\n                ;\n                break;\n            case 'keys':\n                {\n                    if (!this.currentMetadataKeys) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const keySize = readU32Be(slice);\n                        slice.skip(4); // Key namespace\n                        const keyName = textDecoder.decode(readBytes(slice, keySize - 8));\n                        this.currentMetadataKeys.set(i + 1, keyName);\n                    }\n                }\n                ;\n                break;\n            case 'ilst':\n                {\n                    if (!this.currentMetadataKeys) {\n                        break;\n                    }\n                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    for (const { boxInfo, slice } of iterator) {\n                        let metadataKey = boxInfo.name;\n                        // Interpret the box name as a u32be\n                        const nameAsNumber = (metadataKey.charCodeAt(0) << 24)\n                            + (metadataKey.charCodeAt(1) << 16)\n                            + (metadataKey.charCodeAt(2) << 8)\n                            + metadataKey.charCodeAt(3);\n                        if (this.currentMetadataKeys.has(nameAsNumber)) {\n                            // An entry exists for this number\n                            metadataKey = this.currentMetadataKeys.get(nameAsNumber);\n                        }\n                        const data = readDataBox(slice);\n                        this.metadataTags.raw ??= {};\n                        this.metadataTags.raw[metadataKey] ??= data;\n                        switch (metadataKey) {\n                            case 'nam':\n                            case 'titl':\n                            case 'com.apple.quicktime.title':\n                            case 'title':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.title ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'des':\n                            case 'desc':\n                            case 'dscp':\n                            case 'com.apple.quicktime.description':\n                            case 'description':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.description ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'ART':\n                            case 'com.apple.quicktime.artist':\n                            case 'artist':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.artist ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'alb':\n                            case 'albm':\n                            case 'com.apple.quicktime.album':\n                            case 'album':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.album ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'aART':\n                            case 'album_artist':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.albumArtist ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'cmt':\n                            case 'com.apple.quicktime.comment':\n                            case 'comment':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.comment ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'gen':\n                            case 'gnre':\n                            case 'com.apple.quicktime.genre':\n                            case 'genre':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.genre ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'lyr':\n                            case 'lyrics':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.lyrics ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'day':\n                            case 'rldt':\n                            case 'com.apple.quicktime.creationdate':\n                            case 'date':\n                                {\n                                    if (typeof data === 'string') {\n                                        const date = new Date(data);\n                                        if (!Number.isNaN(date.getTime())) {\n                                            this.metadataTags.date ??= date;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'covr':\n                            case 'com.apple.quicktime.artwork':\n                                {\n                                    if (data instanceof RichImageData) {\n                                        this.metadataTags.images ??= [];\n                                        this.metadataTags.images.push({\n                                            data: data.data,\n                                            kind: 'coverFront',\n                                            mimeType: data.mimeType,\n                                        });\n                                    }\n                                    else if (data instanceof Uint8Array) {\n                                        this.metadataTags.images ??= [];\n                                        this.metadataTags.images.push({\n                                            data,\n                                            kind: 'coverFront',\n                                            mimeType: 'image/*',\n                                        });\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'track':\n                                {\n                                    if (typeof data === 'string') {\n                                        const parts = data.split('/');\n                                        const trackNum = Number.parseInt(parts[0], 10);\n                                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                                            this.metadataTags.trackNumber ??= trackNum;\n                                        }\n                                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                                            this.metadataTags.tracksTotal ??= tracksTotal;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'trkn':\n                                {\n                                    if (data instanceof Uint8Array && data.length >= 6) {\n                                        const view = toDataView(data);\n                                        const trackNumber = view.getUint16(2, false);\n                                        const tracksTotal = view.getUint16(4, false);\n                                        if (trackNumber > 0) {\n                                            this.metadataTags.trackNumber ??= trackNumber;\n                                        }\n                                        if (tracksTotal > 0) {\n                                            this.metadataTags.tracksTotal ??= tracksTotal;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'disc':\n                            case 'disk':\n                                {\n                                    if (data instanceof Uint8Array && data.length >= 6) {\n                                        const view = toDataView(data);\n                                        const discNumber = view.getUint16(2, false);\n                                        const discNumberMax = view.getUint16(4, false);\n                                        if (discNumber > 0) {\n                                            this.metadataTags.discNumber ??= discNumber;\n                                        }\n                                        if (discNumberMax > 0) {\n                                            this.metadataTags.discsTotal ??= discNumberMax;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                        }\n                    }\n                }\n                ;\n                break;\n        }\n        slice.filePos = boxEndPos;\n        return true;\n    }\n}\nclass IsobmffTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToSampleIndex = new WeakMap();\n        this.packetToFragmentLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    getInternalCodecId() {\n        return this.internalTrack.internalCodecId;\n    }\n    getName() {\n        return this.internalTrack.name;\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    getTimeResolution() {\n        return this.internalTrack.timescale;\n    }\n    getDisposition() {\n        return this.internalTrack.disposition;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    async getFirstPacket(options) {\n        const regularPacket = await this.fetchPacketForSampleIndex(0, options);\n        if (regularPacket || !this.internalTrack.demuxer.isFragmented) {\n            // If there's a non-fragmented packet, always prefer that\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (trackData) {\n                return {\n                    sampleIndex: 0,\n                    correctSampleFound: true,\n                };\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    mapTimestampIntoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundIfAlmostInteger(timestamp * this.internalTrack.timescale) + this.internalTrack.editListOffset;\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { sampleIndex: -1, correctSampleFound: false };\n            }\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.presentationTimestamp);\n            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;\n            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { sampleIndex, correctSampleFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            return this.fetchPacketForSampleIndex(regularSampleIndex + 1, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performFragmentedLookup(locationInFragment.fragment, (fragment) => {\n            if (fragment === locationInFragment.fragment) {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (locationInFragment.sampleIndex + 1 < trackData.samples.length) {\n                    // We can simply take the next sample in the fragment\n                    return {\n                        sampleIndex: locationInFragment.sampleIndex + 1,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (trackData) {\n                    return {\n                        sampleIndex: 0,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getKeyframeSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { sampleIndex: -1, correctSampleFound: false };\n            }\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const sample = trackData.samples[x.sampleIndex];\n                return sample.isKeyFrame && x.presentationTimestamp <= timestampInTimescale;\n            });\n            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;\n            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { sampleIndex, correctSampleFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n            const nextKeyFrameSampleIndex = getNextKeyframeIndexForSample(sampleTable, regularSampleIndex);\n            return this.fetchPacketForSampleIndex(nextKeyFrameSampleIndex, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performFragmentedLookup(locationInFragment.fragment, (fragment) => {\n            if (fragment === locationInFragment.fragment) {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                const nextKeyFrameIndex = trackData.samples.findIndex((x, i) => x.isKeyFrame && i > locationInFragment.sampleIndex);\n                if (nextKeyFrameIndex !== -1) {\n                    // We can simply take the next key frame in the fragment\n                    return {\n                        sampleIndex: nextKeyFrameIndex,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                    const keyFrameIndex = trackData.samples.findIndex(x => x.isKeyFrame);\n                    assert(keyFrameIndex !== -1); // There must be one\n                    return {\n                        sampleIndex: keyFrameIndex,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async fetchPacketForSampleIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleInfo = getSampleInfo(sampleTable, sampleIndex);\n        if (!sampleInfo) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.internalTrack.demuxer.reader.requestSlice(sampleInfo.sampleOffset, sampleInfo.sampleSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            data = readBytes(slice, sampleInfo.sampleSize);\n        }\n        const timestamp = (sampleInfo.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = sampleInfo.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, sampleInfo.isKeyFrame ? 'key' : 'delta', timestamp, duration, sampleIndex, sampleInfo.sampleSize);\n        this.packetToSampleIndex.set(packet, sampleIndex);\n        return packet;\n    }\n    async fetchPacketInFragment(fragment, sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const trackData = fragment.trackData.get(this.internalTrack.id);\n        const fragmentSample = trackData.samples[sampleIndex];\n        assert(fragmentSample);\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.internalTrack.demuxer.reader.requestSlice(fragmentSample.byteOffset, fragmentSample.byteSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            data = readBytes(slice, fragmentSample.byteSize);\n        }\n        const timestamp = (fragmentSample.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = fragmentSample.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, fragmentSample.isKeyFrame ? 'key' : 'delta', timestamp, duration, fragment.moofOffset + sampleIndex, fragmentSample.byteSize);\n        this.packetToFragmentLocation.set(packet, { fragment, sampleIndex });\n        return packet;\n    }\n    /** Looks for a packet in the fragments while trying to load as few fragments as possible to retrieve it. */\n    async performFragmentedLookup(\n    // The fragment where we start looking\n    startFragment, \n    // This function returns the best-matching sample in a given fragment\n    getMatchInFragment, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct sample will not come after it\n    latestTimestamp, options) {\n        const demuxer = this.internalTrack.demuxer;\n        let currentFragment = null;\n        let bestFragment = null;\n        let bestSampleIndex = -1;\n        if (startFragment) {\n            const { sampleIndex, correctSampleFound } = getMatchInFragment(startFragment);\n            if (correctSampleFound) {\n                return this.fetchPacketInFragment(startFragment, sampleIndex, options);\n            }\n            if (sampleIndex !== -1) {\n                bestFragment = startFragment;\n                bestSampleIndex = sampleIndex;\n            }\n        }\n        // Search for a lookup entry; this way, we won't need to start searching from the start of the file\n        // but can jump right into the correct fragment (or at least nearby).\n        const lookupEntryIndex = binarySearchLessOrEqual(this.internalTrack.fragmentLookupTable, searchTimestamp, x => x.timestamp);\n        const lookupEntry = lookupEntryIndex !== -1\n            ? this.internalTrack.fragmentLookupTable[lookupEntryIndex]\n            : null;\n        const positionCacheIndex = binarySearchLessOrEqual(this.internalTrack.fragmentPositionCache, searchTimestamp, x => x.startTimestamp);\n        const positionCacheEntry = positionCacheIndex !== -1\n            ? this.internalTrack.fragmentPositionCache[positionCacheIndex]\n            : null;\n        const lookupEntryPosition = Math.max(lookupEntry?.moofOffset ?? 0, positionCacheEntry?.moofOffset ?? 0) || null;\n        let currentPos;\n        if (!startFragment) {\n            currentPos = lookupEntryPosition ?? 0;\n        }\n        else {\n            if (lookupEntryPosition === null || startFragment.moofOffset >= lookupEntryPosition) {\n                currentPos = startFragment.moofOffset + startFragment.moofSize;\n                currentFragment = startFragment;\n            }\n            else {\n                // Use the lookup entry\n                currentPos = lookupEntryPosition;\n            }\n        }\n        while (true) {\n            if (currentFragment) {\n                const trackData = currentFragment.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.startTimestamp > latestTimestamp) {\n                    // We're already past the upper bound, no need to keep searching\n                    break;\n                }\n            }\n            // Load the header\n            let slice = demuxer.reader.requestSliceRange(currentPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const boxStartPos = currentPos;\n            const boxInfo = readBoxHeader(slice);\n            if (!boxInfo) {\n                break;\n            }\n            if (boxInfo.name === 'moof') {\n                currentFragment = await demuxer.readFragment(boxStartPos);\n                const { sampleIndex, correctSampleFound } = getMatchInFragment(currentFragment);\n                if (correctSampleFound) {\n                    return this.fetchPacketInFragment(currentFragment, sampleIndex, options);\n                }\n                if (sampleIndex !== -1) {\n                    bestFragment = currentFragment;\n                    bestSampleIndex = sampleIndex;\n                }\n            }\n            currentPos = boxStartPos + boxInfo.totalSize;\n        }\n        // Catch faulty lookup table entries\n        if (lookupEntry && (!bestFragment || bestFragment.moofOffset < lookupEntry.moofOffset)) {\n            // The lookup table entry lied to us! We found a lookup entry but no fragment there that satisfied\n            // the match. In this case, let's search again but using the lookup entry before that.\n            const previousLookupEntry = this.internalTrack.fragmentLookupTable[lookupEntryIndex - 1];\n            assert(!previousLookupEntry || previousLookupEntry.timestamp < lookupEntry.timestamp);\n            const newSearchTimestamp = previousLookupEntry?.timestamp ?? -Infinity;\n            return this.performFragmentedLookup(null, getMatchInFragment, newSearchTimestamp, latestTimestamp, options);\n        }\n        if (bestFragment) {\n            // If we finished looping but didn't find a perfect match, still return the best match we found\n            return this.fetchPacketInFragment(bestFragment, bestSampleIndex, options);\n        }\n        return null;\n    }\n}\nclass IsobmffVideoTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async canBeTransparent() {\n        return false;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            if (this.internalTrack.info.codec === 'vp9' && !this.internalTrack.info.vp9CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.vp9CodecInfo = firstPacket && extractVp9CodecInfoFromPacket(firstPacket.data);\n            }\n            else if (this.internalTrack.info.codec === 'av1' && !this.internalTrack.info.av1CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.av1CodecInfo = firstPacket && extractAv1CodecInfoFromPacket(firstPacket.data);\n            }\n            return {\n                codec: extractVideoCodecString(this.internalTrack.info),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass IsobmffAudioTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString(this.internalTrack.info),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\nconst getSampleIndexForTimestamp = (sampleTable, timescaleUnits) => {\n    if (sampleTable.presentationTimestamps) {\n        const index = binarySearchLessOrEqual(sampleTable.presentationTimestamps, timescaleUnits, x => x.presentationTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        return sampleTable.presentationTimestamps[index].sampleIndex;\n    }\n    else {\n        const index = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, timescaleUnits, x => x.startDecodeTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        const entry = sampleTable.sampleTimingEntries[index];\n        return entry.startIndex\n            + Math.min(Math.floor((timescaleUnits - entry.startDecodeTimestamp) / entry.delta), entry.count - 1);\n    }\n};\nconst getKeyframeSampleIndexForTimestamp = (sampleTable, timescaleUnits) => {\n    if (!sampleTable.keySampleIndices) {\n        // Every sample is a keyframe\n        return getSampleIndexForTimestamp(sampleTable, timescaleUnits);\n    }\n    if (sampleTable.presentationTimestamps) {\n        const index = binarySearchLessOrEqual(sampleTable.presentationTimestamps, timescaleUnits, x => x.presentationTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        // Walk the samples in presentation order until we find one that's a keyframe\n        for (let i = index; i >= 0; i--) {\n            const sampleIndex = sampleTable.presentationTimestamps[i].sampleIndex;\n            const isKeyFrame = binarySearchExact(sampleTable.keySampleIndices, sampleIndex, x => x) !== -1;\n            if (isKeyFrame) {\n                return sampleIndex;\n            }\n        }\n        return -1;\n    }\n    else {\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timescaleUnits);\n        const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n        return sampleTable.keySampleIndices[index] ?? -1;\n    }\n};\nconst getSampleInfo = (sampleTable, sampleIndex) => {\n    const timingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, sampleIndex, x => x.startIndex);\n    const timingEntry = sampleTable.sampleTimingEntries[timingEntryIndex];\n    if (!timingEntry || timingEntry.startIndex + timingEntry.count <= sampleIndex) {\n        return null;\n    }\n    const decodeTimestamp = timingEntry.startDecodeTimestamp\n        + (sampleIndex - timingEntry.startIndex) * timingEntry.delta;\n    let presentationTimestamp = decodeTimestamp;\n    const offsetEntryIndex = binarySearchLessOrEqual(sampleTable.sampleCompositionTimeOffsets, sampleIndex, x => x.startIndex);\n    const offsetEntry = sampleTable.sampleCompositionTimeOffsets[offsetEntryIndex];\n    if (offsetEntry && sampleIndex - offsetEntry.startIndex < offsetEntry.count) {\n        presentationTimestamp += offsetEntry.offset;\n    }\n    const sampleSize = sampleTable.sampleSizes[Math.min(sampleIndex, sampleTable.sampleSizes.length - 1)];\n    const chunkEntryIndex = binarySearchLessOrEqual(sampleTable.sampleToChunk, sampleIndex, x => x.startSampleIndex);\n    const chunkEntry = sampleTable.sampleToChunk[chunkEntryIndex];\n    assert(chunkEntry);\n    const chunkIndex = chunkEntry.startChunkIndex\n        + Math.floor((sampleIndex - chunkEntry.startSampleIndex) / chunkEntry.samplesPerChunk);\n    const chunkOffset = sampleTable.chunkOffsets[chunkIndex];\n    const startSampleIndexOfChunk = chunkEntry.startSampleIndex\n        + (chunkIndex - chunkEntry.startChunkIndex) * chunkEntry.samplesPerChunk;\n    let chunkSize = 0;\n    let sampleOffset = chunkOffset;\n    if (sampleTable.sampleSizes.length === 1) {\n        sampleOffset += sampleSize * (sampleIndex - startSampleIndexOfChunk);\n        chunkSize += sampleSize * chunkEntry.samplesPerChunk;\n    }\n    else {\n        for (let i = startSampleIndexOfChunk; i < startSampleIndexOfChunk + chunkEntry.samplesPerChunk; i++) {\n            const sampleSize = sampleTable.sampleSizes[i];\n            if (i < sampleIndex) {\n                sampleOffset += sampleSize;\n            }\n            chunkSize += sampleSize;\n        }\n    }\n    let duration = timingEntry.delta;\n    if (sampleTable.presentationTimestamps) {\n        // In order to accurately compute the duration, we need to take the duration to the next sample in presentation\n        // order, not in decode order\n        const presentationIndex = sampleTable.presentationTimestampIndexMap[sampleIndex];\n        assert(presentationIndex !== undefined);\n        if (presentationIndex < sampleTable.presentationTimestamps.length - 1) {\n            const nextEntry = sampleTable.presentationTimestamps[presentationIndex + 1];\n            const nextPresentationTimestamp = nextEntry.presentationTimestamp;\n            duration = nextPresentationTimestamp - presentationTimestamp;\n        }\n    }\n    return {\n        presentationTimestamp,\n        duration,\n        sampleOffset,\n        sampleSize,\n        chunkOffset,\n        chunkSize,\n        isKeyFrame: sampleTable.keySampleIndices\n            ? binarySearchExact(sampleTable.keySampleIndices, sampleIndex, x => x) !== -1\n            : true,\n    };\n};\nconst getNextKeyframeIndexForSample = (sampleTable, sampleIndex) => {\n    if (!sampleTable.keySampleIndices) {\n        return sampleIndex + 1;\n    }\n    const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n    return sampleTable.keySampleIndices[index + 1] ?? -1;\n};\nconst offsetFragmentTrackDataByTimestamp = (trackData, timestamp) => {\n    trackData.startTimestamp += timestamp;\n    trackData.endTimestamp += timestamp;\n    for (const sample of trackData.samples) {\n        sample.presentationTimestamp += timestamp;\n    }\n    for (const entry of trackData.presentationTimestamps) {\n        entry.presentationTimestamp += timestamp;\n    }\n};\n/** Extracts the rotation component from a transformation matrix, in degrees. */\nconst extractRotationFromMatrix = (matrix) => {\n    const [m11, , , m21] = matrix;\n    const scaleX = Math.hypot(m11, m21);\n    const cosTheta = m11 / scaleX;\n    const sinTheta = m21 / scaleX;\n    // Invert the rotation because matrices are post-multiplied in ISOBMFF\n    const result = -Math.atan2(sinTheta, cosTheta) * (180 / Math.PI);\n    if (!Number.isFinite(result)) {\n        // Can happen if the entire matrix is 0, for example\n        return 0;\n    }\n    return result;\n};\nconst sampleTableIsEmpty = (sampleTable) => {\n    return sampleTable.sampleSizes.length === 0;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2566, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { toUint8Array, assert, isU32, last, textEncoder, COLOR_PRIMARIES_MAP, TRANSFER_CHARACTERISTICS_MAP, MATRIX_COEFFICIENTS_MAP, colorSpaceIsComplete, UNDETERMINED_LANGUAGE, assertNever, keyValueIterator, } from '../misc.js';\nimport { generateAv1CodecConfigurationFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { formatSubtitleTimestamp } from '../subtitles.js';\nimport { getTrackMetadata, GLOBAL_TIMESCALE, intoTimescale, } from './isobmff-muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { RichImageData } from '../metadata.js';\nexport class IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        assert(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = /* #__PURE__ */ new Uint8Array(8);\nconst view = /* #__PURE__ */ new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = /* #__PURE__ */ rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nexport const box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nexport const fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nexport const ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nexport const mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/** Free Space Box: A box that designates unused space in the movie data file. */\nexport const free = (size) => ({ type: 'free', size });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nexport const moov = (muxer) => box('moov', undefined, [\n    mvhd(muxer.creationTime, muxer.trackDatas),\n    ...muxer.trackDatas.map(x => trak(x, muxer.creationTime)),\n    muxer.isFragmented ? mvex(muxer.trackDatas) : null,\n    udta(muxer),\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nexport const mvhd = (creationTime, trackDatas) => {\n    const duration = intoTimescale(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !isU32(creationTime) || !isU32(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nexport const trak = (trackData, creationTime) => {\n    const trackMetadata = getTrackMetadata(trackData);\n    return box('trak', undefined, [\n        tkhd(trackData, creationTime),\n        mdia(trackData, creationTime),\n        trackMetadata.name !== undefined\n            ? box('udta', undefined, [\n                box('name', [\n                    ...textEncoder.encode(trackMetadata.name),\n                ]),\n            ])\n            : null,\n    ]);\n};\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nexport const tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, GLOBAL_TIMESCALE);\n    const needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    let flags = 0x2; // Track in movie\n    if (trackData.track.metadata.disposition?.default !== false) {\n        flags |= 0x1; // Track enabled\n    }\n    return fullBox('tkhd', +needsU64, flags, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nexport const mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nexport const mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !isU32(creationTime) || !isU32(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE)), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box. */\nexport const hdlr = (hasComponentType, handlerType, name, manufacturer = '\\0\\0\\0\\0') => fullBox('hdlr', 0, 0, [\n    hasComponentType ? ascii('mhlr') : u32(0), // Component type\n    ascii(handlerType), // Component subtype\n    ascii(manufacturer), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(name, true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nexport const minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nexport const vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nexport const smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nexport const nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nexport const dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nexport const dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nexport const url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nexport const stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nexport const stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(videoCodecToBoxName(trackData.track.source._codec, trackData.info.decoderConfig.codec), trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        assert(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    assert(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nexport const videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    colorSpaceIsComplete(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nexport const colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nexport const avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nexport const hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nexport const vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nexport const av1C = (trackData) => {\n    return box('av1C', generateAv1CodecConfigurationFromCodecString(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nexport const soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = parsePcmCodec(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nexport const esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = toUint8Array(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nexport const wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nexport const frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nexport const enda = (trackData) => {\n    const { littleEndian } = parsePcmCodec(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nexport const dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        assert(description.byteLength >= 18);\n        const bytes = toUint8Array(description);\n        const header = parseOpusIdentificationHeader(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nexport const dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    assert(description);\n    const bytes = toUint8Array(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = parsePcmCodec(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nexport const subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nexport const vttC = (trackData) => box('vttC', [\n    ...textEncoder.encode(trackData.info.config.description),\n]);\nexport const txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nexport const stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nexport const stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nexport const stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nexport const stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = parsePcmCodec(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + intoTimescale(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nexport const stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && last(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nexport const ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nexport const cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    assert(trackData.compositionTimeOffsetTable.length > 0);\n    assert(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, intoTimescale(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, intoTimescale(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nexport const mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nexport const trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nexport const moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nexport const mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nexport const traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nexport const tfhd = (trackData) => {\n    assert(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nexport const tfdt = (trackData) => {\n    assert(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64(intoTimescale(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nexport const trun = (trackData) => {\n    assert(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => intoTimescale(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nexport const mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nexport const tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64(intoTimescale(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nexport const mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nexport const vtte = () => box('vtte');\n/** VTT Cue Box */\nexport const vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [...textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [...textEncoder.encode(formatSubtitleTimestamp(timestamp))]) : null,\n    settings !== null ? box('sttg', [...textEncoder.encode(settings)]) : null,\n    box('payl', [...textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nexport const vtta = (notes) => box('vtta', [...textEncoder.encode(notes)]);\n/** User Data Box */\nconst udta = (muxer) => {\n    const boxes = [];\n    const metadataFormat = muxer.format._options.metadataFormat ?? 'auto';\n    const metadataTags = muxer.output._metadataTags;\n    // Depending on the format, metadata tags are written differently\n    if (metadataFormat === 'mdir' || (metadataFormat === 'auto' && !muxer.isQuickTime)) {\n        const metaBox = metaMdir(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'mdta') {\n        const metaBox = metaMdta(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'udta' || (metadataFormat === 'auto' && muxer.isQuickTime)) {\n        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return box('udta', undefined, boxes);\n};\nconst addQuickTimeMetadataTagBoxes = (boxes, tags) => {\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)\n    // For QuickTime files, metadata tags are dumped into the udta box\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxShort('nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxShort('des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxShort('ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxShort('alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxShort('albr', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxShort('gen', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxShort('day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxShort('cmt', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxShort('lyr', value));\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            case 'discNumber':\n            case 'discsTotal':\n            case 'trackNumber':\n            case 'tracksTotal':\n            case 'images':\n                {\n                    // Not written for QuickTime (common Apple L)\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxShort(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, Array.from(value)));\n            }\n        }\n    }\n};\nconst metadataTagStringBoxShort = (name, value) => {\n    const encoded = textEncoder.encode(value);\n    return box(name, [\n        u16(encoded.length),\n        u16(getLanguageCodeInt('und')),\n        Array.from(encoded),\n    ]);\n};\nconst DATA_BOX_MIME_TYPE_MAP = {\n    'image/jpeg': 13,\n    'image/png': 14,\n    'image/bmp': 27,\n};\n/**\n * Generates key-value metadata for inclusion in the \"meta\" box.\n */\nconst generateMetadataPairs = (tags, isMdta) => {\n    const pairs = [];\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)\n    // This is the metadata format used for MP4 files\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    pairs.push({ key: isMdta ? 'title' : 'nam', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    pairs.push({ key: isMdta ? 'description' : 'des', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    pairs.push({ key: isMdta ? 'artist' : 'ART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    pairs.push({ key: isMdta ? 'album' : 'alb', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    pairs.push({ key: isMdta ? 'album_artist' : 'aART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    pairs.push({ key: isMdta ? 'comment' : 'cmt', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    pairs.push({ key: isMdta ? 'genre' : 'gen', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    pairs.push({ key: isMdta ? 'lyrics' : 'lyr', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    pairs.push({\n                        key: isMdta ? 'date' : 'day',\n                        value: dataStringBoxLong(value.toISOString().slice(0, 10)),\n                    });\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    for (const image of value) {\n                        if (image.kind !== 'coverFront') {\n                            continue;\n                        }\n                        pairs.push({ key: 'covr', value: box('data', [\n                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0), // Type indicator\n                                u32(0), // Locale indicator\n                                Array.from(image.data), // Kinda slow, hopefully temp\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    if (isMdta) {\n                        const string = tags.tracksTotal !== undefined\n                            ? `${value}/${tags.tracksTotal}`\n                            : value.toString();\n                        pairs.push({ key: 'track', value: dataStringBoxLong(string) });\n                    }\n                    else {\n                        pairs.push({ key: 'trkn', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.tracksTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    if (!isMdta) {\n                        // Only written for mdir\n                        pairs.push({ key: 'disc', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.discsTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'tracksTotal':\n            case 'discsTotal':\n                {\n                    // These are included with 'trackNumber' and 'discNumber' respectively\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || (!isMdta && key.length !== 4) || pairs.some(x => x.key === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                pairs.push({ key, value: dataStringBoxLong(value) });\n            }\n            else if (value instanceof Uint8Array) {\n                pairs.push({ key, value: box('data', [\n                        u32(0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value),\n                    ]) });\n            }\n            else if (value instanceof RichImageData) {\n                pairs.push({ key, value: box('data', [\n                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value.data), // Kinda slow, hopefully temp\n                    ]) });\n            }\n        }\n    }\n    return pairs;\n};\n/** Metadata Box (mdir format) */\nconst metaMdir = (tags) => {\n    const pairs = generateMetadataPairs(tags, false);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // fullBox format\n    return fullBox('meta', 0, 0, undefined, [\n        hdlr(false, 'mdir', '', 'appl'), // mdir handler\n        box('ilst', undefined, pairs.map(pair => box(pair.key, undefined, [pair.value]))), // Item list without keys box\n    ]);\n};\n/** Metadata Box (mdta format with keys box) */\nconst metaMdta = (tags) => {\n    const pairs = generateMetadataPairs(tags, true);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // box without version and flags\n    return box('meta', undefined, [\n        hdlr(false, 'mdta', ''), // mdta handler\n        fullBox('keys', 0, 0, [\n            u32(pairs.length),\n        ], pairs.map(pair => box('mdta', [\n            ...textEncoder.encode(pair.key),\n        ]))),\n        box('ilst', undefined, pairs.map((pair, i) => {\n            const boxName = String.fromCharCode(...u32(i + 1));\n            return box(boxName, undefined, [pair.value]);\n        })),\n    ]);\n};\nconst dataStringBoxLong = (value) => {\n    return box('data', [\n        u32(1), // Type indicator (UTF-8)\n        u32(0), // Locale indicator\n        ...textEncoder.encode(value),\n    ]);\n};\nconst videoCodecToBoxName = (codec, fullCodecString) => {\n    switch (codec) {\n        case 'avc': return fullCodecString.startsWith('avc3') ? 'avc3' : 'avc1';\n        case 'hevc': return 'hvc1';\n        case 'vp8': return 'vp08';\n        case 'vp9': return 'vp09';\n        case 'av1': return 'av01';\n    }\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\nconst getLanguageCodeInt = (code) => {\n    assert(code.length === 3);\n    ;\n    let language = 0;\n    for (let i = 0; i < 3; i++) {\n        language <<= 5;\n        language += code.charCodeAt(i) - 0x60;\n    }\n    return language;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4197, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { free, ftyp, IsobmffBoxWriter, mdat, mfra, moof, moov, vtta, vttc, vtte } from './isobmff-boxes.js';\nimport { Muxer } from '../muxer.js';\nimport { BufferTargetWriter } from '../writer.js';\nimport { assert, computeRationalApproximation, last, promiseWithResolvers } from '../misc.js';\nimport { MovOutputFormat } from '../output-format.js';\nimport { inlineTimestampRegex } from '../subtitles.js';\nimport { parsePcmCodec, PCM_AUDIO_CODECS, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { BufferTarget } from '../target.js';\nimport { extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, serializeAvcDecoderConfigurationRecord, serializeHevcDecoderConfigurationRecord, transformAnnexBToLengthPrefixed, } from '../codec-data.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport const GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nexport const getTrackMetadata = (trackData) => {\n    const metadata = {};\n    const track = trackData.track;\n    if (track.metadata.name !== undefined) {\n        metadata.name = track.metadata.name;\n    }\n    return metadata;\n};\nexport const intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nexport class IsobmffMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.ftypSize = null;\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox(ftyp({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        this.ftypSize = this.writer.getPos();\n        if (this.fastStart === 'in-memory') {\n            // We're write at finalization\n        }\n        else if (this.fastStart === 'reserve') {\n            // Validate that all tracks have set maximumPacketCount\n            for (const track of this.output._tracks) {\n                if (track.metadata.maximumPacketCount === undefined) {\n                    throw new Error('All tracks must specify maximumPacketCount in their metadata when using'\n                        + ' fastStart: \\'reserve\\'.');\n                }\n            }\n            // We'll start writing once we know all tracks\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = mdat(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        assert(decoderConfig.codedWidth !== undefined);\n        assert(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractAvcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = serializeAvcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractHevcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = serializeHevcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = computeRationalApproximation(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && PCM_AUDIO_CODECS.includes(track.source._codec),\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const transformedData = transformAnnexBToLengthPrefixed(packetData);\n                if (!transformedData) {\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                packetData = transformedData;\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packet.data, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = last(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = parsePcmCodec(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                assert(cue.timestamp <= until);\n                assert(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = vtte();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = vtta(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = vttc(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = last(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                assert(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                assert(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = last(trackData.timeToSampleTable);\n                    assert(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = last(trackData.compositionTimeOffsetTable);\n                    assert(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        assert(trackData.lastSample);\n        assert(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            assert(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else if (this.fastStart === 'reserve') {\n            await this.registerSampleFastStartReserve(trackData, sample);\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n            if (this.fastStart === 'reserve') {\n                const maximumPacketCount = trackData.track.metadata.maximumPacketCount;\n                assert(maximumPacketCount !== undefined);\n                if (trackData.samples.length > maximumPacketCount) {\n                    throw new Error(`Track #${trackData.track.id} has already reached the maximum packet count`\n                        + ` (${maximumPacketCount}). Either add less packets or increase the maximum packet count.`);\n                }\n            }\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        assert(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        assert(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || last(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            assert(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        assert(this.isFragmented);\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        assert(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = moof(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += MAX_BOX_HEADER_SIZE - MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = moof(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        assert(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = mdat(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? MAX_BOX_HEADER_SIZE : MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    async registerSampleFastStartReserve(trackData, sample) {\n        if (this.allTracksAreKnown()) {\n            if (!this.mdat) {\n                // We finally know all tracks, let's reserve space for the moov box\n                const moovBox = moov(this);\n                const moovSize = this.boxWriter.measureBox(moovBox);\n                const reservedSize = moovSize\n                    + this.computeSampleTableSizeUpperBound()\n                    + 4096; // Just a little extra headroom\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize + reservedSize);\n                if (this.format._options.onMdat) {\n                    this.writer.startTrackingWrites();\n                }\n                this.mdat = mdat(true);\n                this.boxWriter.writeBox(this.mdat);\n                // Now write everything that was queued\n                for (const trackData of this.trackDatas) {\n                    for (const sample of trackData.sampleQueue) {\n                        await this.addSampleToTrack(trackData, sample);\n                    }\n                    trackData.sampleQueue.length = 0;\n                }\n            }\n            await this.addSampleToTrack(trackData, sample);\n        }\n        else {\n            // Queue it for when we know all tracks\n            trackData.sampleQueue.push(sample);\n        }\n    }\n    computeSampleTableSizeUpperBound() {\n        assert(this.fastStart === 'reserve');\n        let upperBound = 0;\n        for (const trackData of this.trackDatas) {\n            const n = trackData.track.metadata.maximumPacketCount;\n            assert(n !== undefined); // We validated this earlier\n            // Given the max allowed packet count, compute the space they'll take up in the Sample Table Box, assuming\n            // the worst case for each individual box:\n            // stts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stss box - 1 entry per sample\n            upperBound += 4 * n;\n            // ctts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stsc box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4 + 4) * Math.ceil(2 / 3 * n);\n            // stsz box - 1 entry per sample\n            upperBound += 4 * n;\n            // co64 box - we assume 1 sample per chunk and 64-bit chunk offsets (co64 instead of stco)\n            upperBound += 8 * n;\n        }\n        return upperBound;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = mdat(false);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = moov(this);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        assert(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    assert(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = mfra(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            assert(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            assert(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            const movieBox = moov(this);\n            if (this.fastStart === 'reserve') {\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize);\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n                // Fill the remaining space with a free box. If there are less than 8 bytes left, sucks I guess\n                const remainingSpace = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();\n                this.boxWriter.writeBox(free(remainingSpace));\n            }\n            else {\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n            }\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AACO,MAAM,mBAAmB;AAChC,MAAM,mBAAmB,eAAe,4CAA4C;AAC7E,MAAM,mBAAmB,CAAC;IAC7B,MAAM,WAAW,CAAC;IAClB,MAAM,QAAQ,UAAU,KAAK;IAC7B,IAAI,MAAM,QAAQ,CAAC,IAAI,KAAK,WAAW;QACnC,SAAS,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI;IACvC;IACA,OAAO;AACX;AACO,MAAM,gBAAgB,CAAC,eAAe,WAAW,QAAQ,IAAI;IAChE,MAAM,QAAQ,gBAAgB;IAC9B,OAAO,QAAQ,KAAK,KAAK,CAAC,SAAS;AACvC;AACO,MAAM,qBAAqB,wKAAK;IACnC,YAAY,MAAM,EAAE,MAAM,CAAE;QACxB,KAAK,CAAC;QACN,IAAI,CAAC,SAAS,GAAG,IAAI,gLAAY;QACjC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa;QAC7C,IAAI,CAAC,YAAY,GAAG,IAAI,yMAAgB,CAAC,IAAI,CAAC,SAAS;QACvD,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG,EAAE;QACpB,IAAI,CAAC,cAAc,GAAG,IAAA,sLAAoB;QAC1C,IAAI,CAAC,YAAY,GAAG,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,QAAQ;QACpD,IAAI,CAAC,eAAe,GAAG,EAAE;QACzB,IAAI,CAAC,kBAAkB,GAAG;QAC1B,8GAA8G;QAC9G,IAAI,CAAC,mBAAmB,GAAG,CAAC;QAC5B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG,OAAO,OAAO;QAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,yMAAgB,CAAC,IAAI,CAAC,MAAM;QACjD,IAAI,CAAC,WAAW,GAAG,kBAAkB,6LAAe;QACpD,6GAA6G;QAC7G,iCAAiC;QACjC,MAAM,mBAAmB,IAAI,CAAC,MAAM,YAAY,sLAAkB,GAAG,cAAc;QACnF,IAAI,CAAC,SAAS,GAAG,OAAO,QAAQ,CAAC,SAAS,IAAI;QAC9C,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,KAAK;QACvC,IAAI,IAAI,CAAC,SAAS,KAAK,eAAe,IAAI,CAAC,YAAY,EAAE;YACrD,IAAI,CAAC,MAAM,CAAC,kBAAkB,GAAG;QACrC;QACA,IAAI,CAAC,uBAAuB,GAAG,OAAO,QAAQ,CAAC,uBAAuB,IAAI;IAC9E;IACA,MAAM,QAAQ;QACV,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,MAAM,WAAW,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,WAAW,EAAE,MAAM,CAAC,MAAM,KAAK;QACzF,mBAAmB;QACnB;YACI,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;YACnC;YACA,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAA,6LAAI,EAAC;gBACzB,aAAa,IAAI,CAAC,WAAW;gBAC7B,UAAU;gBACV,YAAY,IAAI,CAAC,YAAY;YACjC;YACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;QACJ;QACA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM;QAClC,IAAI,IAAI,CAAC,SAAS,KAAK,aAAa;QAChC,8BAA8B;QAClC,OACK,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW;YACnC,uDAAuD;YACvD,KAAK,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO,CAAE;gBACrC,IAAI,MAAM,QAAQ,CAAC,kBAAkB,KAAK,WAAW;oBACjD,MAAM,IAAI,MAAM,4EACV;gBACV;YACJ;QACA,8CAA8C;QAClD,OACK,IAAI,IAAI,CAAC,YAAY,EAAE;QACxB,qGAAqG;QACzG,OACK;YACD,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;YACnC;YACA,IAAI,CAAC,IAAI,GAAG,IAAA,6LAAI,EAAC,OAAO,kEAAkE;YAC1F,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;QACrC;QACA,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK;QACvB;IACJ;IACA,oBAAoB;QAChB,KAAK,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO,CAAE;YACrC,IAAI,CAAC,MAAM,MAAM,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,QAAQ;gBACxE,OAAO,OAAO,oDAAoD;YACtE;QACJ;QACA,OAAO;IACX;IACA,MAAM,cAAc;QAChB,MAAM,IAAI,CAAC,cAAc,CAAC,OAAO;QACjC,MAAM,eAAe,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACtC,IAAI,UAAU,IAAI,KAAK,SAAS;gBAC5B,OAAO,UAAU,IAAI,CAAC,aAAa,CAAC,KAAK;YAC7C,OACK,IAAI,UAAU,IAAI,KAAK,SAAS;gBACjC,OAAO,UAAU,IAAI,CAAC,aAAa,CAAC,KAAK;YAC7C,OACK;gBACD,MAAM,MAAM;oBACR,QAAQ;gBACZ;gBACA,OAAO,GAAG,CAAC,UAAU,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;YAC7C;QACJ;QACA,OAAO,IAAA,4MAAoB,EAAC;YACxB,aAAa,IAAI,CAAC,WAAW;YAC7B,UAAU,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;YAC/C,UAAU,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;YAC/C;QACJ;IACJ;IACA,kBAAkB,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE;QACnC,MAAM,oBAAoB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;QAChE,IAAI,mBAAmB;YACnB,OAAO;QACX;QACA,IAAA,6LAA0B,EAAC;QAC3B,IAAA,wKAAM,EAAC;QACP,IAAA,wKAAM,EAAC,KAAK,aAAa;QACzB,MAAM,gBAAgB;YAAE,GAAG,KAAK,aAAa;QAAC;QAC9C,IAAA,wKAAM,EAAC,cAAc,UAAU,KAAK;QACpC,IAAA,wKAAM,EAAC,cAAc,WAAW,KAAK;QACrC,IAAI,+BAA+B;QACnC,IAAI,MAAM,MAAM,CAAC,MAAM,KAAK,SAAS,CAAC,cAAc,WAAW,EAAE;YAC7D,sGAAsG;YACtG,0DAA0D;YAC1D,MAAM,6BAA6B,IAAA,+MAAoC,EAAC,OAAO,IAAI;YACnF,IAAI,CAAC,4BAA4B;gBAC7B,MAAM,IAAI,MAAM,sGACV,8FACA,mGACA;YACV;YACA,cAAc,WAAW,GAAG,IAAA,iNAAsC,EAAC;YACnE,+BAA+B;QACnC,OACK,IAAI,MAAM,MAAM,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,WAAW,EAAE;YACnE,uGAAuG;YACvG,0DAA0D;YAC1D,MAAM,6BAA6B,IAAA,gNAAqC,EAAC,OAAO,IAAI;YACpF,IAAI,CAAC,4BAA4B;gBAC7B,MAAM,IAAI,MAAM,oGACV,kGACA,oGACA;YACV;YACA,cAAc,WAAW,GAAG,IAAA,kNAAuC,EAAC;YACpE,+BAA+B;QACnC;QACA,6GAA6G;QAC7G,uGAAuG;QACvG,oBAAoB;QACpB,MAAM,YAAY,IAAA,8LAA4B,EAAC,IAAI,CAAC,MAAM,QAAQ,CAAC,SAAS,IAAI,KAAK,GAAG,KAAK,WAAW;QACxG,MAAM,eAAe;YACjB,OAAO,IAAI;YACX;YACA,MAAM;YACN,MAAM;gBACF,OAAO,cAAc,UAAU;gBAC/B,QAAQ,cAAc,WAAW;gBACjC,eAAe;gBACf;YACJ;YACA;YACA,SAAS,EAAE;YACX,aAAa,EAAE;YACf,0BAA0B,EAAE;YAC5B,mBAAmB,EAAE;YACrB,4BAA4B,EAAE;YAC9B,oBAAoB;YACpB,YAAY;YACZ,iBAAiB,EAAE;YACnB,cAAc;YACd,0BAA0B,EAAE;QAChC;QACA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QACrB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE;QACtD,IAAI,IAAI,CAAC,iBAAiB,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/B;QACA,OAAO;IACX;IACA,kBAAkB,KAAK,EAAE,IAAI,EAAE;QAC3B,MAAM,oBAAoB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;QAChE,IAAI,mBAAmB;YACnB,OAAO;QACX;QACA,IAAA,6LAA0B,EAAC;QAC3B,IAAA,wKAAM,EAAC;QACP,IAAA,wKAAM,EAAC,KAAK,aAAa;QACzB,MAAM,eAAe;YACjB,OAAO,IAAI;YACX;YACA,MAAM;YACN,MAAM;gBACF,kBAAkB,KAAK,aAAa,CAAC,gBAAgB;gBACrD,YAAY,KAAK,aAAa,CAAC,UAAU;gBACzC,eAAe,KAAK,aAAa;gBACjC,2BAA2B,CAAC,IAAI,CAAC,YAAY,IACtC,mLAAgB,CAAC,QAAQ,CAAC,MAAM,MAAM,CAAC,MAAM;YACxD;YACA,WAAW,KAAK,aAAa,CAAC,UAAU;YACxC,SAAS,EAAE;YACX,aAAa,EAAE;YACf,0BAA0B,EAAE;YAC5B,mBAAmB,EAAE;YACrB,4BAA4B,EAAE;YAC9B,oBAAoB;YACpB,YAAY;YACZ,iBAAiB,EAAE;YACnB,cAAc;YACd,0BAA0B,EAAE;QAChC;QACA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QACrB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE;QACtD,IAAI,IAAI,CAAC,iBAAiB,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/B;QACA,OAAO;IACX;IACA,qBAAqB,KAAK,EAAE,IAAI,EAAE;QAC9B,MAAM,oBAAoB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;QAChE,IAAI,mBAAmB;YACnB,OAAO;QACX;QACA,IAAA,2LAAwB,EAAC;QACzB,IAAA,wKAAM,EAAC;QACP,IAAA,wKAAM,EAAC,KAAK,MAAM;QAClB,MAAM,eAAe;YACjB,OAAO,IAAI;YACX;YACA,MAAM;YACN,MAAM;gBACF,QAAQ,KAAK,MAAM;YACvB;YACA,WAAW;YACX,SAAS,EAAE;YACX,aAAa,EAAE;YACf,0BAA0B,EAAE;YAC5B,mBAAmB,EAAE;YACrB,4BAA4B,EAAE;YAC9B,oBAAoB;YACpB,YAAY;YACZ,iBAAiB,EAAE;YACnB,cAAc;YACd,0BAA0B,EAAE;YAC5B,qBAAqB;YACrB,UAAU,EAAE;YACZ,cAAc;YACd,eAAe,IAAI;QACvB;QACA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QACrB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE;QACtD,IAAI,IAAI,CAAC,iBAAiB,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/B;QACA,OAAO;IACX;IACA,MAAM,sBAAsB,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE;QAC7C,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,IAAI;YACA,MAAM,YAAY,IAAI,CAAC,iBAAiB,CAAC,OAAO,QAAQ;YACxD,IAAI,aAAa,OAAO,IAAI;YAC5B,IAAI,UAAU,IAAI,CAAC,4BAA4B,EAAE;gBAC7C,MAAM,kBAAkB,IAAA,0MAA+B,EAAC;gBACxD,IAAI,CAAC,iBAAiB;oBAClB,MAAM,IAAI,MAAM,8FACV;gBACV;gBACA,aAAa;YACjB;YACA,MAAM,YAAY,IAAI,CAAC,6BAA6B,CAAC,UAAU,KAAK,EAAE,OAAO,SAAS,EAAE,OAAO,IAAI,KAAK;YACxG,MAAM,iBAAiB,IAAI,CAAC,oBAAoB,CAAC,WAAW,YAAY,WAAW,OAAO,QAAQ,EAAE,OAAO,IAAI;YAC/G,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW;QACzC,SACQ;YACJ;QACJ;IACJ;IACA,MAAM,sBAAsB,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE;QAC7C,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,IAAI;YACA,MAAM,YAAY,IAAI,CAAC,iBAAiB,CAAC,OAAO;YAChD,MAAM,YAAY,IAAI,CAAC,6BAA6B,CAAC,UAAU,KAAK,EAAE,OAAO,SAAS,EAAE,OAAO,IAAI,KAAK;YACxG,MAAM,iBAAiB,IAAI,CAAC,oBAAoB,CAAC,WAAW,OAAO,IAAI,EAAE,WAAW,OAAO,QAAQ,EAAE,OAAO,IAAI;YAChH,IAAI,UAAU,IAAI,CAAC,yBAAyB,EAAE;gBAC1C,MAAM,IAAI,CAAC,mBAAmB,CAAC,WAAW;YAC9C;YACA,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW;QACzC,SACQ;YACJ;QACJ;IACJ;IACA,MAAM,oBAAoB,SAAS,EAAE,cAAc,EAAE;QACjD,6GAA6G;QAC7G,8FAA8F;QAC9F,qBAAqB;QACrB,MAAM,aAAa,IAAA,sKAAI,EAAC,UAAU,OAAO;QACzC,MAAM,mBAAmB,aACnB,WAAW,SAAS,GAAG,WAAW,QAAQ,GAC1C;QACN,MAAM,QAAQ,iBAAiB;QAC/B,MAAM,mBAAmB,cAAc,OAAO,UAAU,SAAS;QACjE,IAAI,mBAAmB,GAAG;YACtB,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG,IAAA,gLAAa,EAAC,UAAU,IAAI,CAAC,aAAa,CAAC,KAAK;YACpF,MAAM,gBAAgB,mBAAmB,UAAU,IAAI,CAAC,gBAAgB;YACxE,MAAM,OAAO,IAAI,WAAW,aAAa,eAAe,IAAI,CAAC;YAC7D,MAAM,gBAAgB,IAAI,CAAC,oBAAoB,CAAC,WAAW,IAAI,WAAW,KAAK,MAAM,GAAG,kBAAkB,OAAO;YACjH,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW;QACzC;IACJ;IACA,MAAM,eAAe,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE;QACnC,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,IAAI;YACA,MAAM,YAAY,IAAI,CAAC,oBAAoB,CAAC,OAAO;YACnD,IAAI,CAAC,6BAA6B,CAAC,UAAU,KAAK,EAAE,IAAI,SAAS,EAAE;YACnE,IAAI,MAAM,MAAM,CAAC,MAAM,KAAK,UAAU;gBAClC,UAAU,QAAQ,CAAC,IAAI,CAAC;gBACxB,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,IAAI,SAAS;YACzD,OACK;YACD,OAAO;YACX;QACJ,SACQ;YACJ;QACJ;IACJ;IACA,MAAM,kBAAkB,SAAS,EAAE,KAAK,EAAE;QACtC,2GAA2G;QAC3G,0GAA0G;QAC1G,MAAO,UAAU,QAAQ,CAAC,MAAM,GAAG,EAAG;YAClC,MAAM,aAAa,IAAI,IAAI,EAAE;YAC7B,KAAK,MAAM,OAAO,UAAU,QAAQ,CAAE;gBAClC,IAAA,wKAAM,EAAC,IAAI,SAAS,IAAI;gBACxB,IAAA,wKAAM,EAAC,UAAU,mBAAmB,IAAI,IAAI,SAAS,GAAG,IAAI,QAAQ;gBACpE,WAAW,GAAG,CAAC,KAAK,GAAG,CAAC,IAAI,SAAS,EAAE,UAAU,mBAAmB,IAAI,kBAAkB;gBAC1F,WAAW,GAAG,CAAC,IAAI,SAAS,GAAG,IAAI,QAAQ,GAAG,gBAAgB;YAClE;YACA,MAAM,mBAAmB;mBAAI;aAAW,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI;YAC5D,4DAA4D;YAC5D,MAAM,cAAc,gBAAgB,CAAC,EAAE;YACvC,MAAM,YAAY,gBAAgB,CAAC,EAAE,IAAI;YACzC,IAAI,QAAQ,WAAW;gBACnB;YACJ;YACA,sDAAsD;YACtD,IAAI,UAAU,mBAAmB,GAAG,aAAa;gBAC7C,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBACpB,MAAM,MAAM,IAAA,6LAAI;gBAChB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;gBAC3B,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM;gBAC7D,MAAM,SAAS,IAAI,CAAC,oBAAoB,CAAC,WAAW,MAAM,UAAU,mBAAmB,EAAE,cAAc,UAAU,mBAAmB,EAAE;gBACtI,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW;gBACrC,UAAU,mBAAmB,GAAG;YACpC;YACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;YACpB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,CAAC,MAAM,EAAE,IAAK;gBAChD,MAAM,MAAM,UAAU,QAAQ,CAAC,EAAE;gBACjC,IAAI,IAAI,SAAS,IAAI,WAAW;oBAC5B;gBACJ;gBACA,2LAAoB,CAAC,SAAS,GAAG;gBACjC,MAAM,oBAAoB,2LAAoB,CAAC,IAAI,CAAC,IAAI,IAAI;gBAC5D,MAAM,eAAe,IAAI,SAAS,GAAG,IAAI,QAAQ;gBACjD,IAAI,WAAW,UAAU,aAAa,CAAC,GAAG,CAAC;gBAC3C,IAAI,aAAa,aAAa,YAAY,cAAc;oBACpD,4FAA4F;oBAC5F,YAAY;oBACZ,WAAW,UAAU,YAAY;oBACjC,UAAU,aAAa,CAAC,GAAG,CAAC,KAAK;gBACrC;gBACA,IAAI,IAAI,KAAK,EAAE;oBACX,wDAAwD;oBACxD,MAAM,MAAM,IAAA,6LAAI,EAAC,IAAI,KAAK;oBAC1B,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;gBAC/B;gBACA,MAAM,MAAM,IAAA,6LAAI,EAAC,IAAI,IAAI,EAAE,oBAAoB,cAAc,MAAM,IAAI,UAAU,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,YAAY;gBAC7H,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;gBAC3B,IAAI,iBAAiB,WAAW;oBAC5B,mEAAmE;oBACnE,UAAU,QAAQ,CAAC,MAAM,CAAC,KAAK;gBACnC;YACJ;YACA,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM;YAC7D,MAAM,SAAS,IAAI,CAAC,oBAAoB,CAAC,WAAW,MAAM,aAAa,YAAY,aAAa;YAChG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW;YACrC,UAAU,mBAAmB,GAAG;QACpC;IACJ;IACA,qBAAqB,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE;QAC7D,MAAM,SAAS;YACX;YACA,iBAAiB;YACjB;YACA;YACA,MAAM,KAAK,UAAU;YACrB;YACA,4BAA4B,cAAc,UAAU,UAAU,SAAS;QAC3E;QACA,OAAO;IACX;IACA,kBAAkB,SAAS,EAAE,UAAU,EAAE;QACrC,IAAI,UAAU,wBAAwB,CAAC,MAAM,KAAK,GAAG;YACjD;QACJ;QACA,IAAI,UAAU,IAAI,KAAK,WAAW,UAAU,IAAI,CAAC,yBAAyB,EAAE;YACxE,IAAI,gBAAgB;YACpB,wGAAwG;YACxG,wDAAwD;YACxD,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,wBAAwB,CAAC,MAAM,EAAE,IAAK;gBAChE,MAAM,SAAS,UAAU,wBAAwB,CAAC,EAAE;gBACpD,MAAM,WAAW,cAAc,OAAO,QAAQ,EAAE,UAAU,SAAS;gBACnE,iBAAiB;YACrB;YACA,IAAI,UAAU,iBAAiB,CAAC,MAAM,KAAK,GAAG;gBAC1C,UAAU,iBAAiB,CAAC,IAAI,CAAC;oBAC7B,aAAa;oBACb,aAAa;gBACjB;YACJ,OACK;gBACD,MAAM,YAAY,IAAA,sKAAI,EAAC,UAAU,iBAAiB;gBAClD,UAAU,WAAW,IAAI;YAC7B;YACA,UAAU,wBAAwB,CAAC,MAAM,GAAG;YAC5C;QACJ;QACA,MAAM,mBAAmB,UAAU,wBAAwB,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI;QACrG,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,wBAAwB,CAAC,MAAM,EAAE,IAAK;YAChE,MAAM,SAAS,UAAU,wBAAwB,CAAC,EAAE;YACpD,0GAA0G;YAC1G,+FAA+F;YAC/F,yGAAyG;YACzG,YAAY;YACZ,OAAO,eAAe,GAAG,gBAAgB,CAAC,EAAE;YAC5C,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,UAAU,kBAAkB,KAAK,MAAM;gBAC7D,gGAAgG;gBAChG,oFAAoF;gBACpF,OAAO,eAAe,GAAG;YAC7B;YACA,MAAM,8BAA8B,cAAc,OAAO,SAAS,GAAG,OAAO,eAAe,EAAE,UAAU,SAAS;YAChH,MAAM,sBAAsB,cAAc,OAAO,QAAQ,EAAE,UAAU,SAAS;YAC9E,IAAI,UAAU,kBAAkB,KAAK,MAAM;gBACvC,IAAA,wKAAM,EAAC,UAAU,UAAU;gBAC3B,MAAM,iBAAiB,cAAc,OAAO,eAAe,EAAE,UAAU,SAAS,EAAE;gBAClF,MAAM,QAAQ,KAAK,KAAK,CAAC,iBAAiB,UAAU,kBAAkB;gBACtE,IAAA,wKAAM,EAAC,SAAS;gBAChB,UAAU,kBAAkB,IAAI;gBAChC,UAAU,UAAU,CAAC,0BAA0B,GAAG;gBAClD,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACpB,IAAI,iBAAiB,IAAA,sKAAI,EAAC,UAAU,iBAAiB;oBACrD,IAAA,wKAAM,EAAC;oBACP,IAAI,eAAe,WAAW,KAAK,GAAG;wBAClC,eAAe,WAAW,GAAG;wBAC7B,MAAM,cAAc,UAAU,iBAAiB,CAAC,UAAU,iBAAiB,CAAC,MAAM,GAAG,EAAE;wBACvF,IAAI,eAAe,YAAY,WAAW,KAAK,OAAO;4BAClD,sEAAsE;4BACtE,YAAY,WAAW;4BACvB,UAAU,iBAAiB,CAAC,GAAG;4BAC/B,iBAAiB;wBACrB;oBACJ,OACK,IAAI,eAAe,WAAW,KAAK,OAAO;wBAC3C,4EAA4E;wBAC5E,eAAe,WAAW;wBAC1B,UAAU,iBAAiB,CAAC,IAAI,CAAC,iBAAiB;4BAC9C,aAAa;4BACb,aAAa;wBACjB;oBACJ;oBACA,IAAI,eAAe,WAAW,KAAK,qBAAqB;wBACpD,yEAAyE;wBACzE,eAAe,WAAW;oBAC9B,OACK;wBACD,uEAAuE;wBACvE,UAAU,iBAAiB,CAAC,IAAI,CAAC;4BAC7B,aAAa;4BACb,aAAa;wBACjB;oBACJ;oBACA,MAAM,sCAAsC,IAAA,sKAAI,EAAC,UAAU,0BAA0B;oBACrF,IAAA,wKAAM,EAAC;oBACP,IAAI,oCAAoC,2BAA2B,KAAK,6BAA6B;wBACjG,6BAA6B;wBAC7B,oCAAoC,WAAW;oBACnD,OACK;wBACD,+FAA+F;wBAC/F,SAAS;wBACT,UAAU,0BAA0B,CAAC,IAAI,CAAC;4BACtC,aAAa;4BACb,6BAA6B;wBACjC;oBACJ;gBACJ;YACJ,OACK;gBACD,uCAAuC;gBACvC,UAAU,kBAAkB,GAAG,cAAc,OAAO,eAAe,EAAE,UAAU,SAAS,EAAE;gBAC1F,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACpB,UAAU,iBAAiB,CAAC,IAAI,CAAC;wBAC7B,aAAa;wBACb,aAAa;oBACjB;oBACA,UAAU,0BAA0B,CAAC,IAAI,CAAC;wBACtC,aAAa;wBACb,6BAA6B;oBACjC;gBACJ;YACJ;YACA,UAAU,UAAU,GAAG;QAC3B;QACA,UAAU,wBAAwB,CAAC,MAAM,GAAG;QAC5C,IAAA,wKAAM,EAAC,UAAU,UAAU;QAC3B,IAAA,wKAAM,EAAC,UAAU,kBAAkB,KAAK;QACxC,IAAI,eAAe,aAAa,UAAU,UAAU,CAAC,0BAA0B,KAAK,GAAG;YACnF,IAAA,wKAAM,EAAC,WAAW,IAAI,KAAK;YAC3B,uGAAuG;YACvG,qGAAqG;YACrG,4GAA4G;YAC5G,kCAAkC;YAClC,MAAM,iBAAiB,cAAc,WAAW,SAAS,EAAE,UAAU,SAAS,EAAE;YAChF,MAAM,QAAQ,KAAK,KAAK,CAAC,iBAAiB,UAAU,kBAAkB;YACtE,UAAU,UAAU,CAAC,0BAA0B,GAAG;QACtD;IACJ;IACA,MAAM,eAAe,SAAS,EAAE,MAAM,EAAE;QACpC,IAAI,OAAO,IAAI,KAAK,OAAO;YACvB,IAAI,CAAC,iBAAiB,CAAC,WAAW;QACtC;QACA,UAAU,wBAAwB,CAAC,IAAI,CAAC;QACxC,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,UAAU,WAAW,CAAC,IAAI,CAAC;YAC3B,MAAM,IAAI,CAAC,iBAAiB;QAChC,OACK,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW;YACnC,MAAM,IAAI,CAAC,8BAA8B,CAAC,WAAW;QACzD,OACK;YACD,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW;QAC3C;IACJ;IACA,MAAM,iBAAiB,SAAS,EAAE,MAAM,EAAE;QACtC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACpB,UAAU,OAAO,CAAC,IAAI,CAAC;YACvB,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW;gBAC9B,MAAM,qBAAqB,UAAU,KAAK,CAAC,QAAQ,CAAC,kBAAkB;gBACtE,IAAA,wKAAM,EAAC,uBAAuB;gBAC9B,IAAI,UAAU,OAAO,CAAC,MAAM,GAAG,oBAAoB;oBAC/C,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,UAAU,KAAK,CAAC,EAAE,CAAC,6CAA6C,CAAC,GACrF,CAAC,EAAE,EAAE,mBAAmB,gEAAgE,CAAC;gBACnG;YACJ;QACJ;QACA,IAAI,gBAAgB;QACpB,IAAI,CAAC,UAAU,YAAY,EAAE;YACzB,gBAAgB;QACpB,OACK;YACD,yGAAyG;YACzG,YAAY;YACZ,UAAU,YAAY,CAAC,cAAc,GAAG,KAAK,GAAG,CAAC,UAAU,YAAY,CAAC,cAAc,EAAE,OAAO,SAAS;YACxG,MAAM,uBAAuB,OAAO,SAAS,GAAG,UAAU,YAAY,CAAC,cAAc;YACrF,IAAI,IAAI,CAAC,YAAY,EAAE;gBACnB,sGAAsG;gBACtG,sCAAsC;gBACtC,MAAM,2BAA2B,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;oBACpD,IAAI,cAAc,gBAAgB;wBAC9B,OAAO,OAAO,IAAI,KAAK;oBAC3B;oBACA,MAAM,oBAAoB,eAAe,WAAW,CAAC,EAAE;oBACvD,IAAI,mBAAmB;wBACnB,OAAO,kBAAkB,IAAI,KAAK;oBACtC;oBACA,OAAO,eAAe,KAAK,CAAC,MAAM,CAAC,OAAO;gBAC9C;gBACA,IAAI,wBAAwB,IAAI,CAAC,uBAAuB,IACjD,4BACA,OAAO,SAAS,GAAG,IAAI,CAAC,mBAAmB,EAAE;oBAChD,gBAAgB;oBAChB,MAAM,IAAI,CAAC,gBAAgB;gBAC/B;YACJ,OACK;gBACD,gBAAgB,wBAAwB,KAAK,0CAA0C;YAC3F;QACJ;QACA,IAAI,eAAe;YACf,IAAI,UAAU,YAAY,EAAE;gBACxB,MAAM,IAAI,CAAC,oBAAoB,CAAC;YACpC;YACA,UAAU,YAAY,GAAG;gBACrB,gBAAgB,OAAO,SAAS;gBAChC,SAAS,EAAE;gBACX,QAAQ;gBACR,YAAY;YAChB;QACJ;QACA,IAAA,wKAAM,EAAC,UAAU,YAAY;QAC7B,UAAU,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC;QACpC,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,mBAAmB,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,mBAAmB,EAAE,OAAO,SAAS;QAClF;IACJ;IACA,MAAM,qBAAqB,SAAS,EAAE;QAClC,IAAA,wKAAM,EAAC,CAAC,IAAI,CAAC,YAAY;QACzB,IAAI,CAAC,UAAU,YAAY,EACvB;QACJ,UAAU,eAAe,CAAC,IAAI,CAAC,UAAU,YAAY;QACrD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,YAAY;QAChD,IAAI,cAAc,UAAU,YAAY,CAAC,OAAO,CAAC,MAAM;QACvD,IAAI,UAAU,IAAI,KAAK,WAAW,UAAU,IAAI,CAAC,yBAAyB,EAAE;YACxE,cAAc,UAAU,YAAY,CAAC,OAAO,CACvC,MAAM,CAAC,CAAC,KAAK,SAAW,MAAM,cAAc,OAAO,QAAQ,EAAE,UAAU,SAAS,GAAG;QAC5F;QACA,IAAI,UAAU,wBAAwB,CAAC,MAAM,KAAK,KAC3C,IAAA,sKAAI,EAAC,UAAU,wBAAwB,EAAE,eAAe,KAAK,aAAa;YAC7E,UAAU,wBAAwB,CAAC,IAAI,CAAC;gBACpC,YAAY,UAAU,eAAe,CAAC,MAAM;gBAC5C,iBAAiB;YACrB;QACJ;QACA,IAAI,IAAI,CAAC,SAAS,KAAK,aAAa;YAChC,UAAU,YAAY,CAAC,MAAM,GAAG,GAAG,kDAAkD;YACrF;QACJ;QACA,qBAAqB;QACrB,UAAU,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM;QAClD,KAAK,MAAM,UAAU,UAAU,YAAY,CAAC,OAAO,CAAE;YACjD,IAAA,wKAAM,EAAC,OAAO,IAAI;YAClB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,IAAI;YAC7B,OAAO,IAAI,GAAG,MAAM,cAAc;QACtC;QACA,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK;IAC3B;IACA,MAAM,kBAAkB,cAAc,KAAK,EAAE;QACzC,IAAA,wKAAM,EAAC,IAAI,CAAC,YAAY;QACxB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,iBAAiB,IAAI;YAC3C,QAAQ,gFAAgF;QAC5F;QACA,OAAO,MAAO,KAAM;YAChB,IAAI,wBAAwB;YAC5B,IAAI,eAAe;YACnB,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;gBACrC,IAAI,CAAC,eAAe,UAAU,WAAW,CAAC,MAAM,KAAK,KAAK,CAAC,UAAU,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE;oBACvF,MAAM;gBACV;gBACA,IAAI,UAAU,WAAW,CAAC,MAAM,GAAG,KAAK,UAAU,WAAW,CAAC,EAAE,CAAC,SAAS,GAAG,cAAc;oBACvF,wBAAwB;oBACxB,eAAe,UAAU,WAAW,CAAC,EAAE,CAAC,SAAS;gBACrD;YACJ;YACA,IAAI,CAAC,uBAAuB;gBACxB;YACJ;YACA,MAAM,SAAS,sBAAsB,WAAW,CAAC,KAAK;YACtD,MAAM,IAAI,CAAC,gBAAgB,CAAC,uBAAuB;QACvD;IACJ;IACA,MAAM,iBAAiB,cAAc,IAAI,EAAE;QACvC,IAAA,wKAAM,EAAC,IAAI,CAAC,YAAY;QACxB,MAAM,iBAAiB,IAAI,CAAC,kBAAkB;QAC9C,IAAI,mBAAmB,GAAG;YACtB,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;YACnC;YACA,0DAA0D;YAC1D,MAAM,WAAW,IAAA,6LAAI,EAAC,IAAI;YAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;YACxB,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;QACJ;QACA,sDAAsD;QACtD,MAAM,mBAAmB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,YAAY;QACnE,0GAA0G;QAC1G,MAAM,UAAU,IAAA,6LAAI,EAAC,gBAAgB;QACrC,MAAM,aAAa,IAAI,CAAC,MAAM,CAAC,MAAM;QACrC,MAAM,eAAe,aAAa,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;QAC5D,IAAI,aAAa,eAAe,6MAAmB;QACnD,IAAI,yBAAyB;QAC7B,KAAK,MAAM,aAAa,iBAAkB;YACtC,UAAU,YAAY,CAAC,MAAM,GAAG;YAChC,UAAU,YAAY,CAAC,UAAU,GAAG;YACpC,KAAK,MAAM,UAAU,UAAU,YAAY,CAAC,OAAO,CAAE;gBACjD,cAAc,OAAO,IAAI;YAC7B;YACA,yBAAyB,KAAK,GAAG,CAAC,wBAAwB,UAAU,YAAY,CAAC,cAAc;QACnG;QACA,MAAM,WAAW,aAAa;QAC9B,MAAM,qBAAqB,YAAY,KAAK;QAC5C,IAAI,oBAAoB;YACpB,2GAA2G;YAC3G,4GAA4G;YAC5G,KAAK,MAAM,aAAa,iBAAkB;gBACtC,UAAU,YAAY,CAAC,MAAM,IAAI,6MAAmB,GAAG,6MAAmB;YAC9E;QACJ;QACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;QACnC;QACA,MAAM,aAAa,IAAA,6LAAI,EAAC,gBAAgB;QACxC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;QACxB,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;YACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,OAAO;QAC7C;QACA,IAAA,wKAAM,EAAC,IAAI,CAAC,MAAM,CAAC,MAAM,OAAO;QAChC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;QACnC;QACA,MAAM,UAAU,IAAA,6LAAI,EAAC;QACrB,QAAQ,IAAI,GAAG;QACf,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,qBAAqB,6MAAmB,GAAG,6MAAmB;QAC/F,oBAAoB;QACpB,KAAK,MAAM,aAAa,iBAAkB;YACtC,KAAK,MAAM,UAAU,UAAU,YAAY,CAAC,OAAO,CAAE;gBACjD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,IAAI;gBAC7B,OAAO,IAAI,GAAG,MAAM,cAAc;YACtC;QACJ;QACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;YACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;QACtC;QACA,KAAK,MAAM,aAAa,iBAAkB;YACtC,UAAU,eAAe,CAAC,IAAI,CAAC,UAAU,YAAY;YACrD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,YAAY;YAChD,UAAU,YAAY,GAAG;QAC7B;QACA,IAAI,aAAa;YACb,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK;QAC3B;IACJ;IACA,MAAM,+BAA+B,SAAS,EAAE,MAAM,EAAE;QACpD,IAAI,IAAI,CAAC,iBAAiB,IAAI;YAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBACZ,mEAAmE;gBACnE,MAAM,UAAU,IAAA,6LAAI,EAAC,IAAI;gBACzB,MAAM,WAAW,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBAC3C,MAAM,eAAe,WACf,IAAI,CAAC,gCAAgC,KACrC,MAAM,+BAA+B;gBAC3C,IAAA,wKAAM,EAAC,IAAI,CAAC,QAAQ,KAAK;gBACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG;gBACjC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;oBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;gBACnC;gBACA,IAAI,CAAC,IAAI,GAAG,IAAA,6LAAI,EAAC;gBACjB,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;gBACjC,uCAAuC;gBACvC,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;oBACrC,KAAK,MAAM,UAAU,UAAU,WAAW,CAAE;wBACxC,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW;oBAC3C;oBACA,UAAU,WAAW,CAAC,MAAM,GAAG;gBACnC;YACJ;YACA,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW;QAC3C,OACK;YACD,uCAAuC;YACvC,UAAU,WAAW,CAAC,IAAI,CAAC;QAC/B;IACJ;IACA,mCAAmC;QAC/B,IAAA,wKAAM,EAAC,IAAI,CAAC,SAAS,KAAK;QAC1B,IAAI,aAAa;QACjB,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;YACrC,MAAM,IAAI,UAAU,KAAK,CAAC,QAAQ,CAAC,kBAAkB;YACrD,IAAA,wKAAM,EAAC,MAAM,YAAY,4BAA4B;YACrD,0GAA0G;YAC1G,0CAA0C;YAC1C,wFAAwF;YACxF,cAAc,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI;YAC1C,gCAAgC;YAChC,cAAc,IAAI;YAClB,wFAAwF;YACxF,cAAc,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI;YAC1C,wFAAwF;YACxF,cAAc,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI;YAC9C,gCAAgC;YAChC,cAAc,IAAI;YAClB,0FAA0F;YAC1F,cAAc,IAAI;QACtB;QACA,OAAO;IACX;IACA,kEAAkE;IAClE,MAAM,aAAa,KAAK,EAAE;QACtB,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,IAAI,MAAM,IAAI,KAAK,cAAc,MAAM,MAAM,CAAC,MAAM,KAAK,UAAU;YAC/D,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;YACxD,IAAI,WAAW;gBACX,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW;YAC5C;QACJ;QACA,IAAI,IAAI,CAAC,iBAAiB,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/B;QACA,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,+FAA+F;YAC/F,MAAM,IAAI,CAAC,iBAAiB;QAChC;QACA;IACJ;IACA,kHAAkH,GAClH,MAAM,WAAW;QACb,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO;QACxC,IAAI,CAAC,cAAc,CAAC,OAAO;QAC3B,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;YACrC,IAAI,UAAU,IAAI,KAAK,cAAc,UAAU,KAAK,CAAC,MAAM,CAAC,MAAM,KAAK,UAAU;gBAC7E,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW;YAC5C;QACJ;QACA,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAC7B,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;gBACrC,IAAI,CAAC,iBAAiB,CAAC;YAC3B;YACA,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,sEAAsE;QAC9G,OACK;YACD,KAAK,MAAM,aAAa,IAAI,CAAC,UAAU,CAAE;gBACrC,IAAI,CAAC,iBAAiB,CAAC;gBACvB,MAAM,IAAI,CAAC,oBAAoB,CAAC;YACpC;QACJ;QACA,IAAI,IAAI,CAAC,SAAS,KAAK,aAAa;YAChC,IAAI,CAAC,IAAI,GAAG,IAAA,6LAAI,EAAC;YACjB,IAAI;YACJ,uGAAuG;YACvG,2GAA2G;YAC3G,wGAAwG;YACxG,wGAAwG;YACxG,2GAA2G;YAC3G,0GAA0G;YAC1G,mEAAmE;YACnE,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gBACxB,MAAM,WAAW,IAAA,6LAAI,EAAC,IAAI;gBAC1B,MAAM,eAAe,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBAC/C,WAAW,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI;gBAC9C,IAAI,kBAAkB,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,eAAe;gBAC5D,KAAK,MAAM,SAAS,IAAI,CAAC,eAAe,CAAE;oBACtC,MAAM,MAAM,GAAG;oBACf,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,MAAM,OAAO,CAAE;wBAClC,IAAA,wKAAM,EAAC;wBACP,mBAAmB,KAAK,UAAU;wBAClC,YAAY,KAAK,UAAU;oBAC/B;gBACJ;gBACA,IAAI,kBAAkB,KAAK,IACvB;gBACJ,IAAI,YAAY,KAAK,IACjB,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG;YAC9B;YACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;YACnC;YACA,MAAM,WAAW,IAAA,6LAAI,EAAC,IAAI;YAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;YACxB,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;YACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;YACnC;YACA,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG;YACjB,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;YACjC,KAAK,MAAM,SAAS,IAAI,CAAC,eAAe,CAAE;gBACtC,KAAK,MAAM,UAAU,MAAM,OAAO,CAAE;oBAChC,IAAA,wKAAM,EAAC,OAAO,IAAI;oBAClB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,IAAI;oBAC7B,OAAO,IAAI,GAAG;gBAClB;YACJ;YACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;QACJ,OACK,IAAI,IAAI,CAAC,YAAY,EAAE;YACxB,sEAAsE;YACtE,MAAM,WAAW,IAAI,CAAC,MAAM,CAAC,MAAM;YACnC,MAAM,UAAU,IAAA,6LAAI,EAAC,IAAI,CAAC,UAAU;YACpC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;YACxB,qGAAqG;YACrG,MAAM,cAAc,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK;YAC3C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK;YACxC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;QAC5B,OACK;YACD,IAAA,wKAAM,EAAC,IAAI,CAAC,IAAI;YAChB,MAAM,UAAU,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI;YACpD,IAAA,wKAAM,EAAC,YAAY;YACnB,MAAM,WAAW,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK;YACxC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG;YACjB,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,YAAY,KAAK,IAAI,wCAAwC;YACnF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;YACjC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;YACA,MAAM,WAAW,IAAA,6LAAI,EAAC,IAAI;YAC1B,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW;gBAC9B,IAAA,wKAAM,EAAC,IAAI,CAAC,QAAQ,KAAK;gBACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ;gBAC9B,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;oBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;gBACnC;gBACA,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;gBACxB,+FAA+F;gBAC/F,MAAM,iBAAiB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM;gBACjF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAA,6LAAI,EAAC;YACjC,OACK;gBACD,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;oBAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB;gBACnC;gBACA,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;YAC5B;YACA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC7B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB;gBACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;YACtC;QACJ;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}}]
}