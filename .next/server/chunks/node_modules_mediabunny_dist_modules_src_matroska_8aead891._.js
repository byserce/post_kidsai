module.exports = [
"[project]/node_modules/mediabunny/dist/modules/src/matroska/ebml.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "CODEC_STRING_MAP",
    ()=>CODEC_STRING_MAP,
    "EBMLFloat32",
    ()=>EBMLFloat32,
    "EBMLFloat64",
    ()=>EBMLFloat64,
    "EBMLId",
    ()=>EBMLId,
    "EBMLSignedInt",
    ()=>EBMLSignedInt,
    "EBMLUnicodeString",
    ()=>EBMLUnicodeString,
    "EBMLWriter",
    ()=>EBMLWriter,
    "LEVEL_0_AND_1_EBML_IDS",
    ()=>LEVEL_0_AND_1_EBML_IDS,
    "LEVEL_0_EBML_IDS",
    ()=>LEVEL_0_EBML_IDS,
    "LEVEL_1_EBML_IDS",
    ()=>LEVEL_1_EBML_IDS,
    "MAX_HEADER_SIZE",
    ()=>MAX_HEADER_SIZE,
    "MAX_VAR_INT_SIZE",
    ()=>MAX_VAR_INT_SIZE,
    "MIN_HEADER_SIZE",
    ()=>MIN_HEADER_SIZE,
    "assertDefinedSize",
    ()=>assertDefinedSize,
    "measureSignedInt",
    ()=>measureSignedInt,
    "measureUnsignedBigInt",
    ()=>measureUnsignedBigInt,
    "measureUnsignedInt",
    ()=>measureUnsignedInt,
    "measureVarInt",
    ()=>measureVarInt,
    "readAsciiString",
    ()=>readAsciiString,
    "readElementHeader",
    ()=>readElementHeader,
    "readElementId",
    ()=>readElementId,
    "readElementSize",
    ()=>readElementSize,
    "readFloat",
    ()=>readFloat,
    "readSignedInt",
    ()=>readSignedInt,
    "readUnicodeString",
    ()=>readUnicodeString,
    "readUnsignedBigInt",
    ()=>readUnsignedBigInt,
    "readUnsignedInt",
    ()=>readUnsignedInt,
    "readVarInt",
    ()=>readVarInt,
    "readVarIntSize",
    ()=>readVarIntSize,
    "resync",
    ()=>resync,
    "searchForNextElementId",
    ()=>searchForNextElementId
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/reader.js [app-route] (ecmascript)");
;
;
class EBMLFloat32 {
    constructor(value){
        this.value = value;
    }
}
class EBMLFloat64 {
    constructor(value){
        this.value = value;
    }
}
class EBMLSignedInt {
    constructor(value){
        this.value = value;
    }
}
class EBMLUnicodeString {
    constructor(value){
        this.value = value;
    }
}
var EBMLId;
(function(EBMLId) {
    EBMLId[EBMLId["EBML"] = 440786851] = "EBML";
    EBMLId[EBMLId["EBMLVersion"] = 17030] = "EBMLVersion";
    EBMLId[EBMLId["EBMLReadVersion"] = 17143] = "EBMLReadVersion";
    EBMLId[EBMLId["EBMLMaxIDLength"] = 17138] = "EBMLMaxIDLength";
    EBMLId[EBMLId["EBMLMaxSizeLength"] = 17139] = "EBMLMaxSizeLength";
    EBMLId[EBMLId["DocType"] = 17026] = "DocType";
    EBMLId[EBMLId["DocTypeVersion"] = 17031] = "DocTypeVersion";
    EBMLId[EBMLId["DocTypeReadVersion"] = 17029] = "DocTypeReadVersion";
    EBMLId[EBMLId["Void"] = 236] = "Void";
    EBMLId[EBMLId["Segment"] = 408125543] = "Segment";
    EBMLId[EBMLId["SeekHead"] = 290298740] = "SeekHead";
    EBMLId[EBMLId["Seek"] = 19899] = "Seek";
    EBMLId[EBMLId["SeekID"] = 21419] = "SeekID";
    EBMLId[EBMLId["SeekPosition"] = 21420] = "SeekPosition";
    EBMLId[EBMLId["Duration"] = 17545] = "Duration";
    EBMLId[EBMLId["Info"] = 357149030] = "Info";
    EBMLId[EBMLId["TimestampScale"] = 2807729] = "TimestampScale";
    EBMLId[EBMLId["MuxingApp"] = 19840] = "MuxingApp";
    EBMLId[EBMLId["WritingApp"] = 22337] = "WritingApp";
    EBMLId[EBMLId["Tracks"] = 374648427] = "Tracks";
    EBMLId[EBMLId["TrackEntry"] = 174] = "TrackEntry";
    EBMLId[EBMLId["TrackNumber"] = 215] = "TrackNumber";
    EBMLId[EBMLId["TrackUID"] = 29637] = "TrackUID";
    EBMLId[EBMLId["TrackType"] = 131] = "TrackType";
    EBMLId[EBMLId["FlagEnabled"] = 185] = "FlagEnabled";
    EBMLId[EBMLId["FlagDefault"] = 136] = "FlagDefault";
    EBMLId[EBMLId["FlagForced"] = 21930] = "FlagForced";
    EBMLId[EBMLId["FlagOriginal"] = 21934] = "FlagOriginal";
    EBMLId[EBMLId["FlagHearingImpaired"] = 21931] = "FlagHearingImpaired";
    EBMLId[EBMLId["FlagVisualImpaired"] = 21932] = "FlagVisualImpaired";
    EBMLId[EBMLId["FlagCommentary"] = 21935] = "FlagCommentary";
    EBMLId[EBMLId["FlagLacing"] = 156] = "FlagLacing";
    EBMLId[EBMLId["Name"] = 21358] = "Name";
    EBMLId[EBMLId["Language"] = 2274716] = "Language";
    EBMLId[EBMLId["LanguageBCP47"] = 2274717] = "LanguageBCP47";
    EBMLId[EBMLId["CodecID"] = 134] = "CodecID";
    EBMLId[EBMLId["CodecPrivate"] = 25506] = "CodecPrivate";
    EBMLId[EBMLId["CodecDelay"] = 22186] = "CodecDelay";
    EBMLId[EBMLId["SeekPreRoll"] = 22203] = "SeekPreRoll";
    EBMLId[EBMLId["DefaultDuration"] = 2352003] = "DefaultDuration";
    EBMLId[EBMLId["Video"] = 224] = "Video";
    EBMLId[EBMLId["PixelWidth"] = 176] = "PixelWidth";
    EBMLId[EBMLId["PixelHeight"] = 186] = "PixelHeight";
    EBMLId[EBMLId["AlphaMode"] = 21440] = "AlphaMode";
    EBMLId[EBMLId["Audio"] = 225] = "Audio";
    EBMLId[EBMLId["SamplingFrequency"] = 181] = "SamplingFrequency";
    EBMLId[EBMLId["Channels"] = 159] = "Channels";
    EBMLId[EBMLId["BitDepth"] = 25188] = "BitDepth";
    EBMLId[EBMLId["SimpleBlock"] = 163] = "SimpleBlock";
    EBMLId[EBMLId["BlockGroup"] = 160] = "BlockGroup";
    EBMLId[EBMLId["Block"] = 161] = "Block";
    EBMLId[EBMLId["BlockAdditions"] = 30113] = "BlockAdditions";
    EBMLId[EBMLId["BlockMore"] = 166] = "BlockMore";
    EBMLId[EBMLId["BlockAdditional"] = 165] = "BlockAdditional";
    EBMLId[EBMLId["BlockAddID"] = 238] = "BlockAddID";
    EBMLId[EBMLId["BlockDuration"] = 155] = "BlockDuration";
    EBMLId[EBMLId["ReferenceBlock"] = 251] = "ReferenceBlock";
    EBMLId[EBMLId["Cluster"] = 524531317] = "Cluster";
    EBMLId[EBMLId["Timestamp"] = 231] = "Timestamp";
    EBMLId[EBMLId["Cues"] = 475249515] = "Cues";
    EBMLId[EBMLId["CuePoint"] = 187] = "CuePoint";
    EBMLId[EBMLId["CueTime"] = 179] = "CueTime";
    EBMLId[EBMLId["CueTrackPositions"] = 183] = "CueTrackPositions";
    EBMLId[EBMLId["CueTrack"] = 247] = "CueTrack";
    EBMLId[EBMLId["CueClusterPosition"] = 241] = "CueClusterPosition";
    EBMLId[EBMLId["Colour"] = 21936] = "Colour";
    EBMLId[EBMLId["MatrixCoefficients"] = 21937] = "MatrixCoefficients";
    EBMLId[EBMLId["TransferCharacteristics"] = 21946] = "TransferCharacteristics";
    EBMLId[EBMLId["Primaries"] = 21947] = "Primaries";
    EBMLId[EBMLId["Range"] = 21945] = "Range";
    EBMLId[EBMLId["Projection"] = 30320] = "Projection";
    EBMLId[EBMLId["ProjectionType"] = 30321] = "ProjectionType";
    EBMLId[EBMLId["ProjectionPoseRoll"] = 30325] = "ProjectionPoseRoll";
    EBMLId[EBMLId["Attachments"] = 423732329] = "Attachments";
    EBMLId[EBMLId["AttachedFile"] = 24999] = "AttachedFile";
    EBMLId[EBMLId["FileDescription"] = 18046] = "FileDescription";
    EBMLId[EBMLId["FileName"] = 18030] = "FileName";
    EBMLId[EBMLId["FileMediaType"] = 18016] = "FileMediaType";
    EBMLId[EBMLId["FileData"] = 18012] = "FileData";
    EBMLId[EBMLId["FileUID"] = 18094] = "FileUID";
    EBMLId[EBMLId["Chapters"] = 272869232] = "Chapters";
    EBMLId[EBMLId["Tags"] = 307544935] = "Tags";
    EBMLId[EBMLId["Tag"] = 29555] = "Tag";
    EBMLId[EBMLId["Targets"] = 25536] = "Targets";
    EBMLId[EBMLId["TargetTypeValue"] = 26826] = "TargetTypeValue";
    EBMLId[EBMLId["TargetType"] = 25546] = "TargetType";
    EBMLId[EBMLId["TagTrackUID"] = 25541] = "TagTrackUID";
    EBMLId[EBMLId["TagEditionUID"] = 25545] = "TagEditionUID";
    EBMLId[EBMLId["TagChapterUID"] = 25540] = "TagChapterUID";
    EBMLId[EBMLId["TagAttachmentUID"] = 25542] = "TagAttachmentUID";
    EBMLId[EBMLId["SimpleTag"] = 26568] = "SimpleTag";
    EBMLId[EBMLId["TagName"] = 17827] = "TagName";
    EBMLId[EBMLId["TagLanguage"] = 17530] = "TagLanguage";
    EBMLId[EBMLId["TagString"] = 17543] = "TagString";
    EBMLId[EBMLId["TagBinary"] = 17541] = "TagBinary";
    EBMLId[EBMLId["ContentEncodings"] = 28032] = "ContentEncodings";
    EBMLId[EBMLId["ContentEncoding"] = 25152] = "ContentEncoding";
    EBMLId[EBMLId["ContentEncodingOrder"] = 20529] = "ContentEncodingOrder";
    EBMLId[EBMLId["ContentEncodingScope"] = 20530] = "ContentEncodingScope";
    EBMLId[EBMLId["ContentCompression"] = 20532] = "ContentCompression";
    EBMLId[EBMLId["ContentCompAlgo"] = 16980] = "ContentCompAlgo";
    EBMLId[EBMLId["ContentCompSettings"] = 16981] = "ContentCompSettings";
    EBMLId[EBMLId["ContentEncryption"] = 20533] = "ContentEncryption";
})(EBMLId || (EBMLId = {}));
const LEVEL_0_EBML_IDS = [
    EBMLId.EBML,
    EBMLId.Segment
];
const LEVEL_1_EBML_IDS = [
    EBMLId.SeekHead,
    EBMLId.Info,
    EBMLId.Cluster,
    EBMLId.Tracks,
    EBMLId.Cues,
    EBMLId.Attachments,
    EBMLId.Chapters,
    EBMLId.Tags
];
const LEVEL_0_AND_1_EBML_IDS = [
    ...LEVEL_0_EBML_IDS,
    ...LEVEL_1_EBML_IDS
];
const measureUnsignedInt = (value)=>{
    if (value < 1 << 8) {
        return 1;
    } else if (value < 1 << 16) {
        return 2;
    } else if (value < 1 << 24) {
        return 3;
    } else if (value < 2 ** 32) {
        return 4;
    } else if (value < 2 ** 40) {
        return 5;
    } else {
        return 6;
    }
};
const measureUnsignedBigInt = (value)=>{
    if (value < 1n << 8n) {
        return 1;
    } else if (value < 1n << 16n) {
        return 2;
    } else if (value < 1n << 24n) {
        return 3;
    } else if (value < 1n << 32n) {
        return 4;
    } else if (value < 1n << 40n) {
        return 5;
    } else if (value < 1n << 48n) {
        return 6;
    } else if (value < 1n << 56n) {
        return 7;
    } else {
        return 8;
    }
};
const measureSignedInt = (value)=>{
    if (value >= -(1 << 6) && value < 1 << 6) {
        return 1;
    } else if (value >= -(1 << 13) && value < 1 << 13) {
        return 2;
    } else if (value >= -(1 << 20) && value < 1 << 20) {
        return 3;
    } else if (value >= -(1 << 27) && value < 1 << 27) {
        return 4;
    } else if (value >= -(2 ** 34) && value < 2 ** 34) {
        return 5;
    } else {
        return 6;
    }
};
const measureVarInt = (value)=>{
    if (value < (1 << 7) - 1) {
        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store
         * 127 because "all bits set to one" is a reserved value. Same thing for the
         * other cases below:
         */ return 1;
    } else if (value < (1 << 14) - 1) {
        return 2;
    } else if (value < (1 << 21) - 1) {
        return 3;
    } else if (value < (1 << 28) - 1) {
        return 4;
    } else if (value < 2 ** 35 - 1) {
        return 5;
    } else if (value < 2 ** 42 - 1) {
        return 6;
    } else {
        throw new Error('EBML varint size not supported ' + value);
    }
};
class EBMLWriter {
    constructor(writer){
        this.writer = writer;
        this.helper = new Uint8Array(8);
        this.helperView = new DataView(this.helper.buffer);
        /**
         * Stores the position from the start of the file to where EBML elements have been written. This is used to
         * rewrite/edit elements that were already added before, and to measure sizes of things.
         */ this.offsets = new WeakMap();
        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */ this.dataOffsets = new WeakMap();
    }
    writeByte(value) {
        this.helperView.setUint8(0, value);
        this.writer.write(this.helper.subarray(0, 1));
    }
    writeFloat32(value) {
        this.helperView.setFloat32(0, value, false);
        this.writer.write(this.helper.subarray(0, 4));
    }
    writeFloat64(value) {
        this.helperView.setFloat64(0, value, false);
        this.writer.write(this.helper);
    }
    writeUnsignedInt(value, width = measureUnsignedInt(value)) {
        let pos = 0;
        // Each case falls through:
        switch(width){
            case 6:
                // Need to use division to access >32 bits of floating point var
                this.helperView.setUint8(pos++, value / 2 ** 40 | 0);
            // eslint-disable-next-line no-fallthrough
            case 5:
                this.helperView.setUint8(pos++, value / 2 ** 32 | 0);
            // eslint-disable-next-line no-fallthrough
            case 4:
                this.helperView.setUint8(pos++, value >> 24);
            // eslint-disable-next-line no-fallthrough
            case 3:
                this.helperView.setUint8(pos++, value >> 16);
            // eslint-disable-next-line no-fallthrough
            case 2:
                this.helperView.setUint8(pos++, value >> 8);
            // eslint-disable-next-line no-fallthrough
            case 1:
                this.helperView.setUint8(pos++, value);
                break;
            default:
                throw new Error('Bad unsigned int size ' + width);
        }
        this.writer.write(this.helper.subarray(0, pos));
    }
    writeUnsignedBigInt(value, width = measureUnsignedBigInt(value)) {
        let pos = 0;
        for(let i = width - 1; i >= 0; i--){
            this.helperView.setUint8(pos++, Number(value >> BigInt(i * 8) & 0xffn));
        }
        this.writer.write(this.helper.subarray(0, pos));
    }
    writeSignedInt(value, width = measureSignedInt(value)) {
        if (value < 0) {
            // Two's complement stuff
            value += 2 ** (width * 8);
        }
        this.writeUnsignedInt(value, width);
    }
    writeVarInt(value, width = measureVarInt(value)) {
        let pos = 0;
        switch(width){
            case 1:
                this.helperView.setUint8(pos++, 1 << 7 | value);
                break;
            case 2:
                this.helperView.setUint8(pos++, 1 << 6 | value >> 8);
                this.helperView.setUint8(pos++, value);
                break;
            case 3:
                this.helperView.setUint8(pos++, 1 << 5 | value >> 16);
                this.helperView.setUint8(pos++, value >> 8);
                this.helperView.setUint8(pos++, value);
                break;
            case 4:
                this.helperView.setUint8(pos++, 1 << 4 | value >> 24);
                this.helperView.setUint8(pos++, value >> 16);
                this.helperView.setUint8(pos++, value >> 8);
                this.helperView.setUint8(pos++, value);
                break;
            case 5:
                /**
                 * JavaScript converts its doubles to 32-bit integers for bitwise
                 * operations, so we need to do a division by 2^32 instead of a
                 * right-shift of 32 to retain those top 3 bits
                 */ this.helperView.setUint8(pos++, 1 << 3 | value / 2 ** 32 & 0x7);
                this.helperView.setUint8(pos++, value >> 24);
                this.helperView.setUint8(pos++, value >> 16);
                this.helperView.setUint8(pos++, value >> 8);
                this.helperView.setUint8(pos++, value);
                break;
            case 6:
                this.helperView.setUint8(pos++, 1 << 2 | value / 2 ** 40 & 0x3);
                this.helperView.setUint8(pos++, value / 2 ** 32 | 0);
                this.helperView.setUint8(pos++, value >> 24);
                this.helperView.setUint8(pos++, value >> 16);
                this.helperView.setUint8(pos++, value >> 8);
                this.helperView.setUint8(pos++, value);
                break;
            default:
                throw new Error('Bad EBML varint size ' + width);
        }
        this.writer.write(this.helper.subarray(0, pos));
    }
    writeAsciiString(str) {
        this.writer.write(new Uint8Array(str.split('').map((x)=>x.charCodeAt(0))));
    }
    writeEBML(data) {
        if (data === null) return;
        if (data instanceof Uint8Array) {
            this.writer.write(data);
        } else if (Array.isArray(data)) {
            for (const elem of data){
                this.writeEBML(elem);
            }
        } else {
            this.offsets.set(data, this.writer.getPos());
            this.writeUnsignedInt(data.id); // ID field
            if (Array.isArray(data.data)) {
                const sizePos = this.writer.getPos();
                const sizeSize = data.size === -1 ? 1 : data.size ?? 4;
                if (data.size === -1) {
                    // Write the reserved all-one-bits marker for unknown/unbounded size.
                    this.writeByte(0xff);
                } else {
                    this.writer.seek(this.writer.getPos() + sizeSize);
                }
                const startPos = this.writer.getPos();
                this.dataOffsets.set(data, startPos);
                this.writeEBML(data.data);
                if (data.size !== -1) {
                    const size = this.writer.getPos() - startPos;
                    const endPos = this.writer.getPos();
                    this.writer.seek(sizePos);
                    this.writeVarInt(size, sizeSize);
                    this.writer.seek(endPos);
                }
            } else if (typeof data.data === 'number') {
                const size = data.size ?? measureUnsignedInt(data.data);
                this.writeVarInt(size);
                this.writeUnsignedInt(data.data, size);
            } else if (typeof data.data === 'bigint') {
                const size = data.size ?? measureUnsignedBigInt(data.data);
                this.writeVarInt(size);
                this.writeUnsignedBigInt(data.data, size);
            } else if (typeof data.data === 'string') {
                this.writeVarInt(data.data.length);
                this.writeAsciiString(data.data);
            } else if (data.data instanceof Uint8Array) {
                this.writeVarInt(data.data.byteLength, data.size);
                this.writer.write(data.data);
            } else if (data.data instanceof EBMLFloat32) {
                this.writeVarInt(4);
                this.writeFloat32(data.data.value);
            } else if (data.data instanceof EBMLFloat64) {
                this.writeVarInt(8);
                this.writeFloat64(data.data.value);
            } else if (data.data instanceof EBMLSignedInt) {
                const size = data.size ?? measureSignedInt(data.data.value);
                this.writeVarInt(size);
                this.writeSignedInt(data.data.value, size);
            } else if (data.data instanceof EBMLUnicodeString) {
                const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(data.data.value);
                this.writeVarInt(bytes.length);
                this.writer.write(bytes);
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertNever"])(data.data);
            }
        }
    }
}
const MAX_VAR_INT_SIZE = 8;
const MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size
const MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size
const readVarIntSize = (slice)=>{
    const firstByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
    slice.skip(-1);
    if (firstByte === 0) {
        return null; // Invalid VINT
    }
    let width = 1;
    let mask = 0x80;
    while((firstByte & mask) === 0){
        width++;
        mask >>= 1;
    }
    return width;
};
const readVarInt = (slice)=>{
    // Read the first byte to determine the width of the variable-length integer
    const firstByte = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
    if (firstByte === 0) {
        return null; // Invalid VINT
    }
    // Find the position of VINT_MARKER, which determines the width
    let width = 1;
    let mask = 1 << 7;
    while((firstByte & mask) === 0){
        width++;
        mask >>= 1;
    }
    // First byte's value needs the marker bit cleared
    let value = firstByte & mask - 1;
    // Read remaining bytes
    for(let i = 1; i < width; i++){
        value *= 1 << 8;
        value += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
    }
    return value;
};
const readUnsignedInt = (slice, width)=>{
    if (width < 1 || width > 8) {
        throw new Error('Bad unsigned int size ' + width);
    }
    let value = 0;
    // Read bytes from most significant to least significant
    for(let i = 0; i < width; i++){
        value *= 1 << 8;
        value += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
    }
    return value;
};
const readUnsignedBigInt = (slice, width)=>{
    if (width < 1) {
        throw new Error('Bad unsigned int size ' + width);
    }
    let value = 0n;
    for(let i = 0; i < width; i++){
        value <<= 8n;
        value += BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice));
    }
    return value;
};
const readSignedInt = (slice, width)=>{
    let value = readUnsignedInt(slice, width);
    // If the highest bit is set, convert from two's complement
    if (value & 1 << width * 8 - 1) {
        value -= 2 ** (width * 8);
    }
    return value;
};
const readElementId = (slice)=>{
    const size = readVarIntSize(slice);
    if (size === null) {
        return null;
    }
    const id = readUnsignedInt(slice, size);
    return id;
};
const readElementSize = (slice)=>{
    let size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
    if (size === 0xff) {
        size = null;
    } else {
        slice.skip(-1);
        size = readVarInt(slice);
        // In some (livestreamed) files, this is the value of the size field. While this technically is just a very
        // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We
        // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works
        // nonetheless.
        // eslint-disable-next-line no-loss-of-precision
        if (size === 0x00ffffffffffffff) {
            size = null;
        }
    }
    return size;
};
const readElementHeader = (slice)=>{
    const id = readElementId(slice);
    if (id === null) {
        return null;
    }
    const size = readElementSize(slice);
    return {
        id,
        size
    };
};
const readAsciiString = (slice, length)=>{
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, length);
    // Actual string length might be shorter due to null terminators
    let strLength = 0;
    while(strLength < length && bytes[strLength] !== 0){
        strLength += 1;
    }
    return String.fromCharCode(...bytes.subarray(0, strLength));
};
const readUnicodeString = (slice, length)=>{
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, length);
    // Actual string length might be shorter due to null terminators
    let strLength = 0;
    while(strLength < length && bytes[strLength] !== 0){
        strLength += 1;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecoder"].decode(bytes.subarray(0, strLength));
};
const readFloat = (slice, width)=>{
    if (width === 0) {
        return 0;
    }
    if (width !== 4 && width !== 8) {
        throw new Error('Bad float size ' + width);
    }
    return width === 4 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readF32Be"])(slice) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readF64Be"])(slice);
};
const searchForNextElementId = async (reader, startPos, ids, until)=>{
    const idsSet = new Set(ids);
    let currentPos = startPos;
    while(until === null || currentPos < until){
        let slice = reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);
        if (slice instanceof Promise) slice = await slice;
        if (!slice) break;
        const elementHeader = readElementHeader(slice);
        if (!elementHeader) {
            break;
        }
        if (idsSet.has(elementHeader.id)) {
            return {
                pos: currentPos,
                found: true
            };
        }
        assertDefinedSize(elementHeader.size);
        currentPos = slice.filePos + elementHeader.size;
    }
    return {
        pos: until !== null && until > currentPos ? until : currentPos,
        found: false
    };
};
const resync = async (reader, startPos, ids, until)=>{
    const CHUNK_SIZE = 2 ** 16; // So we don't need to grab thousands of slices
    const idsSet = new Set(ids);
    let currentPos = startPos;
    while(currentPos < until){
        let slice = reader.requestSliceRange(currentPos, 0, Math.min(CHUNK_SIZE, until - currentPos));
        if (slice instanceof Promise) slice = await slice;
        if (!slice) break;
        if (slice.length < MAX_VAR_INT_SIZE) break;
        for(let i = 0; i < slice.length - MAX_VAR_INT_SIZE; i++){
            slice.filePos = currentPos;
            const elementId = readElementId(slice);
            if (elementId !== null && idsSet.has(elementId)) {
                return currentPos;
            }
            currentPos++;
        }
    }
    return null;
};
const CODEC_STRING_MAP = {
    'avc': 'V_MPEG4/ISO/AVC',
    'hevc': 'V_MPEGH/ISO/HEVC',
    'vp8': 'V_VP8',
    'vp9': 'V_VP9',
    'av1': 'V_AV1',
    'aac': 'A_AAC',
    'mp3': 'A_MPEG/L3',
    'opus': 'A_OPUS',
    'vorbis': 'A_VORBIS',
    'flac': 'A_FLAC',
    'pcm-u8': 'A_PCM/INT/LIT',
    'pcm-s16': 'A_PCM/INT/LIT',
    'pcm-s16be': 'A_PCM/INT/BIG',
    'pcm-s24': 'A_PCM/INT/LIT',
    'pcm-s24be': 'A_PCM/INT/BIG',
    'pcm-s32': 'A_PCM/INT/LIT',
    'pcm-s32be': 'A_PCM/INT/BIG',
    'pcm-f32': 'A_PCM/FLOAT/IEEE',
    'pcm-f64': 'A_PCM/FLOAT/IEEE',
    'webvtt': 'S_TEXT/WEBVTT'
};
function assertDefinedSize(size) {
    if (size === null) {
        throw new Error('Undefined element size is used in a place where it is not supported.');
    }
}
;
}),
"[project]/node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "buildMatroskaMimeType",
    ()=>buildMatroskaMimeType
]);
const buildMatroskaMimeType = (info)=>{
    const base = info.hasVideo ? 'video/' : info.hasAudio ? 'audio/' : 'application/';
    let string = base + (info.isWebM ? 'webm' : 'x-matroska');
    if (info.codecStrings.length > 0) {
        const uniqueCodecMimeTypes = [
            ...new Set(info.codecStrings.filter(Boolean))
        ];
        string += `; codecs="${uniqueCodecMimeTypes.join(', ')}"`;
    }
    return string;
};
}),
"[project]/node_modules/mediabunny/dist/modules/src/matroska/matroska-demuxer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "MatroskaDemuxer",
    ()=>MatroskaDemuxer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec-data.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$demuxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/demuxer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/input-track.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/metadata.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/packet.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/matroska/ebml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$matroska$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/reader.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var BlockLacing;
(function(BlockLacing) {
    BlockLacing[BlockLacing["None"] = 0] = "None";
    BlockLacing[BlockLacing["Xiph"] = 1] = "Xiph";
    BlockLacing[BlockLacing["FixedSize"] = 2] = "FixedSize";
    BlockLacing[BlockLacing["Ebml"] = 3] = "Ebml";
})(BlockLacing || (BlockLacing = {}));
var ContentEncodingScope;
(function(ContentEncodingScope) {
    ContentEncodingScope[ContentEncodingScope["Block"] = 1] = "Block";
    ContentEncodingScope[ContentEncodingScope["Private"] = 2] = "Private";
    ContentEncodingScope[ContentEncodingScope["Next"] = 4] = "Next";
})(ContentEncodingScope || (ContentEncodingScope = {}));
var ContentCompAlgo;
(function(ContentCompAlgo) {
    ContentCompAlgo[ContentCompAlgo["Zlib"] = 0] = "Zlib";
    ContentCompAlgo[ContentCompAlgo["Bzlib"] = 1] = "Bzlib";
    ContentCompAlgo[ContentCompAlgo["lzo1x"] = 2] = "lzo1x";
    ContentCompAlgo[ContentCompAlgo["HeaderStripping"] = 3] = "HeaderStripping";
})(ContentCompAlgo || (ContentCompAlgo = {}));
const METADATA_ELEMENTS = [
    {
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekHead,
        flag: 'seekHeadSeen'
    },
    {
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Info,
        flag: 'infoSeen'
    },
    {
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tracks,
        flag: 'tracksSeen'
    },
    {
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cues,
        flag: 'cuesSeen'
    }
];
const MAX_RESYNC_LENGTH = 10 * 2 ** 20; // 10 MiB
class MatroskaDemuxer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$demuxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Demuxer"] {
    constructor(input){
        super(input);
        this.readMetadataPromise = null;
        this.segments = [];
        this.currentSegment = null;
        this.currentTrack = null;
        this.currentCluster = null;
        this.currentBlock = null;
        this.currentBlockAdditional = null;
        this.currentCueTime = null;
        this.currentDecodingInstruction = null;
        this.currentTagTargetIsMovie = true;
        this.currentSimpleTagName = null;
        this.currentAttachedFile = null;
        this.isWebM = false;
        this.reader = input._reader;
    }
    async computeDuration() {
        const tracks = await this.getTracks();
        const trackDurations = await Promise.all(tracks.map((x)=>x.computeDuration()));
        return Math.max(0, ...trackDurations);
    }
    async getTracks() {
        await this.readMetadata();
        return this.segments.flatMap((segment)=>segment.tracks.map((track)=>track.inputTrack));
    }
    async getMimeType() {
        await this.readMetadata();
        const tracks = await this.getTracks();
        const codecStrings = await Promise.all(tracks.map((x)=>x.getCodecParameterString()));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$matroska$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatroskaMimeType"])({
            isWebM: this.isWebM,
            hasVideo: this.segments.some((segment)=>segment.tracks.some((x)=>x.info?.type === 'video')),
            hasAudio: this.segments.some((segment)=>segment.tracks.some((x)=>x.info?.type === 'audio')),
            codecStrings: codecStrings.filter(Boolean)
        });
    }
    async getMetadataTags() {
        await this.readMetadata();
        // Load metadata tags from each segment lazily (only once)
        for (const segment of this.segments){
            if (!segment.metadataTagsCollected) {
                if (this.reader.fileSize !== null) {
                    await this.loadSegmentMetadata(segment);
                } else {
                // The seeking would be too crazy, let's not
                }
                segment.metadataTagsCollected = true;
            }
        }
        // This is kinda handwavy, and how we handle multiple segments isn't suuuuper well-defined anyway; so we just
        // shallow-merge metadata tags from all (usually just one) segments.
        let metadataTags = {};
        for (const segment of this.segments){
            metadataTags = {
                ...metadataTags,
                ...segment.metadataTags
            };
        }
        return metadataTags;
    }
    readMetadata() {
        return this.readMetadataPromise ??= (async ()=>{
            let currentPos = 0;
            // Loop over all top-level elements in the file
            while(true){
                let slice = this.reader.requestSliceRange(currentPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
                if (slice instanceof Promise) slice = await slice;
                if (!slice) break;
                const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
                if (!header) {
                    break; // Zero padding at the end of the file triggers this, for example
                }
                const id = header.id;
                let size = header.size;
                const dataStartPos = slice.filePos;
                if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBML) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
                    let slice = this.reader.requestSlice(dataStartPos, size);
                    if (slice instanceof Promise) slice = await slice;
                    if (!slice) break;
                    this.readContiguousElements(slice);
                } else if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Segment) {
                    await this.readSegment(dataStartPos, size);
                    if (size === null) {
                        break;
                    }
                    if (this.reader.fileSize === null) {
                        break; // Stop at the first segment
                    }
                } else if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster) {
                    if (this.reader.fileSize === null) {
                        break; // Shouldn't be reached anyway, since we stop at the first segment
                    }
                    // Clusters are not a top-level element in Matroska, but some files contain a Segment whose size
                    // doesn't contain any of the clusters that follow it. In the case, we apply the following logic: if
                    // we find a top-level cluster, attribute it to the previous segment.
                    if (size === null) {
                        // Just in case this is one of those weird sizeless clusters, let's do our best and still try to
                        // determine its size.
                        const nextElementPos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchForNextElementId"])(this.reader, dataStartPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_0_AND_1_EBML_IDS"], this.reader.fileSize);
                        size = nextElementPos.pos - dataStartPos;
                    }
                    const lastSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(this.segments);
                    if (lastSegment) {
                        // Extend the previous segment's size
                        lastSegment.elementEndPos = dataStartPos + size;
                    }
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
                currentPos = dataStartPos + size;
            }
        })();
    }
    async readSegment(segmentDataStart, dataSize) {
        this.currentSegment = {
            seekHeadSeen: false,
            infoSeen: false,
            tracksSeen: false,
            cuesSeen: false,
            tagsSeen: false,
            attachmentsSeen: false,
            timestampScale: -1,
            timestampFactor: -1,
            duration: -1,
            seekEntries: [],
            tracks: [],
            cuePoints: [],
            dataStartPos: segmentDataStart,
            elementEndPos: dataSize === null ? null // Assume it goes until the end of the file
             : segmentDataStart + dataSize,
            clusterSeekStartPos: segmentDataStart,
            lastReadCluster: null,
            metadataTags: {},
            metadataTagsCollected: false
        };
        this.segments.push(this.currentSegment);
        let currentPos = segmentDataStart;
        while(this.currentSegment.elementEndPos === null || currentPos < this.currentSegment.elementEndPos){
            let slice = this.reader.requestSliceRange(currentPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
            if (slice instanceof Promise) slice = await slice;
            if (!slice) break;
            const elementStartPos = currentPos;
            const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
            if (!header || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_1_EBML_IDS"].includes(header.id) && header.id !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Void) {
                // Potential junk. Let's try to resync
                const nextPos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resync"])(this.reader, elementStartPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_1_EBML_IDS"], Math.min(this.currentSegment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));
                if (nextPos) {
                    currentPos = nextPos;
                    continue;
                } else {
                    break; // Resync failed
                }
            }
            const { id, size } = header;
            const dataStartPos = slice.filePos;
            const metadataElementIndex = METADATA_ELEMENTS.findIndex((x)=>x.id === id);
            if (metadataElementIndex !== -1) {
                const field = METADATA_ELEMENTS[metadataElementIndex].flag;
                this.currentSegment[field] = true;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
                let slice = this.reader.requestSlice(dataStartPos, size);
                if (slice instanceof Promise) slice = await slice;
                if (slice) {
                    this.readContiguousElements(slice);
                }
            } else if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tags || id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Attachments) {
                // Metadata found at the beginning of the segment, great, let's parse it
                if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tags) {
                    this.currentSegment.tagsSeen = true;
                } else {
                    this.currentSegment.attachmentsSeen = true;
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
                let slice = this.reader.requestSlice(dataStartPos, size);
                if (slice instanceof Promise) slice = await slice;
                if (slice) {
                    this.readContiguousElements(slice);
                }
            } else if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster) {
                this.currentSegment.clusterSeekStartPos = elementStartPos;
                break; // Stop at the first cluster
            }
            if (size === null) {
                break;
            } else {
                currentPos = dataStartPos + size;
            }
        }
        // Sort the seek entries by file position so reading them exhibits a sequential pattern
        this.currentSegment.seekEntries.sort((a, b)=>a.segmentPosition - b.segmentPosition);
        if (this.reader.fileSize !== null) {
            // Use the seek head to read missing metadata elements
            for (const seekEntry of this.currentSegment.seekEntries){
                const target = METADATA_ELEMENTS.find((x)=>x.id === seekEntry.id);
                if (!target) {
                    continue;
                }
                if (this.currentSegment[target.flag]) continue;
                let slice = this.reader.requestSliceRange(segmentDataStart + seekEntry.segmentPosition, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
                if (slice instanceof Promise) slice = await slice;
                if (!slice) continue;
                const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
                if (!header) continue;
                const { id, size } = header;
                if (id !== target.id) continue;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
                this.currentSegment[target.flag] = true;
                let dataSlice = this.reader.requestSlice(slice.filePos, size);
                if (dataSlice instanceof Promise) dataSlice = await dataSlice;
                if (!dataSlice) continue;
                this.readContiguousElements(dataSlice);
            }
        }
        if (this.currentSegment.timestampScale === -1) {
            // TimestampScale element is missing. Technically an invalid file, but let's default to the typical value,
            // which is 1e6.
            this.currentSegment.timestampScale = 1e6;
            this.currentSegment.timestampFactor = 1e9 / 1e6;
        }
        // Put default tracks first
        this.currentSegment.tracks.sort((a, b)=>Number(b.disposition.default) - Number(a.disposition.default));
        // Now, let's distribute the cue points to the tracks
        const idToTrack = new Map(this.currentSegment.tracks.map((x)=>[
                x.id,
                x
            ]));
        // Assign cue points to their respective tracks
        for (const cuePoint of this.currentSegment.cuePoints){
            const track = idToTrack.get(cuePoint.trackId);
            if (track) {
                track.cuePoints.push(cuePoint);
            }
        }
        for (const track of this.currentSegment.tracks){
            // Sort cue points by time
            track.cuePoints.sort((a, b)=>a.time - b.time);
            // Remove multiple cue points for the same time
            for(let i = 0; i < track.cuePoints.length - 1; i++){
                const cuePoint1 = track.cuePoints[i];
                const cuePoint2 = track.cuePoints[i + 1];
                if (cuePoint1.time === cuePoint2.time) {
                    track.cuePoints.splice(i + 1, 1);
                    i--;
                }
            }
        }
        let trackWithMostCuePoints = null;
        let maxCuePointCount = -Infinity;
        for (const track of this.currentSegment.tracks){
            if (track.cuePoints.length > maxCuePointCount) {
                maxCuePointCount = track.cuePoints.length;
                trackWithMostCuePoints = track;
            }
        }
        // For every track that has received 0 cue points (can happen, often only the video track receives cue points),
        // we still want to have better seeking. Therefore, let's give it the cue points of the track with the most cue
        // points, which should provide us with the most fine-grained seeking.
        for (const track of this.currentSegment.tracks){
            if (track.cuePoints.length === 0) {
                track.cuePoints = trackWithMostCuePoints.cuePoints;
            }
        }
        this.currentSegment = null;
    }
    async readCluster(startPos, segment) {
        if (segment.lastReadCluster?.elementStartPos === startPos) {
            return segment.lastReadCluster;
        }
        let headerSlice = this.reader.requestSliceRange(startPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
        if (headerSlice instanceof Promise) headerSlice = await headerSlice;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(headerSlice);
        const elementStartPos = startPos;
        const elementHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(headerSlice);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(elementHeader);
        const id = elementHeader.id;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster);
        let size = elementHeader.size;
        const dataStartPos = headerSlice.filePos;
        if (size === null) {
            // The cluster's size is undefined (can happen in livestreamed files). We'd still like to know the size of
            // it, so we have no other choice but to iterate over the EBML structure until we find an element at level
            // 0 or 1, indicating the end of the cluster (all elements inside the cluster are at level 2).
            const nextElementPos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchForNextElementId"])(this.reader, dataStartPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_0_AND_1_EBML_IDS"], segment.elementEndPos);
            size = nextElementPos.pos - dataStartPos;
        }
        // Load the entire cluster
        let dataSlice = this.reader.requestSlice(dataStartPos, size);
        if (dataSlice instanceof Promise) dataSlice = await dataSlice;
        const cluster = {
            segment,
            elementStartPos,
            elementEndPos: dataStartPos + size,
            dataStartPos,
            timestamp: -1,
            trackData: new Map()
        };
        this.currentCluster = cluster;
        if (dataSlice) {
            // Read the children of the cluster, stopping early at level 0 or 1 EBML elements. We do this because some
            // clusters have incorrect sizes that are too large
            const endPos = this.readContiguousElements(dataSlice, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_0_AND_1_EBML_IDS"]);
            cluster.elementEndPos = endPos;
        }
        for (const [, trackData] of cluster.trackData){
            const track = trackData.track;
            // This must hold, as track datas only get created if a block for that track is encountered
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(trackData.blocks.length > 0);
            let hasLacedBlocks = false;
            for(let i = 0; i < trackData.blocks.length; i++){
                const block = trackData.blocks[i];
                block.timestamp += cluster.timestamp;
                hasLacedBlocks ||= block.lacing !== BlockLacing.None;
            }
            trackData.presentationTimestamps = trackData.blocks.map((block, i)=>({
                    timestamp: block.timestamp,
                    blockIndex: i
                })).sort((a, b)=>a.timestamp - b.timestamp);
            for(let i = 0; i < trackData.presentationTimestamps.length; i++){
                const currentEntry = trackData.presentationTimestamps[i];
                const currentBlock = trackData.blocks[currentEntry.blockIndex];
                if (trackData.firstKeyFrameTimestamp === null && currentBlock.isKeyFrame) {
                    trackData.firstKeyFrameTimestamp = currentBlock.timestamp;
                }
                if (i < trackData.presentationTimestamps.length - 1) {
                    // Update block durations based on presentation order
                    const nextEntry = trackData.presentationTimestamps[i + 1];
                    currentBlock.duration = nextEntry.timestamp - currentBlock.timestamp;
                } else if (currentBlock.duration === 0) {
                    if (track.defaultDuration != null) {
                        if (currentBlock.lacing === BlockLacing.None) {
                            currentBlock.duration = track.defaultDuration;
                        } else {
                        // Handled by the lace resolution code
                        }
                    }
                }
            }
            if (hasLacedBlocks) {
                // Perform lace resolution. Here, we expand each laced block into multiple blocks where each contains
                // one frame of the lace. We do this after determining block timestamps so we can properly distribute
                // the block's duration across the laced frames.
                this.expandLacedBlocks(trackData.blocks, track);
                // Recompute since blocks have changed
                trackData.presentationTimestamps = trackData.blocks.map((block, i)=>({
                        timestamp: block.timestamp,
                        blockIndex: i
                    })).sort((a, b)=>a.timestamp - b.timestamp);
            }
            const firstBlock = trackData.blocks[trackData.presentationTimestamps[0].blockIndex];
            const lastBlock = trackData.blocks[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["last"])(trackData.presentationTimestamps).blockIndex];
            trackData.startTimestamp = firstBlock.timestamp;
            trackData.endTimestamp = lastBlock.timestamp + lastBlock.duration;
            // Let's remember that a cluster with a given timestamp is here, speeding up future lookups if no cues exist
            const insertionIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(track.clusterPositionCache, trackData.startTimestamp, (x)=>x.startTimestamp);
            if (insertionIndex === -1 || track.clusterPositionCache[insertionIndex].elementStartPos !== elementStartPos) {
                track.clusterPositionCache.splice(insertionIndex + 1, 0, {
                    elementStartPos: cluster.elementStartPos,
                    startTimestamp: trackData.startTimestamp
                });
            }
        }
        segment.lastReadCluster = cluster;
        return cluster;
    }
    getTrackDataInCluster(cluster, trackNumber) {
        let trackData = cluster.trackData.get(trackNumber);
        if (!trackData) {
            const track = cluster.segment.tracks.find((x)=>x.id === trackNumber);
            if (!track) {
                return null;
            }
            trackData = {
                track,
                startTimestamp: 0,
                endTimestamp: 0,
                firstKeyFrameTimestamp: null,
                blocks: [],
                presentationTimestamps: []
            };
            cluster.trackData.set(trackNumber, trackData);
        }
        return trackData;
    }
    expandLacedBlocks(blocks, track) {
        // https://www.matroska.org/technical/notes.html#block-lacing
        for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){
            const originalBlock = blocks[blockIndex];
            if (originalBlock.lacing === BlockLacing.None) {
                continue;
            }
            // Decode the block data if it hasn't been decoded yet (needed for lacing expansion)
            if (!originalBlock.decoded) {
                originalBlock.data = this.decodeBlockData(track, originalBlock.data);
                originalBlock.decoded = true;
            }
            const slice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileSlice"].tempFromBytes(originalBlock.data);
            const frameSizes = [];
            const frameCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice) + 1;
            switch(originalBlock.lacing){
                case BlockLacing.Xiph:
                    {
                        let totalUsedSize = 0;
                        // Xiph lacing, just like in Ogg
                        for(let i = 0; i < frameCount - 1; i++){
                            let frameSize = 0;
                            while(slice.bufferPos < slice.length){
                                const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                                frameSize += value;
                                if (value < 255) {
                                    frameSizes.push(frameSize);
                                    totalUsedSize += frameSize;
                                    break;
                                }
                            }
                        }
                        // Compute the last frame's size from whatever's left
                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));
                    }
                    ;
                    break;
                case BlockLacing.FixedSize:
                    {
                        // Fixed size lacing: all frames have same size
                        const totalDataSize = slice.length - 1; // Minus the frame count byte
                        const frameSize = Math.floor(totalDataSize / frameCount);
                        for(let i = 0; i < frameCount; i++){
                            frameSizes.push(frameSize);
                        }
                    }
                    ;
                    break;
                case BlockLacing.Ebml:
                    {
                        // EBML lacing: first size absolute, subsequent ones are coded as signed differences from the last
                        const firstResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readVarInt"])(slice);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(firstResult !== null); // Assume it's not an invalid VINT
                        let currentSize = firstResult;
                        frameSizes.push(currentSize);
                        let totalUsedSize = currentSize;
                        for(let i = 1; i < frameCount - 1; i++){
                            const startPos = slice.bufferPos;
                            const diffResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readVarInt"])(slice);
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(diffResult !== null);
                            const unsignedDiff = diffResult;
                            const width = slice.bufferPos - startPos;
                            const bias = (1 << width * 7 - 1) - 1; // Typo-corrected version of 2^((7*n)-1)^-1
                            const diff = unsignedDiff - bias;
                            currentSize += diff;
                            frameSizes.push(currentSize);
                            totalUsedSize += currentSize;
                        }
                        // Compute the last frame's size from whatever's left
                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));
                    }
                    ;
                    break;
                default:
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(false);
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(frameSizes.length === frameCount);
            blocks.splice(blockIndex, 1); // Remove the original block
            const blockDuration = originalBlock.duration || frameCount * (track.defaultDuration ?? 0);
            // Now, let's insert each frame as its own block
            for(let i = 0; i < frameCount; i++){
                const frameSize = frameSizes[i];
                const frameData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, frameSize);
                // Distribute timestamps evenly across the block duration
                const frameTimestamp = originalBlock.timestamp + blockDuration * i / frameCount;
                const frameDuration = blockDuration / frameCount;
                blocks.splice(blockIndex + i, 0, {
                    timestamp: frameTimestamp,
                    duration: frameDuration,
                    isKeyFrame: originalBlock.isKeyFrame,
                    data: frameData,
                    lacing: BlockLacing.None,
                    decoded: true,
                    mainAdditional: originalBlock.mainAdditional
                });
            }
            blockIndex += frameCount; // Skip the blocks we just added
            blockIndex--;
        }
    }
    async loadSegmentMetadata(segment) {
        for (const seekEntry of segment.seekEntries){
            if (seekEntry.id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tags && !segment.tagsSeen) {
            // We need to load the tags
            } else if (seekEntry.id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Attachments && !segment.attachmentsSeen) {
            // We need to load the attachments
            } else {
                continue;
            }
            let slice = this.reader.requestSliceRange(segment.dataStartPos + seekEntry.segmentPosition, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
            if (slice instanceof Promise) slice = await slice;
            if (!slice) continue;
            const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
            if (!header || header.id !== seekEntry.id) continue;
            const { size } = header;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(!this.currentSegment);
            this.currentSegment = segment;
            let dataSlice = this.reader.requestSlice(slice.filePos, size);
            if (dataSlice instanceof Promise) dataSlice = await dataSlice;
            if (dataSlice) {
                this.readContiguousElements(dataSlice);
            }
            this.currentSegment = null;
            // Mark as seen
            if (seekEntry.id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tags) {
                segment.tagsSeen = true;
            } else if (seekEntry.id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Attachments) {
                segment.attachmentsSeen = true;
            }
        }
    }
    readContiguousElements(slice, stopIds) {
        const startIndex = slice.filePos;
        while(slice.filePos - startIndex <= slice.length - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"]){
            const startPos = slice.filePos;
            const foundElement = this.traverseElement(slice, stopIds);
            if (!foundElement) {
                return startPos;
            }
        }
        return slice.filePos;
    }
    traverseElement(slice, stopIds) {
        const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
        if (!header) {
            return false;
        }
        if (stopIds && stopIds.includes(header.id)) {
            return false;
        }
        const { id, size } = header;
        const dataStartPos = slice.filePos;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertDefinedSize"])(size);
        switch(id){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DocType:
                {
                    this.isWebM = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAsciiString"])(slice, size) === 'webm';
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek:
                {
                    if (!this.currentSegment) break;
                    const seekEntry = {
                        id: -1,
                        segmentPosition: -1
                    };
                    this.currentSegment.seekEntries.push(seekEntry);
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    if (seekEntry.id === -1 || seekEntry.segmentPosition === -1) {
                        this.currentSegment.seekEntries.pop();
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID:
                {
                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];
                    if (!lastSeekEntry) break;
                    lastSeekEntry.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition:
                {
                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];
                    if (!lastSeekEntry) break;
                    lastSeekEntry.segmentPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TimestampScale:
                {
                    if (!this.currentSegment) break;
                    this.currentSegment.timestampScale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    this.currentSegment.timestampFactor = 1e9 / this.currentSegment.timestampScale;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Duration:
                {
                    if (!this.currentSegment) break;
                    this.currentSegment.duration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFloat"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackEntry:
                {
                    if (!this.currentSegment) break;
                    this.currentTrack = {
                        id: -1,
                        segment: this.currentSegment,
                        demuxer: this,
                        clusterPositionCache: [],
                        cuePoints: [],
                        disposition: {
                            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_TRACK_DISPOSITION"]
                        },
                        inputTrack: null,
                        codecId: null,
                        codecPrivate: null,
                        defaultDuration: null,
                        name: null,
                        languageCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"],
                        decodingInstructions: [],
                        info: null
                    };
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    if (this.currentTrack.decodingInstructions.some((instruction)=>{
                        return instruction.data?.type !== 'decompress' || instruction.scope !== ContentEncodingScope.Block || instruction.data.algorithm !== ContentCompAlgo.HeaderStripping;
                    })) {
                        console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`);
                        this.currentTrack = null;
                    }
                    if (this.currentTrack && this.currentTrack.id !== -1 && this.currentTrack.codecId && this.currentTrack.info) {
                        const slashIndex = this.currentTrack.codecId.indexOf('/');
                        const codecIdWithoutSuffix = slashIndex === -1 ? this.currentTrack.codecId : this.currentTrack.codecId.slice(0, slashIndex);
                        if (this.currentTrack.info.type === 'video' && this.currentTrack.info.width !== -1 && this.currentTrack.info.height !== -1) {
                            if (this.currentTrack.codecId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].avc) {
                                this.currentTrack.info.codec = 'avc';
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                            } else if (this.currentTrack.codecId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].hevc) {
                                this.currentTrack.info.codec = 'hevc';
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].vp8) {
                                this.currentTrack.info.codec = 'vp8';
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].vp9) {
                                this.currentTrack.info.codec = 'vp9';
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].av1) {
                                this.currentTrack.info.codec = 'av1';
                            }
                            const videoTrack = this.currentTrack;
                            const inputTrack = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputVideoTrack"](this.input, new MatroskaVideoTrackBacking(videoTrack));
                            this.currentTrack.inputTrack = inputTrack;
                            this.currentSegment.tracks.push(this.currentTrack);
                        } else if (this.currentTrack.info.type === 'audio' && this.currentTrack.info.numberOfChannels !== -1 && this.currentTrack.info.sampleRate !== -1) {
                            if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].aac) {
                                this.currentTrack.info.codec = 'aac';
                                this.currentTrack.info.aacCodecInfo = {
                                    isMpeg2: this.currentTrack.codecId.includes('MPEG2')
                                };
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                            } else if (this.currentTrack.codecId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].mp3) {
                                this.currentTrack.info.codec = 'mp3';
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].opus) {
                                this.currentTrack.info.codec = 'opus';
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                                this.currentTrack.info.sampleRate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OPUS_SAMPLE_RATE"]; // Always the same
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].vorbis) {
                                this.currentTrack.info.codec = 'vorbis';
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                            } else if (codecIdWithoutSuffix === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"].flac) {
                                this.currentTrack.info.codec = 'flac';
                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;
                            } else if (this.currentTrack.codecId === 'A_PCM/INT/LIT') {
                                if (this.currentTrack.info.bitDepth === 8) {
                                    this.currentTrack.info.codec = 'pcm-u8';
                                } else if (this.currentTrack.info.bitDepth === 16) {
                                    this.currentTrack.info.codec = 'pcm-s16';
                                } else if (this.currentTrack.info.bitDepth === 24) {
                                    this.currentTrack.info.codec = 'pcm-s24';
                                } else if (this.currentTrack.info.bitDepth === 32) {
                                    this.currentTrack.info.codec = 'pcm-s32';
                                }
                            } else if (this.currentTrack.codecId === 'A_PCM/INT/BIG') {
                                if (this.currentTrack.info.bitDepth === 8) {
                                    this.currentTrack.info.codec = 'pcm-u8';
                                } else if (this.currentTrack.info.bitDepth === 16) {
                                    this.currentTrack.info.codec = 'pcm-s16be';
                                } else if (this.currentTrack.info.bitDepth === 24) {
                                    this.currentTrack.info.codec = 'pcm-s24be';
                                } else if (this.currentTrack.info.bitDepth === 32) {
                                    this.currentTrack.info.codec = 'pcm-s32be';
                                }
                            } else if (this.currentTrack.codecId === 'A_PCM/FLOAT/IEEE') {
                                if (this.currentTrack.info.bitDepth === 32) {
                                    this.currentTrack.info.codec = 'pcm-f32';
                                } else if (this.currentTrack.info.bitDepth === 64) {
                                    this.currentTrack.info.codec = 'pcm-f64';
                                }
                            }
                            const audioTrack = this.currentTrack;
                            const inputTrack = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$input$2d$track$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputAudioTrack"](this.input, new MatroskaAudioTrackBacking(audioTrack));
                            this.currentTrack.inputTrack = inputTrack;
                            this.currentSegment.tracks.push(this.currentTrack);
                        }
                    }
                    this.currentTrack = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackNumber:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackType:
                {
                    if (!this.currentTrack) break;
                    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    if (type === 1) {
                        this.currentTrack.info = {
                            type: 'video',
                            width: -1,
                            height: -1,
                            rotation: 0,
                            codec: null,
                            codecDescription: null,
                            colorSpace: null,
                            alphaMode: false
                        };
                    } else if (type === 2) {
                        this.currentTrack.info = {
                            type: 'audio',
                            numberOfChannels: -1,
                            sampleRate: -1,
                            bitDepth: -1,
                            codec: null,
                            codecDescription: null,
                            aacCodecInfo: null
                        };
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagEnabled:
                {
                    if (!this.currentTrack) break;
                    const enabled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    if (!enabled) {
                        this.currentSegment.tracks.pop();
                        this.currentTrack = null;
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagDefault:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.default = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagForced:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.forced = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagOriginal:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.original = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagHearingImpaired:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.hearingImpaired = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagVisualImpaired:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.visuallyImpaired = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagCommentary:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.disposition.commentary = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecID:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.codecId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAsciiString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecPrivate:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.codecPrivate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DefaultDuration:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.defaultDuration = this.currentTrack.segment.timestampFactor * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size) / 1e9;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Name:
                {
                    if (!this.currentTrack) break;
                    this.currentTrack.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnicodeString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Language:
                {
                    if (!this.currentTrack) break;
                    if (this.currentTrack.languageCode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"]) {
                        break;
                    }
                    this.currentTrack.languageCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAsciiString"])(slice, size);
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isIso639Dash2LanguageCode"])(this.currentTrack.languageCode)) {
                        this.currentTrack.languageCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"];
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].LanguageBCP47:
                {
                    if (!this.currentTrack) break;
                    const bcp47 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAsciiString"])(slice, size);
                    const languageSubtag = bcp47.split('-')[0];
                    if (languageSubtag) {
                        // Technically invalid, for now: The language subtag might be a language code from ISO 639-1,
                        // ISO 639-2, ISO 639-3, ISO 639-5 or some other thing (source: Wikipedia). But, `languageCode` is
                        // documented as ISO 639-2. Changing the definition would be a breaking change. This will get
                        // cleaned up in the future by defining languageCode to be BCP 47 instead.
                        this.currentTrack.languageCode = languageSubtag;
                    } else {
                        this.currentTrack.languageCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"];
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Video:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].PixelWidth:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.currentTrack.info.width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].PixelHeight:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.currentTrack.info.height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].AlphaMode:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.currentTrack.info.alphaMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size) === 1;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Colour:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.currentTrack.info.colorSpace = {};
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].MatrixCoefficients:
                {
                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace) break;
                    const matrixCoefficients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    const mapped = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MATRIX_COEFFICIENTS_MAP_INVERSE"][matrixCoefficients] ?? null;
                    this.currentTrack.info.colorSpace.matrix = mapped;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Range:
                {
                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace) break;
                    this.currentTrack.info.colorSpace.fullRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size) === 2;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TransferCharacteristics:
                {
                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace) break;
                    const transferCharacteristics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    const mapped = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TRANSFER_CHARACTERISTICS_MAP_INVERSE"][transferCharacteristics] ?? null;
                    this.currentTrack.info.colorSpace.transfer = mapped;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Primaries:
                {
                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace) break;
                    const primaries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    const mapped = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COLOR_PRIMARIES_MAP_INVERSE"][primaries] ?? null;
                    this.currentTrack.info.colorSpace.primaries = mapped;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Projection:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ProjectionPoseRoll:
                {
                    if (this.currentTrack?.info?.type !== 'video') break;
                    const rotation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFloat"])(slice, size);
                    const flippedRotation = -rotation; // Convert counter-clockwise to clockwise
                    try {
                        this.currentTrack.info.rotation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeRotation"])(flippedRotation);
                    } catch  {
                    // It wasn't a valid rotation
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Audio:
                {
                    if (this.currentTrack?.info?.type !== 'audio') break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SamplingFrequency:
                {
                    if (this.currentTrack?.info?.type !== 'audio') break;
                    this.currentTrack.info.sampleRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readFloat"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Channels:
                {
                    if (this.currentTrack?.info?.type !== 'audio') break;
                    this.currentTrack.info.numberOfChannels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BitDepth:
                {
                    if (this.currentTrack?.info?.type !== 'audio') break;
                    this.currentTrack.info.bitDepth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CuePoint:
                {
                    if (!this.currentSegment) break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    this.currentCueTime = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTime:
                {
                    this.currentCueTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTrackPositions:
                {
                    if (this.currentCueTime === null) break;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentSegment);
                    const cuePoint = {
                        time: this.currentCueTime,
                        trackId: -1,
                        clusterPosition: -1
                    };
                    this.currentSegment.cuePoints.push(cuePoint);
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    if (cuePoint.trackId === -1 || cuePoint.clusterPosition === -1) {
                        this.currentSegment.cuePoints.pop();
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTrack:
                {
                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];
                    if (!lastCuePoint) break;
                    lastCuePoint.trackId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueClusterPosition:
                {
                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];
                    if (!lastCuePoint) break;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentSegment);
                    lastCuePoint.clusterPosition = this.currentSegment.dataStartPos + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Timestamp:
                {
                    if (!this.currentCluster) break;
                    this.currentCluster.timestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SimpleBlock:
                {
                    if (!this.currentCluster) break;
                    const trackNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readVarInt"])(slice);
                    if (trackNumber === null) break;
                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);
                    if (!trackData) break; // Not a track we care about
                    const relativeTimestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI16Be"])(slice);
                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const lacing = flags >> 1 & 0x3; // If the block is laced, we'll expand it later
                    let isKeyFrame = !!(flags & 0x80);
                    if (trackData.track.info?.type === 'audio' && trackData.track.info.codec) {
                        // Some files don't mark their audio packets as key packets (I'm looking at you, Firefox). But, we
                        // can fix this in most cases: if we recognize the codec of the track, then we know every packet is
                        // necessarily a key packet, no matter what the container says.
                        // https://github.com/Vanilagy/mediabunny/issues/192
                        isKeyFrame = true;
                    }
                    const blockData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size - (slice.filePos - dataStartPos));
                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;
                    trackData.blocks.push({
                        timestamp: relativeTimestamp,
                        duration: 0,
                        isKeyFrame,
                        data: blockData,
                        lacing,
                        decoded: !hasDecodingInstructions,
                        mainAdditional: null
                    });
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockGroup:
                {
                    if (!this.currentCluster) break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    this.currentBlock = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Block:
                {
                    if (!this.currentCluster) break;
                    const trackNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readVarInt"])(slice);
                    if (trackNumber === null) break;
                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);
                    if (!trackData) break;
                    const relativeTimestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readI16Be"])(slice);
                    const flags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readU8"])(slice);
                    const lacing = flags >> 1 & 0x3; // If the block is laced, we'll expand it later
                    const blockData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size - (slice.filePos - dataStartPos));
                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;
                    this.currentBlock = {
                        timestamp: relativeTimestamp,
                        duration: 0,
                        isKeyFrame: true,
                        data: blockData,
                        lacing,
                        decoded: !hasDecodingInstructions,
                        mainAdditional: null
                    };
                    trackData.blocks.push(this.currentBlock);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAdditions:
                {
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockMore:
                {
                    if (!this.currentBlock) break;
                    this.currentBlockAdditional = {
                        addId: 1,
                        data: null
                    };
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    if (this.currentBlockAdditional.data && this.currentBlockAdditional.addId === 1) {
                        this.currentBlock.mainAdditional = this.currentBlockAdditional.data;
                    }
                    this.currentBlockAdditional = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAdditional:
                {
                    if (!this.currentBlockAdditional) break;
                    this.currentBlockAdditional.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAddID:
                {
                    if (!this.currentBlockAdditional) break;
                    this.currentBlockAdditional.addId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockDuration:
                {
                    if (!this.currentBlock) break;
                    this.currentBlock.duration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ReferenceBlock:
                {
                    if (!this.currentBlock) break;
                    this.currentBlock.isKeyFrame = false;
                // We ignore the actual value here, we just use the reference as an indicator for "not a key frame".
                // This is in line with FFmpeg's behavior.
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tag:
                {
                    this.currentTagTargetIsMovie = true;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Targets:
                {
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TargetTypeValue:
                {
                    const targetTypeValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                    if (targetTypeValue !== 50) {
                        this.currentTagTargetIsMovie = false;
                    }
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagTrackUID:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagEditionUID:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagChapterUID:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagAttachmentUID:
                {
                    this.currentTagTargetIsMovie = false;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SimpleTag:
                {
                    if (!this.currentTagTargetIsMovie) break;
                    this.currentSimpleTagName = null;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagName:
                {
                    this.currentSimpleTagName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnicodeString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagString:
                {
                    if (!this.currentSimpleTagName) break;
                    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnicodeString"])(slice, size);
                    this.processTagValue(this.currentSimpleTagName, value);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagBinary:
                {
                    if (!this.currentSimpleTagName) break;
                    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size);
                    this.processTagValue(this.currentSimpleTagName, value);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].AttachedFile:
                {
                    if (!this.currentSegment) break;
                    this.currentAttachedFile = {
                        fileUid: null,
                        fileName: null,
                        fileMediaType: null,
                        fileData: null,
                        fileDescription: null
                    };
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    const tags = this.currentSegment.metadataTags;
                    if (this.currentAttachedFile.fileUid && this.currentAttachedFile.fileData) {
                        // All attached files get surfaced in the `raw` metadata tags
                        tags.raw ??= {};
                        tags.raw[this.currentAttachedFile.fileUid.toString()] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AttachedFile"](this.currentAttachedFile.fileData, this.currentAttachedFile.fileMediaType ?? undefined, this.currentAttachedFile.fileName ?? undefined, this.currentAttachedFile.fileDescription ?? undefined);
                    }
                    // Only process image attachments
                    if (this.currentAttachedFile.fileMediaType?.startsWith('image/') && this.currentAttachedFile.fileData) {
                        const fileName = this.currentAttachedFile.fileName;
                        let kind = 'unknown';
                        if (fileName) {
                            const lowerName = fileName.toLowerCase();
                            if (lowerName.startsWith('cover.')) {
                                kind = 'coverFront';
                            } else if (lowerName.startsWith('back.')) {
                                kind = 'coverBack';
                            }
                        }
                        tags.images ??= [];
                        tags.images.push({
                            data: this.currentAttachedFile.fileData,
                            mimeType: this.currentAttachedFile.fileMediaType,
                            kind,
                            name: this.currentAttachedFile.fileName ?? undefined,
                            description: this.currentAttachedFile.fileDescription ?? undefined
                        });
                    }
                    this.currentAttachedFile = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileUID:
                {
                    if (!this.currentAttachedFile) break;
                    this.currentAttachedFile.fileUid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedBigInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileName:
                {
                    if (!this.currentAttachedFile) break;
                    this.currentAttachedFile.fileName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnicodeString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileMediaType:
                {
                    if (!this.currentAttachedFile) break;
                    this.currentAttachedFile.fileMediaType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readAsciiString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileData:
                {
                    if (!this.currentAttachedFile) break;
                    this.currentAttachedFile.fileData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileDescription:
                {
                    if (!this.currentAttachedFile) break;
                    this.currentAttachedFile.fileDescription = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnicodeString"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentEncodings:
                {
                    if (!this.currentTrack) break;
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    // "**MUST** start with the `ContentEncoding` with the highest `ContentEncodingOrder`"
                    this.currentTrack.decodingInstructions.sort((a, b)=>b.order - a.order);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentEncoding:
                {
                    this.currentDecodingInstruction = {
                        order: 0,
                        scope: ContentEncodingScope.Block,
                        data: null
                    };
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                    if (this.currentDecodingInstruction.data) {
                        this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction);
                    }
                    this.currentDecodingInstruction = null;
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentEncodingOrder:
                {
                    if (!this.currentDecodingInstruction) break;
                    this.currentDecodingInstruction.order = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentEncodingScope:
                {
                    if (!this.currentDecodingInstruction) break;
                    this.currentDecodingInstruction.scope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentCompression:
                {
                    if (!this.currentDecodingInstruction) break;
                    this.currentDecodingInstruction.data = {
                        type: 'decompress',
                        algorithm: ContentCompAlgo.Zlib,
                        settings: null
                    };
                    this.readContiguousElements(slice.slice(dataStartPos, size));
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentCompAlgo:
                {
                    if (this.currentDecodingInstruction?.data?.type !== 'decompress') break;
                    this.currentDecodingInstruction.data.algorithm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readUnsignedInt"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentCompSettings:
                {
                    if (this.currentDecodingInstruction?.data?.type !== 'decompress') break;
                    this.currentDecodingInstruction.data.settings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readBytes"])(slice, size);
                }
                ;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ContentEncryption:
                {
                    if (!this.currentDecodingInstruction) break;
                    this.currentDecodingInstruction.data = {
                        type: 'decrypt'
                    };
                }
                ;
                break;
        }
        slice.filePos = dataStartPos + size;
        return true;
    }
    decodeBlockData(track, rawData) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(track.decodingInstructions.length > 0); // This method shouldn't be called otherwise
        let currentData = rawData;
        for (const instruction of track.decodingInstructions){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(instruction.data);
            switch(instruction.data.type){
                case 'decompress':
                    {
                        switch(instruction.data.algorithm){
                            case ContentCompAlgo.HeaderStripping:
                                {
                                    if (instruction.data.settings && instruction.data.settings.length > 0) {
                                        const prefix = instruction.data.settings;
                                        const newData = new Uint8Array(prefix.length + currentData.length);
                                        newData.set(prefix, 0);
                                        newData.set(currentData, prefix.length);
                                        currentData = newData;
                                    }
                                }
                                ;
                                break;
                            default:
                                {
                                // Unhandled
                                }
                                ;
                        }
                    }
                    ;
                    break;
                default:
                    {
                    // Unhandled
                    }
                    ;
            }
        }
        return currentData;
    }
    processTagValue(name, value) {
        if (!this.currentSegment?.metadataTags) return;
        const metadataTags = this.currentSegment.metadataTags;
        metadataTags.raw ??= {};
        metadataTags.raw[name] ??= value;
        if (typeof value === 'string') {
            switch(name.toLowerCase()){
                case 'title':
                    {
                        metadataTags.title ??= value;
                    }
                    ;
                    break;
                case 'description':
                    {
                        metadataTags.description ??= value;
                    }
                    ;
                    break;
                case 'artist':
                    {
                        metadataTags.artist ??= value;
                    }
                    ;
                    break;
                case 'album':
                    {
                        metadataTags.album ??= value;
                    }
                    ;
                    break;
                case 'album_artist':
                    {
                        metadataTags.albumArtist ??= value;
                    }
                    ;
                    break;
                case 'genre':
                    {
                        metadataTags.genre ??= value;
                    }
                    ;
                    break;
                case 'comment':
                    {
                        metadataTags.comment ??= value;
                    }
                    ;
                    break;
                case 'lyrics':
                    {
                        metadataTags.lyrics ??= value;
                    }
                    ;
                    break;
                case 'date':
                    {
                        const date = new Date(value);
                        if (!Number.isNaN(date.getTime())) {
                            metadataTags.date ??= date;
                        }
                    }
                    ;
                    break;
                case 'track_number':
                case 'part_number':
                    {
                        const parts = value.split('/');
                        const trackNum = Number.parseInt(parts[0], 10);
                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);
                        if (Number.isInteger(trackNum) && trackNum > 0) {
                            metadataTags.trackNumber ??= trackNum;
                        }
                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {
                            metadataTags.tracksTotal ??= tracksTotal;
                        }
                    }
                    ;
                    break;
                case 'disc_number':
                case 'disc':
                    {
                        const discParts = value.split('/');
                        const discNum = Number.parseInt(discParts[0], 10);
                        const discsTotal = discParts[1] && Number.parseInt(discParts[1], 10);
                        if (Number.isInteger(discNum) && discNum > 0) {
                            metadataTags.discNumber ??= discNum;
                        }
                        if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {
                            metadataTags.discsTotal ??= discsTotal;
                        }
                    }
                    ;
                    break;
            }
        }
    }
}
class MatroskaTrackBacking {
    constructor(internalTrack){
        this.internalTrack = internalTrack;
        this.packetToClusterLocation = new WeakMap();
    }
    getId() {
        return this.internalTrack.id;
    }
    getCodec() {
        throw new Error('Not implemented on base class.');
    }
    getInternalCodecId() {
        return this.internalTrack.codecId;
    }
    async computeDuration() {
        const lastPacket = await this.getPacket(Infinity, {
            metadataOnly: true
        });
        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);
    }
    getName() {
        return this.internalTrack.name;
    }
    getLanguageCode() {
        return this.internalTrack.languageCode;
    }
    async getFirstTimestamp() {
        const firstPacket = await this.getFirstPacket({
            metadataOnly: true
        });
        return firstPacket?.timestamp ?? 0;
    }
    getTimeResolution() {
        return this.internalTrack.segment.timestampFactor;
    }
    getDisposition() {
        return this.internalTrack.disposition;
    }
    async getFirstPacket(options) {
        return this.performClusterLookup(null, (cluster)=>{
            const trackData = cluster.trackData.get(this.internalTrack.id);
            if (trackData) {
                return {
                    blockIndex: 0,
                    correctBlockFound: true
                };
            }
            return {
                blockIndex: -1,
                correctBlockFound: false
            };
        }, -Infinity, Infinity, options);
    }
    intoTimescale(timestamp) {
        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely
        // that the number was originally an integer divided by the timescale. For stability, it's best
        // to return the integer in this case.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["roundIfAlmostInteger"])(timestamp * this.internalTrack.segment.timestampFactor);
    }
    async getPacket(timestamp, options) {
        const timestampInTimescale = this.intoTimescale(timestamp);
        return this.performClusterLookup(null, (cluster)=>{
            const trackData = cluster.trackData.get(this.internalTrack.id);
            if (!trackData) {
                return {
                    blockIndex: -1,
                    correctBlockFound: false
                };
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(trackData.presentationTimestamps, timestampInTimescale, (x)=>x.timestamp);
            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;
            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;
            return {
                blockIndex,
                correctBlockFound
            };
        }, timestampInTimescale, timestampInTimescale, options);
    }
    async getNextPacket(packet, options) {
        const locationInCluster = this.packetToClusterLocation.get(packet);
        if (locationInCluster === undefined) {
            throw new Error('Packet was not created from this track.');
        }
        return this.performClusterLookup(locationInCluster.cluster, (cluster)=>{
            if (cluster === locationInCluster.cluster) {
                const trackData = cluster.trackData.get(this.internalTrack.id);
                if (locationInCluster.blockIndex + 1 < trackData.blocks.length) {
                    // We can simply take the next block in the cluster
                    return {
                        blockIndex: locationInCluster.blockIndex + 1,
                        correctBlockFound: true
                    };
                }
            } else {
                const trackData = cluster.trackData.get(this.internalTrack.id);
                if (trackData) {
                    return {
                        blockIndex: 0,
                        correctBlockFound: true
                    };
                }
            }
            return {
                blockIndex: -1,
                correctBlockFound: false
            };
        }, -Infinity, Infinity, options);
    }
    async getKeyPacket(timestamp, options) {
        const timestampInTimescale = this.intoTimescale(timestamp);
        return this.performClusterLookup(null, (cluster)=>{
            const trackData = cluster.trackData.get(this.internalTrack.id);
            if (!trackData) {
                return {
                    blockIndex: -1,
                    correctBlockFound: false
                };
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findLastIndex"])(trackData.presentationTimestamps, (x)=>{
                const block = trackData.blocks[x.blockIndex];
                return block.isKeyFrame && x.timestamp <= timestampInTimescale;
            });
            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;
            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;
            return {
                blockIndex,
                correctBlockFound
            };
        }, timestampInTimescale, timestampInTimescale, options);
    }
    async getNextKeyPacket(packet, options) {
        const locationInCluster = this.packetToClusterLocation.get(packet);
        if (locationInCluster === undefined) {
            throw new Error('Packet was not created from this track.');
        }
        return this.performClusterLookup(locationInCluster.cluster, (cluster)=>{
            if (cluster === locationInCluster.cluster) {
                const trackData = cluster.trackData.get(this.internalTrack.id);
                const nextKeyFrameIndex = trackData.blocks.findIndex((x, i)=>x.isKeyFrame && i > locationInCluster.blockIndex);
                if (nextKeyFrameIndex !== -1) {
                    // We can simply take the next key frame in the cluster
                    return {
                        blockIndex: nextKeyFrameIndex,
                        correctBlockFound: true
                    };
                }
            } else {
                const trackData = cluster.trackData.get(this.internalTrack.id);
                if (trackData && trackData.firstKeyFrameTimestamp !== null) {
                    const keyFrameIndex = trackData.blocks.findIndex((x)=>x.isKeyFrame);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(keyFrameIndex !== -1); // There must be one
                    return {
                        blockIndex: keyFrameIndex,
                        correctBlockFound: true
                    };
                }
            }
            return {
                blockIndex: -1,
                correctBlockFound: false
            };
        }, -Infinity, Infinity, options);
    }
    async fetchPacketInCluster(cluster, blockIndex, options) {
        if (blockIndex === -1) {
            return null;
        }
        const trackData = cluster.trackData.get(this.internalTrack.id);
        const block = trackData.blocks[blockIndex];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(block);
        // Perform lazy decoding if needed
        if (!block.decoded) {
            block.data = this.internalTrack.demuxer.decodeBlockData(this.internalTrack, block.data);
            block.decoded = true;
        }
        const data = options.metadataOnly ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PLACEHOLDER_DATA"] : block.data;
        const timestamp = block.timestamp / this.internalTrack.segment.timestampFactor;
        const duration = block.duration / this.internalTrack.segment.timestampFactor;
        const sideData = {};
        if (block.mainAdditional && this.internalTrack.info?.type === 'video' && this.internalTrack.info.alphaMode) {
            sideData.alpha = options.metadataOnly ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PLACEHOLDER_DATA"] : block.mainAdditional;
            sideData.alphaByteLength = block.mainAdditional.byteLength;
        }
        const packet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$packet$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EncodedPacket"](data, block.isKeyFrame ? 'key' : 'delta', timestamp, duration, cluster.dataStartPos + blockIndex, block.data.byteLength, sideData);
        this.packetToClusterLocation.set(packet, {
            cluster,
            blockIndex
        });
        return packet;
    }
    /** Looks for a packet in the clusters while trying to load as few clusters as possible to retrieve it. */ async performClusterLookup(// The cluster where we start looking
    startCluster, // This function returns the best-matching block in a given cluster
    getMatchInCluster, // The timestamp with which we can search the lookup table
    searchTimestamp, // The timestamp for which we know the correct block will not come after it
    latestTimestamp, options) {
        const { demuxer, segment } = this.internalTrack;
        let currentCluster = null;
        let bestCluster = null;
        let bestBlockIndex = -1;
        if (startCluster) {
            const { blockIndex, correctBlockFound } = getMatchInCluster(startCluster);
            if (correctBlockFound) {
                return this.fetchPacketInCluster(startCluster, blockIndex, options);
            }
            if (blockIndex !== -1) {
                bestCluster = startCluster;
                bestBlockIndex = blockIndex;
            }
        }
        // Search for a cue point; this way, we won't need to start searching from the start of the file
        // but can jump right into the correct cluster (or at least nearby).
        const cuePointIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(this.internalTrack.cuePoints, searchTimestamp, (x)=>x.time);
        const cuePoint = cuePointIndex !== -1 ? this.internalTrack.cuePoints[cuePointIndex] : null;
        // Also check the position cache
        const positionCacheIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binarySearchLessOrEqual"])(this.internalTrack.clusterPositionCache, searchTimestamp, (x)=>x.startTimestamp);
        const positionCacheEntry = positionCacheIndex !== -1 ? this.internalTrack.clusterPositionCache[positionCacheIndex] : null;
        const lookupEntryPosition = Math.max(cuePoint?.clusterPosition ?? 0, positionCacheEntry?.elementStartPos ?? 0) || null;
        let currentPos;
        if (!startCluster) {
            currentPos = lookupEntryPosition ?? segment.clusterSeekStartPos;
        } else {
            if (lookupEntryPosition === null || startCluster.elementStartPos >= lookupEntryPosition) {
                currentPos = startCluster.elementEndPos;
                currentCluster = startCluster;
            } else {
                // Use the lookup entry
                currentPos = lookupEntryPosition;
            }
        }
        while(segment.elementEndPos === null || currentPos <= segment.elementEndPos - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"]){
            if (currentCluster) {
                const trackData = currentCluster.trackData.get(this.internalTrack.id);
                if (trackData && trackData.startTimestamp > latestTimestamp) {
                    break;
                }
            }
            // Load the header
            let slice = demuxer.reader.requestSliceRange(currentPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
            if (slice instanceof Promise) slice = await slice;
            if (!slice) break;
            const elementStartPos = currentPos;
            const elementHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementHeader"])(slice);
            if (!elementHeader || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_1_EBML_IDS"].includes(elementHeader.id) && elementHeader.id !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Void) {
                // There's an element here that shouldn't be here. Might be garbage. In this case, let's
                // try and resync to the next valid element.
                const nextPos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resync"])(demuxer.reader, elementStartPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_1_EBML_IDS"], Math.min(segment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));
                if (nextPos) {
                    currentPos = nextPos;
                    continue;
                } else {
                    break; // Resync failed
                }
            }
            const id = elementHeader.id;
            let size = elementHeader.size;
            const dataStartPos = slice.filePos;
            if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster) {
                currentCluster = await demuxer.readCluster(elementStartPos, segment);
                // readCluster computes the proper size even if it's undefined in the header, so let's use that instead
                size = currentCluster.elementEndPos - dataStartPos;
                const { blockIndex, correctBlockFound } = getMatchInCluster(currentCluster);
                if (correctBlockFound) {
                    return this.fetchPacketInCluster(currentCluster, blockIndex, options);
                }
                if (blockIndex !== -1) {
                    bestCluster = currentCluster;
                    bestBlockIndex = blockIndex;
                }
            }
            if (size === null) {
                // Undefined element size (can happen in livestreamed files). In this case, we need to do some
                // searching to determine the actual size of the element.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(id !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster); // Undefined cluster sizes are fixed further up
                // Search for the next element at level 0 or 1
                const nextElementPos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchForNextElementId"])(demuxer.reader, dataStartPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEVEL_0_AND_1_EBML_IDS"], segment.elementEndPos);
                size = nextElementPos.pos - dataStartPos;
            }
            const endPos = dataStartPos + size;
            if (segment.elementEndPos === null) {
                // Check the next element. If it's a new segment, we know this segment ends here. The new
                // segment is just ignored, since we're likely in a livestreamed file and thus only care about
                // the first segment.
                let slice = demuxer.reader.requestSliceRange(endPos, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_HEADER_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_HEADER_SIZE"]);
                if (slice instanceof Promise) slice = await slice;
                if (!slice) break;
                const elementId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readElementId"])(slice);
                if (elementId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Segment) {
                    segment.elementEndPos = endPos; // We now know the segment's size
                    break;
                }
            }
            currentPos = endPos;
        }
        // Catch faulty cue points
        if (cuePoint && (!bestCluster || bestCluster.elementStartPos < cuePoint.clusterPosition)) {
            // The cue point lied to us! We found a cue point but no cluster there that satisfied the match. In this
            // case, let's search again but using the cue point before that.
            const previousCuePoint = this.internalTrack.cuePoints[cuePointIndex - 1];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(!previousCuePoint || previousCuePoint.time < cuePoint.time);
            const newSearchTimestamp = previousCuePoint?.time ?? -Infinity;
            return this.performClusterLookup(null, getMatchInCluster, newSearchTimestamp, latestTimestamp, options);
        }
        if (bestCluster) {
            // If we finished looping but didn't find a perfect match, still return the best match we found
            return this.fetchPacketInCluster(bestCluster, bestBlockIndex, options);
        }
        return null;
    }
}
class MatroskaVideoTrackBacking extends MatroskaTrackBacking {
    constructor(internalTrack){
        super(internalTrack);
        this.decoderConfigPromise = null;
        this.internalTrack = internalTrack;
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getCodedWidth() {
        return this.internalTrack.info.width;
    }
    getCodedHeight() {
        return this.internalTrack.info.height;
    }
    getRotation() {
        return this.internalTrack.info.rotation;
    }
    async getColorSpace() {
        return {
            primaries: this.internalTrack.info.colorSpace?.primaries,
            transfer: this.internalTrack.info.colorSpace?.transfer,
            matrix: this.internalTrack.info.colorSpace?.matrix,
            fullRange: this.internalTrack.info.colorSpace?.fullRange
        };
    }
    async canBeTransparent() {
        return this.internalTrack.info.alphaMode;
    }
    async getDecoderConfig() {
        if (!this.internalTrack.info.codec) {
            return null;
        }
        return this.decoderConfigPromise ??= (async ()=>{
            let firstPacket = null;
            const needsPacketForAdditionalInfo = this.internalTrack.info.codec === 'vp9' || this.internalTrack.info.codec === 'av1' || this.internalTrack.info.codec === 'avc' && !this.internalTrack.info.codecDescription || this.internalTrack.info.codec === 'hevc' && !this.internalTrack.info.codecDescription;
            if (needsPacketForAdditionalInfo) {
                firstPacket = await this.getFirstPacket({});
            }
            return {
                codec: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractVideoCodecString"])({
                    width: this.internalTrack.info.width,
                    height: this.internalTrack.info.height,
                    codec: this.internalTrack.info.codec,
                    codecDescription: this.internalTrack.info.codecDescription,
                    colorSpace: this.internalTrack.info.colorSpace,
                    avcType: 1,
                    avcCodecInfo: this.internalTrack.info.codec === 'avc' && firstPacket ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAvcDecoderConfigurationRecord"])(firstPacket.data) : null,
                    hevcCodecInfo: this.internalTrack.info.codec === 'hevc' && firstPacket ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractHevcDecoderConfigurationRecord"])(firstPacket.data) : null,
                    vp9CodecInfo: this.internalTrack.info.codec === 'vp9' && firstPacket ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractVp9CodecInfoFromPacket"])(firstPacket.data) : null,
                    av1CodecInfo: this.internalTrack.info.codec === 'av1' && firstPacket ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAv1CodecInfoFromPacket"])(firstPacket.data) : null
                }),
                codedWidth: this.internalTrack.info.width,
                codedHeight: this.internalTrack.info.height,
                description: this.internalTrack.info.codecDescription ?? undefined,
                colorSpace: this.internalTrack.info.colorSpace ?? undefined
            };
        })();
    }
}
class MatroskaAudioTrackBacking extends MatroskaTrackBacking {
    constructor(internalTrack){
        super(internalTrack);
        this.decoderConfig = null;
        this.internalTrack = internalTrack;
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getNumberOfChannels() {
        return this.internalTrack.info.numberOfChannels;
    }
    getSampleRate() {
        return this.internalTrack.info.sampleRate;
    }
    async getDecoderConfig() {
        if (!this.internalTrack.info.codec) {
            return null;
        }
        return this.decoderConfig ??= {
            codec: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractAudioCodecString"])({
                codec: this.internalTrack.info.codec,
                codecDescription: this.internalTrack.info.codecDescription,
                aacCodecInfo: this.internalTrack.info.aacCodecInfo
            }),
            numberOfChannels: this.internalTrack.info.numberOfChannels,
            sampleRate: this.internalTrack.info.sampleRate,
            description: this.internalTrack.info.codecDescription ?? undefined
        };
    }
}
}),
"[project]/node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ __turbopack_context__.s([
    "MatroskaMuxer",
    ()=>MatroskaMuxer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/matroska/ebml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$matroska$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/output-format.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/subtitles.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/muxer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/codec-data.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mediabunny/dist/modules/src/metadata.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
const MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);
const MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;
const APP_NAME = 'Mediabunny';
const SEGMENT_SIZE_BYTES = 6;
const CLUSTER_SIZE_BYTES = 5;
const TRACK_TYPE_MAP = {
    video: 1,
    audio: 2,
    subtitle: 17
};
class MatroskaMuxer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$muxer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Muxer"] {
    constructor(output, format){
        super(output);
        this.trackDatas = [];
        this.allTracksKnown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["promiseWithResolvers"])();
        this.segment = null;
        this.segmentInfo = null;
        this.seekHead = null;
        this.tracksElement = null;
        this.tagsElement = null;
        this.attachmentsElement = null;
        this.segmentDuration = null;
        this.cues = null;
        this.currentCluster = null;
        this.currentClusterStartMsTimestamp = null;
        this.currentClusterMaxMsTimestamp = null;
        this.trackDatasInCurrentCluster = new Map();
        this.duration = 0;
        this.writer = output._writer;
        this.format = format;
        this.ebmlWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLWriter"](this.writer);
        if (this.format._options.appendOnly) {
            this.writer.ensureMonotonicity = true;
        }
    }
    async start() {
        const release = await this.mutex.acquire();
        this.writeEBMLHeader();
        this.createSegmentInfo();
        this.createCues();
        await this.writer.flush();
        release();
    }
    writeEBMLHeader() {
        if (this.format._options.onEbmlHeader) {
            this.writer.startTrackingWrites();
        }
        const ebmlHeader = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBML,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBMLVersion,
                    data: 1
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBMLReadVersion,
                    data: 1
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBMLMaxIDLength,
                    data: 4
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].EBMLMaxSizeLength,
                    data: 8
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DocType,
                    data: this.format instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebMOutputFormat"] ? 'webm' : 'matroska'
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DocTypeVersion,
                    data: 2
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DocTypeReadVersion,
                    data: 2
                }
            ]
        };
        this.ebmlWriter.writeEBML(ebmlHeader);
        if (this.format._options.onEbmlHeader) {
            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0
            this.format._options.onEbmlHeader(data, start);
        }
    }
    /**
     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to
     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.
     */ maybeCreateSeekHead(writeOffsets) {
        if (this.format._options.appendOnly) {
            return;
        }
        const kaxCues = new Uint8Array([
            0x1c,
            0x53,
            0xbb,
            0x6b
        ]);
        const kaxInfo = new Uint8Array([
            0x15,
            0x49,
            0xa9,
            0x66
        ]);
        const kaxTracks = new Uint8Array([
            0x16,
            0x54,
            0xae,
            0x6b
        ]);
        const kaxAttachments = new Uint8Array([
            0x19,
            0x41,
            0xa4,
            0x69
        ]);
        const kaxTags = new Uint8Array([
            0x12,
            0x54,
            0xc3,
            0x67
        ]);
        const seekHead = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekHead,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID,
                            data: kaxCues
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition,
                            size: 5,
                            data: writeOffsets ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset : 0
                        }
                    ]
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID,
                            data: kaxInfo
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition,
                            size: 5,
                            data: writeOffsets ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset : 0
                        }
                    ]
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID,
                            data: kaxTracks
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition,
                            size: 5,
                            data: writeOffsets ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset : 0
                        }
                    ]
                },
                this.attachmentsElement ? {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID,
                            data: kaxAttachments
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition,
                            size: 5,
                            data: writeOffsets ? this.ebmlWriter.offsets.get(this.attachmentsElement) - this.segmentDataOffset : 0
                        }
                    ]
                } : null,
                this.tagsElement ? {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Seek,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekID,
                            data: kaxTags
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPosition,
                            size: 5,
                            data: writeOffsets ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset : 0
                        }
                    ]
                } : null
            ]
        };
        this.seekHead = seekHead;
    }
    createSegmentInfo() {
        const segmentDuration = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Duration,
            data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLFloat64"](0)
        };
        this.segmentDuration = segmentDuration;
        const segmentInfo = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Info,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TimestampScale,
                    data: 1e6
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].MuxingApp,
                    data: APP_NAME
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].WritingApp,
                    data: APP_NAME
                },
                !this.format._options.appendOnly ? segmentDuration : null
            ]
        };
        this.segmentInfo = segmentInfo;
    }
    createTracks() {
        const tracksElement = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tracks,
            data: []
        };
        this.tracksElement = tracksElement;
        for (const trackData of this.trackDatas){
            const codecId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CODEC_STRING_MAP"][trackData.track.source._codec];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(codecId);
            let seekPreRollNs = 0;
            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {
                seekPreRollNs = 1e6 * 80; // In "Matroska ticks" (nanoseconds)
                const description = trackData.info.decoderConfig.description;
                if (description) {
                    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(description);
                    const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2d$data$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseOpusIdentificationHeader"])(bytes);
                    // Use the preSkip value from the header
                    seekPreRollNs = Math.round(1e9 * (header.preSkip / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OPUS_SAMPLE_RATE"]));
                }
            }
            tracksElement.data.push({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackEntry,
                data: [
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackNumber,
                        data: trackData.track.id
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackUID,
                        data: trackData.track.id
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TrackType,
                        data: TRACK_TYPE_MAP[trackData.type]
                    },
                    trackData.track.metadata.disposition?.default === false ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagDefault,
                        data: 0
                    } : null,
                    trackData.track.metadata.disposition?.forced ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagForced,
                        data: 1
                    } : null,
                    trackData.track.metadata.disposition?.hearingImpaired ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagHearingImpaired,
                        data: 1
                    } : null,
                    trackData.track.metadata.disposition?.visuallyImpaired ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagVisualImpaired,
                        data: 1
                    } : null,
                    trackData.track.metadata.disposition?.original ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagOriginal,
                        data: 1
                    } : null,
                    trackData.track.metadata.disposition?.commentary ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagCommentary,
                        data: 1
                    } : null,
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FlagLacing,
                        data: 0
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Language,
                        data: trackData.track.metadata.languageCode ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNDETERMINED_LANGUAGE"]
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecID,
                        data: codecId
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecDelay,
                        data: 0
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SeekPreRoll,
                        data: seekPreRollNs
                    },
                    trackData.track.metadata.name !== undefined ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Name,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](trackData.track.metadata.name)
                    } : null,
                    trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null,
                    trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null,
                    trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null
                ]
            });
        }
    }
    videoSpecificTrackInfo(trackData) {
        const { frameRate, rotation } = trackData.track.metadata;
        const elements = [
            trackData.info.decoderConfig.description ? {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecPrivate,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(trackData.info.decoderConfig.description)
            } : null,
            frameRate ? {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].DefaultDuration,
                data: 1e9 / frameRate
            } : null
        ];
        // Convert from clockwise to counter-clockwise
        const flippedRotation = rotation ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeRotation"])(-rotation) : 0;
        const colorSpace = trackData.info.decoderConfig.colorSpace;
        const videoElement = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Video,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].PixelWidth,
                    data: trackData.info.width
                },
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].PixelHeight,
                    data: trackData.info.height
                },
                trackData.info.alphaMode ? {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].AlphaMode,
                    data: 1
                } : null,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["colorSpaceIsComplete"])(colorSpace) ? {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Colour,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].MatrixCoefficients,
                            data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MATRIX_COEFFICIENTS_MAP"][colorSpace.matrix]
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TransferCharacteristics,
                            data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TRANSFER_CHARACTERISTICS_MAP"][colorSpace.transfer]
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Primaries,
                            data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COLOR_PRIMARIES_MAP"][colorSpace.primaries]
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Range,
                            data: colorSpace.fullRange ? 2 : 1
                        }
                    ]
                } : null,
                flippedRotation ? {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Projection,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ProjectionType,
                            data: 0
                        },
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ProjectionPoseRoll,
                            data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLFloat32"]((flippedRotation + 180) % 360 - 180)
                        }
                    ]
                } : null
            ]
        };
        elements.push(videoElement);
        return elements;
    }
    audioSpecificTrackInfo(trackData) {
        const pcmInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PCM_AUDIO_CODECS"].includes(trackData.track.source._codec) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePcmCodec"])(trackData.track.source._codec) : null;
        return [
            trackData.info.decoderConfig.description ? {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecPrivate,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toUint8Array"])(trackData.info.decoderConfig.description)
            } : null,
            {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Audio,
                data: [
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SamplingFrequency,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLFloat32"](trackData.info.sampleRate)
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Channels,
                        data: trackData.info.numberOfChannels
                    },
                    pcmInfo ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BitDepth,
                        data: 8 * pcmInfo.sampleSize
                    } : null
                ]
            }
        ];
    }
    subtitleSpecificTrackInfo(trackData) {
        return [
            {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CodecPrivate,
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(trackData.info.config.description)
            }
        ];
    }
    maybeCreateTags() {
        const simpleTags = [];
        const addSimpleTag = (key, value)=>{
            simpleTags.push({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SimpleTag,
                data: [
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagName,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](key)
                    },
                    typeof value === 'string' ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagString,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](value)
                    } : {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TagBinary,
                        data: value
                    }
                ]
            });
        };
        const metadataTags = this.output._metadataTags;
        const writtenTags = new Set();
        for (const { key, value } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keyValueIterator"])(metadataTags)){
            switch(key){
                case 'title':
                    {
                        addSimpleTag('TITLE', value);
                        writtenTags.add('TITLE');
                    }
                    ;
                    break;
                case 'description':
                    {
                        addSimpleTag('DESCRIPTION', value);
                        writtenTags.add('DESCRIPTION');
                    }
                    ;
                    break;
                case 'artist':
                    {
                        addSimpleTag('ARTIST', value);
                        writtenTags.add('ARTIST');
                    }
                    ;
                    break;
                case 'album':
                    {
                        addSimpleTag('ALBUM', value);
                        writtenTags.add('ALBUM');
                    }
                    ;
                    break;
                case 'albumArtist':
                    {
                        addSimpleTag('ALBUM_ARTIST', value);
                        writtenTags.add('ALBUM_ARTIST');
                    }
                    ;
                    break;
                case 'genre':
                    {
                        addSimpleTag('GENRE', value);
                        writtenTags.add('GENRE');
                    }
                    ;
                    break;
                case 'comment':
                    {
                        addSimpleTag('COMMENT', value);
                        writtenTags.add('COMMENT');
                    }
                    ;
                    break;
                case 'lyrics':
                    {
                        addSimpleTag('LYRICS', value);
                        writtenTags.add('LYRICS');
                    }
                    ;
                    break;
                case 'date':
                    {
                        addSimpleTag('DATE', value.toISOString().slice(0, 10));
                        writtenTags.add('DATE');
                    }
                    ;
                    break;
                case 'trackNumber':
                    {
                        const string = metadataTags.tracksTotal !== undefined ? `${value}/${metadataTags.tracksTotal}` : value.toString();
                        addSimpleTag('PART_NUMBER', string);
                        writtenTags.add('PART_NUMBER');
                    }
                    ;
                    break;
                case 'discNumber':
                    {
                        const string = metadataTags.discsTotal !== undefined ? `${value}/${metadataTags.discsTotal}` : value.toString();
                        addSimpleTag('DISC', string);
                        writtenTags.add('DISC');
                    }
                    ;
                    break;
                case 'tracksTotal':
                case 'discsTotal':
                    {
                    // Handled with trackNumber and discNumber respectively
                    }
                    ;
                    break;
                case 'images':
                case 'raw':
                    {
                    // Handled elsewhere
                    }
                    ;
                    break;
                default:
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertNever"])(key);
            }
        }
        if (metadataTags.raw) {
            for(const key in metadataTags.raw){
                const value = metadataTags.raw[key];
                if (value == null || writtenTags.has(key)) {
                    continue;
                }
                if (typeof value === 'string' || value instanceof Uint8Array) {
                    addSimpleTag(key, value);
                }
            }
        }
        if (simpleTags.length === 0) {
            return;
        }
        this.tagsElement = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tags,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Tag,
                    data: [
                        {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Targets,
                            data: [
                                {
                                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TargetTypeValue,
                                    data: 50
                                },
                                {
                                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].TargetType,
                                    data: 'MOVIE'
                                }
                            ]
                        },
                        ...simpleTags
                    ]
                }
            ]
        };
    }
    maybeCreateAttachments() {
        const metadataTags = this.output._metadataTags;
        const elements = [];
        const existingFileUids = new Set();
        const images = metadataTags.images ?? [];
        for (const image of images){
            let imageName = image.name;
            if (imageName === undefined) {
                const baseName = image.kind === 'coverFront' ? 'cover' : image.kind === 'coverBack' ? 'back' : 'image';
                imageName = baseName + ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["imageMimeTypeToExtension"])(image.mimeType) ?? '');
            }
            let fileUid;
            while(true){
                // Generate a random 64-bit unsigned integer
                fileUid = 0n;
                for(let i = 0; i < 8; i++){
                    fileUid <<= 8n;
                    fileUid |= BigInt(Math.floor(Math.random() * 256));
                }
                if (fileUid !== 0n && !existingFileUids.has(fileUid)) {
                    break;
                }
            }
            existingFileUids.add(fileUid);
            elements.push({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].AttachedFile,
                data: [
                    image.description !== undefined ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileDescription,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](image.description)
                    } : null,
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileName,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](imageName)
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileMediaType,
                        data: image.mimeType
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileData,
                        data: image.data
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileUID,
                        data: fileUid
                    }
                ]
            });
        }
        // Add all AttachedFiles from the raw metadata
        for (const [key, value] of Object.entries(metadataTags.raw ?? {})){
            if (!(value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$metadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AttachedFile"])) {
                continue;
            }
            const keyIsNumeric = /^\d+$/.test(key);
            if (!keyIsNumeric) {
                continue;
            }
            if (images.find((x)=>x.mimeType === value.mimeType && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["uint8ArraysAreEqual"])(x.data, value.data))) {
                continue;
            }
            elements.push({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].AttachedFile,
                data: [
                    value.description !== undefined ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileDescription,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](value.description)
                    } : null,
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileName,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLUnicodeString"](value.name ?? '')
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileMediaType,
                        data: value.mimeType ?? ''
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileData,
                        data: value.data
                    },
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].FileUID,
                        data: BigInt(key)
                    }
                ]
            });
        }
        if (elements.length === 0) {
            return;
        }
        this.attachmentsElement = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Attachments,
            data: elements
        };
    }
    createSegment() {
        this.createTracks();
        this.maybeCreateTags();
        this.maybeCreateAttachments();
        this.maybeCreateSeekHead(false);
        const segment = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Segment,
            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,
            data: [
                this.seekHead,
                this.segmentInfo,
                this.tracksElement,
                // Matroska spec says put this at the end of the file, but I think placing it before the first cluster
                // makes more sense, and FFmpeg agrees (argumentum ad ffmpegum fallacy)
                this.attachmentsElement,
                this.tagsElement
            ]
        };
        this.segment = segment;
        if (this.format._options.onSegmentHeader) {
            this.writer.startTrackingWrites();
        }
        this.ebmlWriter.writeEBML(segment);
        if (this.format._options.onSegmentHeader) {
            const { data, start } = this.writer.stopTrackingWrites();
            this.format._options.onSegmentHeader(data, start);
        }
    }
    createCues() {
        this.cues = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cues,
            data: []
        };
    }
    get segmentDataOffset() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.segment);
        return this.ebmlWriter.dataOffsets.get(this.segment);
    }
    allTracksAreKnown() {
        for (const track of this.output._tracks){
            if (!track.source._closed && !this.trackDatas.some((x)=>x.track === track)) {
                return false; // We haven't seen a sample from this open track yet
            }
        }
        return true;
    }
    async getMimeType() {
        await this.allTracksKnown.promise;
        const codecStrings = this.trackDatas.map((trackData)=>{
            if (trackData.type === 'video') {
                return trackData.info.decoderConfig.codec;
            } else if (trackData.type === 'audio') {
                return trackData.info.decoderConfig.codec;
            } else {
                const map = {
                    webvtt: 'wvtt'
                };
                return map[trackData.track.source._codec];
            }
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$matroska$2d$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatroskaMimeType"])({
            isWebM: this.format instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$output$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebMOutputFormat"],
            hasVideo: this.trackDatas.some((x)=>x.type === 'video'),
            hasAudio: this.trackDatas.some((x)=>x.type === 'audio'),
            codecStrings
        });
    }
    getVideoTrackData(track, packet, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateVideoChunkMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig.codedWidth !== undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig.codedHeight !== undefined);
        const newTrackData = {
            track,
            type: 'video',
            info: {
                width: meta.decoderConfig.codedWidth,
                height: meta.decoderConfig.codedHeight,
                decoderConfig: meta.decoderConfig,
                alphaMode: !!packet.sideData.alpha
            },
            chunkQueue: [],
            lastWrittenMsTimestamp: null
        };
        if (track.source._codec === 'vp9') {
            // https://www.webmproject.org/docs/container specifies that VP9 "SHOULD" make use of the CodecPrivate
            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:
            newTrackData.info.decoderConfig = {
                ...newTrackData.info.decoderConfig,
                description: new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateVp9CodecConfigurationFromCodecString"])(newTrackData.info.decoderConfig.codec))
            };
        } else if (track.source._codec === 'av1') {
            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires
            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive
            // it ourselves:
            newTrackData.info.decoderConfig = {
                ...newTrackData.info.decoderConfig,
                description: new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateAv1CodecConfigurationFromCodecString"])(newTrackData.info.decoderConfig.codec))
            };
        }
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    getAudioTrackData(track, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateAudioChunkMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.decoderConfig);
        const newTrackData = {
            track,
            type: 'audio',
            info: {
                numberOfChannels: meta.decoderConfig.numberOfChannels,
                sampleRate: meta.decoderConfig.sampleRate,
                decoderConfig: meta.decoderConfig
            },
            chunkQueue: [],
            lastWrittenMsTimestamp: null
        };
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    getSubtitleTrackData(track, meta) {
        const existingTrackData = this.trackDatas.find((x)=>x.track === track);
        if (existingTrackData) {
            return existingTrackData;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$codec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateSubtitleMetadata"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(meta.config);
        const newTrackData = {
            track,
            type: 'subtitle',
            info: {
                config: meta.config
            },
            chunkQueue: [],
            lastWrittenMsTimestamp: null
        };
        this.trackDatas.push(newTrackData);
        this.trackDatas.sort((a, b)=>a.track.id - b.track.id);
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        return newTrackData;
    }
    async addEncodedVideoPacket(track, packet, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getVideoTrackData(track, packet, meta);
            const isKeyFrame = packet.type === 'key';
            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);
            let duration = packet.duration;
            if (track.metadata.frameRate !== undefined) {
                // Constrain the time values to the frame rate
                timestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["roundToMultiple"])(timestamp, 1 / track.metadata.frameRate);
                duration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["roundToMultiple"])(duration, 1 / track.metadata.frameRate);
            }
            const additions = trackData.info.alphaMode ? packet.sideData.alpha ?? null : null;
            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type, additions);
            if (track.source._codec === 'vp9') this.fixVP9ColorSpace(trackData, videoChunk);
            trackData.chunkQueue.push(videoChunk);
            await this.interleaveChunks();
        } finally{
            release();
        }
    }
    async addEncodedAudioPacket(track, packet, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getAudioTrackData(track, meta);
            const isKeyFrame = packet.type === 'key';
            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);
            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);
            trackData.chunkQueue.push(audioChunk);
            await this.interleaveChunks();
        } finally{
            release();
        }
    }
    async addSubtitleCue(track, cue, meta) {
        const release = await this.mutex.acquire();
        try {
            const trackData = this.getSubtitleTrackData(track, meta);
            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);
            let bodyText = cue.text;
            const timestampMs = Math.round(timestamp * 1000);
            // Replace in-body timestamps so that they're relative to the cue start time
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlineTimestampRegex"].lastIndex = 0;
            bodyText = bodyText.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlineTimestampRegex"], (match)=>{
                const time = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSubtitleTimestamp"])(match.slice(1, -1));
                const offsetTime = time - timestampMs;
                return `<${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$subtitles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatSubtitleTimestamp"])(offsetTime)}>`;
            });
            const body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(bodyText);
            const additions = `${cue.settings ?? ''}\n${cue.identifier ?? ''}\n${cue.notes ?? ''}`;
            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textEncoder"].encode(additions) : null);
            trackData.chunkQueue.push(subtitleChunk);
            await this.interleaveChunks();
        } finally{
            release();
        }
    }
    async interleaveChunks(isFinalCall = false) {
        if (!isFinalCall && !this.allTracksAreKnown()) {
            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have
        }
        outer: while(true){
            let trackWithMinTimestamp = null;
            let minTimestamp = Infinity;
            for (const trackData of this.trackDatas){
                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {
                    break outer;
                }
                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {
                    trackWithMinTimestamp = trackData;
                    minTimestamp = trackData.chunkQueue[0].timestamp;
                }
            }
            if (!trackWithMinTimestamp) {
                break;
            }
            const chunk = trackWithMinTimestamp.chunkQueue.shift();
            this.writeBlock(trackWithMinTimestamp, chunk);
        }
        if (!isFinalCall) {
            await this.writer.flush();
        }
    }
    /**
     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often
     * lack color space information. This method patches in that information.
     */ fixVP9ColorSpace(trackData, chunk) {
        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf
        if (chunk.type !== 'key') return;
        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix) return;
        const bitstream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Bitstream"](chunk.data);
        bitstream.skipBits(2);
        const profileLowBit = bitstream.readBits(1);
        const profileHighBit = bitstream.readBits(1);
        const profile = (profileHighBit << 1) + profileLowBit;
        if (profile === 3) bitstream.skipBits(1);
        const showExistingFrame = bitstream.readBits(1);
        if (showExistingFrame) return;
        const frameType = bitstream.readBits(1);
        if (frameType !== 0) return; // Just to be sure
        bitstream.skipBits(2);
        const syncCode = bitstream.readBits(24);
        if (syncCode !== 0x498342) return;
        if (profile >= 2) bitstream.skipBits(1);
        const colorSpaceID = {
            rgb: 7,
            bt709: 2,
            bt470bg: 1,
            smpte170m: 3
        }[trackData.info.decoderConfig.colorSpace.matrix];
        // The bitstream position is now at the start of the color space bits.
        // We can use the global writeBits function here as requested.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["writeBits"])(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);
    }
    /** Converts a read-only external chunk into an internal one for easier use. */ createInternalChunk(data, timestamp, duration, type, additions = null) {
        const internalChunk = {
            data,
            type,
            timestamp,
            duration,
            additions
        };
        return internalChunk;
    }
    /** Writes a block containing media data to the file. */ writeBlock(trackData, chunk) {
        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.
        if (!this.segment) {
            this.createSegment();
        }
        const msTimestamp = Math.round(1000 * chunk.timestamp);
        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to
        // start the new one with a key frame.
        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData)=>{
            if (trackData === otherTrackData) {
                return chunk.type === 'key';
            }
            const firstQueuedSample = otherTrackData.chunkQueue[0];
            if (firstQueuedSample) {
                return firstQueuedSample.type === 'key';
            }
            return otherTrackData.track.source._closed;
        });
        let shouldCreateNewCluster = false;
        if (!this.currentCluster) {
            shouldCreateNewCluster = true;
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentClusterStartMsTimestamp !== null);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentClusterMaxMsTimestamp !== null);
            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;
            shouldCreateNewCluster = keyFrameQueuedEverywhere && msTimestamp > this.currentClusterMaxMsTimestamp && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1) || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;
        }
        if (shouldCreateNewCluster) {
            this.createNewCluster(msTimestamp);
        }
        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;
        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {
            // The block lies too far in the past, it's not representable within this cluster
            return;
        }
        const prelude = new Uint8Array(4);
        const view = new DataView(prelude.buffer);
        // 0x80 to indicate it's the last byte of a multi-byte number
        view.setUint8(0, 0x80 | trackData.track.id);
        view.setInt16(1, relativeTimestamp, false);
        const msDuration = Math.round(1000 * chunk.duration);
        if (!chunk.additions) {
            // No additions, we can write out a SimpleBlock
            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)
            const simpleBlock = {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].SimpleBlock,
                data: [
                    prelude,
                    chunk.data
                ]
            };
            this.ebmlWriter.writeEBML(simpleBlock);
        } else {
            const blockGroup = {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockGroup,
                data: [
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Block,
                        data: [
                            prelude,
                            chunk.data
                        ]
                    },
                    chunk.type === 'delta' ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].ReferenceBlock,
                        data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLSignedInt"](trackData.lastWrittenMsTimestamp - msTimestamp)
                    } : null,
                    chunk.additions ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAdditions,
                        data: [
                            {
                                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockMore,
                                data: [
                                    {
                                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAddID,
                                        data: 1
                                    },
                                    {
                                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockAdditional,
                                        data: chunk.additions
                                    }
                                ]
                            }
                        ]
                    } : null,
                    msDuration > 0 ? {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].BlockDuration,
                        data: msDuration
                    } : null
                ]
            };
            this.ebmlWriter.writeEBML(blockGroup);
        }
        this.duration = Math.max(this.duration, msTimestamp + msDuration);
        trackData.lastWrittenMsTimestamp = msTimestamp;
        if (!this.trackDatasInCurrentCluster.has(trackData)) {
            this.trackDatasInCurrentCluster.set(trackData, {
                firstMsTimestamp: msTimestamp
            });
        }
        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);
    }
    /** Creates a new Cluster element to contain media chunks. */ createNewCluster(msTimestamp) {
        if (this.currentCluster) {
            this.finalizeCurrentCluster();
        }
        if (this.format._options.onCluster) {
            this.writer.startTrackingWrites();
        }
        this.currentCluster = {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Cluster,
            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,
            data: [
                {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].Timestamp,
                    data: msTimestamp
                }
            ]
        };
        this.ebmlWriter.writeEBML(this.currentCluster);
        this.currentClusterStartMsTimestamp = msTimestamp;
        this.currentClusterMaxMsTimestamp = msTimestamp;
        this.trackDatasInCurrentCluster.clear();
    }
    finalizeCurrentCluster() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentCluster);
        if (!this.format._options.appendOnly) {
            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);
            const endPos = this.writer.getPos();
            // Write the size now that we know it
            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);
            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);
            this.writer.seek(endPos);
        }
        if (this.format._options.onCluster) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.currentClusterStartMsTimestamp !== null);
            const { data, start } = this.writer.stopTrackingWrites();
            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);
        }
        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;
        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp
        const groupedByTimestamp = new Map();
        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster){
            if (!groupedByTimestamp.has(firstMsTimestamp)) {
                groupedByTimestamp.set(firstMsTimestamp, []);
            }
            groupedByTimestamp.get(firstMsTimestamp).push(trackData);
        }
        const groupedAndSortedByTimestamp = [
            ...groupedByTimestamp.entries()
        ].sort((a, b)=>a[0] - b[0]);
        // Add CuePoints to the Cues element for better seeking
        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.cues);
            this.cues.data.push({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CuePoint,
                data: [
                    {
                        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTime,
                        data: msTimestamp
                    },
                    // Create CueTrackPositions for each track that starts at this timestamp
                    ...trackDatas.map((trackData)=>{
                        return {
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTrackPositions,
                            data: [
                                {
                                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueTrack,
                                    data: trackData.track.id
                                },
                                {
                                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLId"].CueClusterPosition,
                                    data: clusterOffsetFromSegment
                                }
                            ]
                        };
                    })
                ]
            });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    async onTrackClose() {
        const release = await this.mutex.acquire();
        if (this.allTracksAreKnown()) {
            this.allTracksKnown.resolve();
        }
        // Since a track is now closed, we may be able to write out chunks that were previously waiting
        await this.interleaveChunks();
        release();
    }
    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */ async finalize() {
        const release = await this.mutex.acquire();
        this.allTracksKnown.resolve();
        if (!this.segment) {
            this.createSegment();
        }
        // Flush any remaining queued chunks to the file
        await this.interleaveChunks(true);
        if (this.currentCluster) {
            this.finalizeCurrentCluster();
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.cues);
        this.ebmlWriter.writeEBML(this.cues);
        if (!this.format._options.appendOnly) {
            const endPos = this.writer.getPos();
            // Write the Segment size
            const segmentSize = this.writer.getPos() - this.segmentDataOffset;
            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);
            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);
            // Write the duration of the media to the Segment
            this.segmentDuration.data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$matroska$2f$ebml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EBMLFloat64"](this.duration);
            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));
            this.ebmlWriter.writeEBML(this.segmentDuration);
            // Fill in SeekHead position data and write it again
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mediabunny$2f$dist$2f$modules$2f$src$2f$misc$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.seekHead);
            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));
            this.maybeCreateSeekHead(true);
            this.ebmlWriter.writeEBML(this.seekHead);
            this.writer.seek(endPos);
        }
        release();
    }
}
}),
];

//# sourceMappingURL=node_modules_mediabunny_dist_modules_src_matroska_8aead891._.js.map