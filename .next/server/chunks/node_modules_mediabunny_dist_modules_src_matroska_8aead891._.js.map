{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/matroska/ebml.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assertNever, textDecoder, textEncoder } from '../misc.js';\nimport { readBytes, readF32Be, readF64Be, readU8 } from '../reader.js';\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat32 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat64 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLSignedInt {\n    constructor(value) {\n        this.value = value;\n    }\n}\nexport class EBMLUnicodeString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Defines some of the EBML IDs used by Matroska files. */\nexport var EBMLId;\n(function (EBMLId) {\n    EBMLId[EBMLId[\"EBML\"] = 440786851] = \"EBML\";\n    EBMLId[EBMLId[\"EBMLVersion\"] = 17030] = \"EBMLVersion\";\n    EBMLId[EBMLId[\"EBMLReadVersion\"] = 17143] = \"EBMLReadVersion\";\n    EBMLId[EBMLId[\"EBMLMaxIDLength\"] = 17138] = \"EBMLMaxIDLength\";\n    EBMLId[EBMLId[\"EBMLMaxSizeLength\"] = 17139] = \"EBMLMaxSizeLength\";\n    EBMLId[EBMLId[\"DocType\"] = 17026] = \"DocType\";\n    EBMLId[EBMLId[\"DocTypeVersion\"] = 17031] = \"DocTypeVersion\";\n    EBMLId[EBMLId[\"DocTypeReadVersion\"] = 17029] = \"DocTypeReadVersion\";\n    EBMLId[EBMLId[\"Void\"] = 236] = \"Void\";\n    EBMLId[EBMLId[\"Segment\"] = 408125543] = \"Segment\";\n    EBMLId[EBMLId[\"SeekHead\"] = 290298740] = \"SeekHead\";\n    EBMLId[EBMLId[\"Seek\"] = 19899] = \"Seek\";\n    EBMLId[EBMLId[\"SeekID\"] = 21419] = \"SeekID\";\n    EBMLId[EBMLId[\"SeekPosition\"] = 21420] = \"SeekPosition\";\n    EBMLId[EBMLId[\"Duration\"] = 17545] = \"Duration\";\n    EBMLId[EBMLId[\"Info\"] = 357149030] = \"Info\";\n    EBMLId[EBMLId[\"TimestampScale\"] = 2807729] = \"TimestampScale\";\n    EBMLId[EBMLId[\"MuxingApp\"] = 19840] = \"MuxingApp\";\n    EBMLId[EBMLId[\"WritingApp\"] = 22337] = \"WritingApp\";\n    EBMLId[EBMLId[\"Tracks\"] = 374648427] = \"Tracks\";\n    EBMLId[EBMLId[\"TrackEntry\"] = 174] = \"TrackEntry\";\n    EBMLId[EBMLId[\"TrackNumber\"] = 215] = \"TrackNumber\";\n    EBMLId[EBMLId[\"TrackUID\"] = 29637] = \"TrackUID\";\n    EBMLId[EBMLId[\"TrackType\"] = 131] = \"TrackType\";\n    EBMLId[EBMLId[\"FlagEnabled\"] = 185] = \"FlagEnabled\";\n    EBMLId[EBMLId[\"FlagDefault\"] = 136] = \"FlagDefault\";\n    EBMLId[EBMLId[\"FlagForced\"] = 21930] = \"FlagForced\";\n    EBMLId[EBMLId[\"FlagOriginal\"] = 21934] = \"FlagOriginal\";\n    EBMLId[EBMLId[\"FlagHearingImpaired\"] = 21931] = \"FlagHearingImpaired\";\n    EBMLId[EBMLId[\"FlagVisualImpaired\"] = 21932] = \"FlagVisualImpaired\";\n    EBMLId[EBMLId[\"FlagCommentary\"] = 21935] = \"FlagCommentary\";\n    EBMLId[EBMLId[\"FlagLacing\"] = 156] = \"FlagLacing\";\n    EBMLId[EBMLId[\"Name\"] = 21358] = \"Name\";\n    EBMLId[EBMLId[\"Language\"] = 2274716] = \"Language\";\n    EBMLId[EBMLId[\"LanguageBCP47\"] = 2274717] = \"LanguageBCP47\";\n    EBMLId[EBMLId[\"CodecID\"] = 134] = \"CodecID\";\n    EBMLId[EBMLId[\"CodecPrivate\"] = 25506] = \"CodecPrivate\";\n    EBMLId[EBMLId[\"CodecDelay\"] = 22186] = \"CodecDelay\";\n    EBMLId[EBMLId[\"SeekPreRoll\"] = 22203] = \"SeekPreRoll\";\n    EBMLId[EBMLId[\"DefaultDuration\"] = 2352003] = \"DefaultDuration\";\n    EBMLId[EBMLId[\"Video\"] = 224] = \"Video\";\n    EBMLId[EBMLId[\"PixelWidth\"] = 176] = \"PixelWidth\";\n    EBMLId[EBMLId[\"PixelHeight\"] = 186] = \"PixelHeight\";\n    EBMLId[EBMLId[\"AlphaMode\"] = 21440] = \"AlphaMode\";\n    EBMLId[EBMLId[\"Audio\"] = 225] = \"Audio\";\n    EBMLId[EBMLId[\"SamplingFrequency\"] = 181] = \"SamplingFrequency\";\n    EBMLId[EBMLId[\"Channels\"] = 159] = \"Channels\";\n    EBMLId[EBMLId[\"BitDepth\"] = 25188] = \"BitDepth\";\n    EBMLId[EBMLId[\"SimpleBlock\"] = 163] = \"SimpleBlock\";\n    EBMLId[EBMLId[\"BlockGroup\"] = 160] = \"BlockGroup\";\n    EBMLId[EBMLId[\"Block\"] = 161] = \"Block\";\n    EBMLId[EBMLId[\"BlockAdditions\"] = 30113] = \"BlockAdditions\";\n    EBMLId[EBMLId[\"BlockMore\"] = 166] = \"BlockMore\";\n    EBMLId[EBMLId[\"BlockAdditional\"] = 165] = \"BlockAdditional\";\n    EBMLId[EBMLId[\"BlockAddID\"] = 238] = \"BlockAddID\";\n    EBMLId[EBMLId[\"BlockDuration\"] = 155] = \"BlockDuration\";\n    EBMLId[EBMLId[\"ReferenceBlock\"] = 251] = \"ReferenceBlock\";\n    EBMLId[EBMLId[\"Cluster\"] = 524531317] = \"Cluster\";\n    EBMLId[EBMLId[\"Timestamp\"] = 231] = \"Timestamp\";\n    EBMLId[EBMLId[\"Cues\"] = 475249515] = \"Cues\";\n    EBMLId[EBMLId[\"CuePoint\"] = 187] = \"CuePoint\";\n    EBMLId[EBMLId[\"CueTime\"] = 179] = \"CueTime\";\n    EBMLId[EBMLId[\"CueTrackPositions\"] = 183] = \"CueTrackPositions\";\n    EBMLId[EBMLId[\"CueTrack\"] = 247] = \"CueTrack\";\n    EBMLId[EBMLId[\"CueClusterPosition\"] = 241] = \"CueClusterPosition\";\n    EBMLId[EBMLId[\"Colour\"] = 21936] = \"Colour\";\n    EBMLId[EBMLId[\"MatrixCoefficients\"] = 21937] = \"MatrixCoefficients\";\n    EBMLId[EBMLId[\"TransferCharacteristics\"] = 21946] = \"TransferCharacteristics\";\n    EBMLId[EBMLId[\"Primaries\"] = 21947] = \"Primaries\";\n    EBMLId[EBMLId[\"Range\"] = 21945] = \"Range\";\n    EBMLId[EBMLId[\"Projection\"] = 30320] = \"Projection\";\n    EBMLId[EBMLId[\"ProjectionType\"] = 30321] = \"ProjectionType\";\n    EBMLId[EBMLId[\"ProjectionPoseRoll\"] = 30325] = \"ProjectionPoseRoll\";\n    EBMLId[EBMLId[\"Attachments\"] = 423732329] = \"Attachments\";\n    EBMLId[EBMLId[\"AttachedFile\"] = 24999] = \"AttachedFile\";\n    EBMLId[EBMLId[\"FileDescription\"] = 18046] = \"FileDescription\";\n    EBMLId[EBMLId[\"FileName\"] = 18030] = \"FileName\";\n    EBMLId[EBMLId[\"FileMediaType\"] = 18016] = \"FileMediaType\";\n    EBMLId[EBMLId[\"FileData\"] = 18012] = \"FileData\";\n    EBMLId[EBMLId[\"FileUID\"] = 18094] = \"FileUID\";\n    EBMLId[EBMLId[\"Chapters\"] = 272869232] = \"Chapters\";\n    EBMLId[EBMLId[\"Tags\"] = 307544935] = \"Tags\";\n    EBMLId[EBMLId[\"Tag\"] = 29555] = \"Tag\";\n    EBMLId[EBMLId[\"Targets\"] = 25536] = \"Targets\";\n    EBMLId[EBMLId[\"TargetTypeValue\"] = 26826] = \"TargetTypeValue\";\n    EBMLId[EBMLId[\"TargetType\"] = 25546] = \"TargetType\";\n    EBMLId[EBMLId[\"TagTrackUID\"] = 25541] = \"TagTrackUID\";\n    EBMLId[EBMLId[\"TagEditionUID\"] = 25545] = \"TagEditionUID\";\n    EBMLId[EBMLId[\"TagChapterUID\"] = 25540] = \"TagChapterUID\";\n    EBMLId[EBMLId[\"TagAttachmentUID\"] = 25542] = \"TagAttachmentUID\";\n    EBMLId[EBMLId[\"SimpleTag\"] = 26568] = \"SimpleTag\";\n    EBMLId[EBMLId[\"TagName\"] = 17827] = \"TagName\";\n    EBMLId[EBMLId[\"TagLanguage\"] = 17530] = \"TagLanguage\";\n    EBMLId[EBMLId[\"TagString\"] = 17543] = \"TagString\";\n    EBMLId[EBMLId[\"TagBinary\"] = 17541] = \"TagBinary\";\n    EBMLId[EBMLId[\"ContentEncodings\"] = 28032] = \"ContentEncodings\";\n    EBMLId[EBMLId[\"ContentEncoding\"] = 25152] = \"ContentEncoding\";\n    EBMLId[EBMLId[\"ContentEncodingOrder\"] = 20529] = \"ContentEncodingOrder\";\n    EBMLId[EBMLId[\"ContentEncodingScope\"] = 20530] = \"ContentEncodingScope\";\n    EBMLId[EBMLId[\"ContentCompression\"] = 20532] = \"ContentCompression\";\n    EBMLId[EBMLId[\"ContentCompAlgo\"] = 16980] = \"ContentCompAlgo\";\n    EBMLId[EBMLId[\"ContentCompSettings\"] = 16981] = \"ContentCompSettings\";\n    EBMLId[EBMLId[\"ContentEncryption\"] = 20533] = \"ContentEncryption\";\n})(EBMLId || (EBMLId = {}));\nexport const LEVEL_0_EBML_IDS = [\n    EBMLId.EBML,\n    EBMLId.Segment,\n];\n// All the stuff that can appear in a segment, basically\nexport const LEVEL_1_EBML_IDS = [\n    EBMLId.SeekHead,\n    EBMLId.Info,\n    EBMLId.Cluster,\n    EBMLId.Tracks,\n    EBMLId.Cues,\n    EBMLId.Attachments,\n    EBMLId.Chapters,\n    EBMLId.Tags,\n];\nexport const LEVEL_0_AND_1_EBML_IDS = [\n    ...LEVEL_0_EBML_IDS,\n    ...LEVEL_1_EBML_IDS,\n];\nexport const measureUnsignedInt = (value) => {\n    if (value < (1 << 8)) {\n        return 1;\n    }\n    else if (value < (1 << 16)) {\n        return 2;\n    }\n    else if (value < (1 << 24)) {\n        return 3;\n    }\n    else if (value < 2 ** 32) {\n        return 4;\n    }\n    else if (value < 2 ** 40) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureUnsignedBigInt = (value) => {\n    if (value < (1n << 8n)) {\n        return 1;\n    }\n    else if (value < (1n << 16n)) {\n        return 2;\n    }\n    else if (value < (1n << 24n)) {\n        return 3;\n    }\n    else if (value < (1n << 32n)) {\n        return 4;\n    }\n    else if (value < (1n << 40n)) {\n        return 5;\n    }\n    else if (value < (1n << 48n)) {\n        return 6;\n    }\n    else if (value < (1n << 56n)) {\n        return 7;\n    }\n    else {\n        return 8;\n    }\n};\nexport const measureSignedInt = (value) => {\n    if (value >= -(1 << 6) && value < (1 << 6)) {\n        return 1;\n    }\n    else if (value >= -(1 << 13) && value < (1 << 13)) {\n        return 2;\n    }\n    else if (value >= -(1 << 20) && value < (1 << 20)) {\n        return 3;\n    }\n    else if (value >= -(1 << 27) && value < (1 << 27)) {\n        return 4;\n    }\n    else if (value >= -(2 ** 34) && value < 2 ** 34) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store\n         * 127 because \"all bits set to one\" is a reserved value. Same thing for the\n         * other cases below:\n         */\n        return 1;\n    }\n    else if (value < (1 << 14) - 1) {\n        return 2;\n    }\n    else if (value < (1 << 21) - 1) {\n        return 3;\n    }\n    else if (value < (1 << 28) - 1) {\n        return 4;\n    }\n    else if (value < 2 ** 35 - 1) {\n        return 5;\n    }\n    else if (value < 2 ** 42 - 1) {\n        return 6;\n    }\n    else {\n        throw new Error('EBML varint size not supported ' + value);\n    }\n};\nexport class EBMLWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where EBML elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */\n        this.dataOffsets = new WeakMap();\n    }\n    writeByte(value) {\n        this.helperView.setUint8(0, value);\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeFloat32(value) {\n        this.helperView.setFloat32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeFloat64(value) {\n        this.helperView.setFloat64(0, value, false);\n        this.writer.write(this.helper);\n    }\n    writeUnsignedInt(value, width = measureUnsignedInt(value)) {\n        let pos = 0;\n        // Each case falls through:\n        switch (width) {\n            case 6:\n                // Need to use division to access >32 bits of floating point var\n                this.helperView.setUint8(pos++, (value / 2 ** 40) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 5:\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 4:\n                this.helperView.setUint8(pos++, value >> 24);\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                this.helperView.setUint8(pos++, value >> 16);\n            // eslint-disable-next-line no-fallthrough\n            case 2:\n                this.helperView.setUint8(pos++, value >> 8);\n            // eslint-disable-next-line no-fallthrough\n            case 1:\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad unsigned int size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeUnsignedBigInt(value, width = measureUnsignedBigInt(value)) {\n        let pos = 0;\n        for (let i = width - 1; i >= 0; i--) {\n            this.helperView.setUint8(pos++, Number((value >> BigInt(i * 8)) & 0xffn));\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeSignedInt(value, width = measureSignedInt(value)) {\n        if (value < 0) {\n            // Two's complement stuff\n            value += 2 ** (width * 8);\n        }\n        this.writeUnsignedInt(value, width);\n    }\n    writeVarInt(value, width = measureVarInt(value)) {\n        let pos = 0;\n        switch (width) {\n            case 1:\n                this.helperView.setUint8(pos++, (1 << 7) | value);\n                break;\n            case 2:\n                this.helperView.setUint8(pos++, (1 << 6) | (value >> 8));\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 3:\n                this.helperView.setUint8(pos++, (1 << 5) | (value >> 16));\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 4:\n                this.helperView.setUint8(pos++, (1 << 4) | (value >> 24));\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 5:\n                /**\n                 * JavaScript converts its doubles to 32-bit integers for bitwise\n                 * operations, so we need to do a division by 2^32 instead of a\n                 * right-shift of 32 to retain those top 3 bits\n                 */\n                this.helperView.setUint8(pos++, (1 << 3) | ((value / 2 ** 32) & 0x7));\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 6:\n                this.helperView.setUint8(pos++, (1 << 2) | ((value / 2 ** 40) & 0x3));\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad EBML varint size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeAsciiString(str) {\n        this.writer.write(new Uint8Array(str.split('').map(x => x.charCodeAt(0))));\n    }\n    writeEBML(data) {\n        if (data === null)\n            return;\n        if (data instanceof Uint8Array) {\n            this.writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            for (const elem of data) {\n                this.writeEBML(elem);\n            }\n        }\n        else {\n            this.offsets.set(data, this.writer.getPos());\n            this.writeUnsignedInt(data.id); // ID field\n            if (Array.isArray(data.data)) {\n                const sizePos = this.writer.getPos();\n                const sizeSize = data.size === -1 ? 1 : (data.size ?? 4);\n                if (data.size === -1) {\n                    // Write the reserved all-one-bits marker for unknown/unbounded size.\n                    this.writeByte(0xff);\n                }\n                else {\n                    this.writer.seek(this.writer.getPos() + sizeSize);\n                }\n                const startPos = this.writer.getPos();\n                this.dataOffsets.set(data, startPos);\n                this.writeEBML(data.data);\n                if (data.size !== -1) {\n                    const size = this.writer.getPos() - startPos;\n                    const endPos = this.writer.getPos();\n                    this.writer.seek(sizePos);\n                    this.writeVarInt(size, sizeSize);\n                    this.writer.seek(endPos);\n                }\n            }\n            else if (typeof data.data === 'number') {\n                const size = data.size ?? measureUnsignedInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedInt(data.data, size);\n            }\n            else if (typeof data.data === 'bigint') {\n                const size = data.size ?? measureUnsignedBigInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedBigInt(data.data, size);\n            }\n            else if (typeof data.data === 'string') {\n                this.writeVarInt(data.data.length);\n                this.writeAsciiString(data.data);\n            }\n            else if (data.data instanceof Uint8Array) {\n                this.writeVarInt(data.data.byteLength, data.size);\n                this.writer.write(data.data);\n            }\n            else if (data.data instanceof EBMLFloat32) {\n                this.writeVarInt(4);\n                this.writeFloat32(data.data.value);\n            }\n            else if (data.data instanceof EBMLFloat64) {\n                this.writeVarInt(8);\n                this.writeFloat64(data.data.value);\n            }\n            else if (data.data instanceof EBMLSignedInt) {\n                const size = data.size ?? measureSignedInt(data.data.value);\n                this.writeVarInt(size);\n                this.writeSignedInt(data.data.value, size);\n            }\n            else if (data.data instanceof EBMLUnicodeString) {\n                const bytes = textEncoder.encode(data.data.value);\n                this.writeVarInt(bytes.length);\n                this.writer.write(bytes);\n            }\n            else {\n                assertNever(data.data);\n            }\n        }\n    }\n}\nexport const MAX_VAR_INT_SIZE = 8;\nexport const MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size\nexport const MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size\nexport const readVarIntSize = (slice) => {\n    const firstByte = readU8(slice);\n    slice.skip(-1);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    let width = 1;\n    let mask = 0x80;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    return width;\n};\nexport const readVarInt = (slice) => {\n    // Read the first byte to determine the width of the variable-length integer\n    const firstByte = readU8(slice);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    // Find the position of VINT_MARKER, which determines the width\n    let width = 1;\n    let mask = 1 << 7;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    // First byte's value needs the marker bit cleared\n    let value = firstByte & (mask - 1);\n    // Read remaining bytes\n    for (let i = 1; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedInt = (slice, width) => {\n    if (width < 1 || width > 8) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0;\n    // Read bytes from most significant to least significant\n    for (let i = 0; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedBigInt = (slice, width) => {\n    if (width < 1) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0n;\n    for (let i = 0; i < width; i++) {\n        value <<= 8n;\n        value += BigInt(readU8(slice));\n    }\n    return value;\n};\nexport const readSignedInt = (slice, width) => {\n    let value = readUnsignedInt(slice, width);\n    // If the highest bit is set, convert from two's complement\n    if (value & (1 << (width * 8 - 1))) {\n        value -= 2 ** (width * 8);\n    }\n    return value;\n};\nexport const readElementId = (slice) => {\n    const size = readVarIntSize(slice);\n    if (size === null) {\n        return null;\n    }\n    const id = readUnsignedInt(slice, size);\n    return id;\n};\nexport const readElementSize = (slice) => {\n    let size = readU8(slice);\n    if (size === 0xff) {\n        size = null;\n    }\n    else {\n        slice.skip(-1);\n        size = readVarInt(slice);\n        // In some (livestreamed) files, this is the value of the size field. While this technically is just a very\n        // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We\n        // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works\n        // nonetheless.\n        // eslint-disable-next-line no-loss-of-precision\n        if (size === 0x00ffffffffffffff) {\n            size = null;\n        }\n    }\n    return size;\n};\nexport const readElementHeader = (slice) => {\n    const id = readElementId(slice);\n    if (id === null) {\n        return null;\n    }\n    const size = readElementSize(slice);\n    return { id, size };\n};\nexport const readAsciiString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return String.fromCharCode(...bytes.subarray(0, strLength));\n};\nexport const readUnicodeString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return textDecoder.decode(bytes.subarray(0, strLength));\n};\nexport const readFloat = (slice, width) => {\n    if (width === 0) {\n        return 0;\n    }\n    if (width !== 4 && width !== 8) {\n        throw new Error('Bad float size ' + width);\n    }\n    return width === 4 ? readF32Be(slice) : readF64Be(slice);\n};\n/** Returns the byte offset in the file of the next element with a matching ID. */\nexport const searchForNextElementId = async (reader, startPos, ids, until) => {\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const elementHeader = readElementHeader(slice);\n        if (!elementHeader) {\n            break;\n        }\n        if (idsSet.has(elementHeader.id)) {\n            return { pos: currentPos, found: true };\n        }\n        assertDefinedSize(elementHeader.size);\n        currentPos = slice.filePos + elementHeader.size;\n    }\n    return { pos: (until !== null && until > currentPos) ? until : currentPos, found: false };\n};\n/** Searches for the next occurrence of an element ID using a naive byte-wise search. */\nexport const resync = async (reader, startPos, ids, until) => {\n    const CHUNK_SIZE = 2 ** 16; // So we don't need to grab thousands of slices\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, 0, Math.min(CHUNK_SIZE, until - currentPos));\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        if (slice.length < MAX_VAR_INT_SIZE)\n            break;\n        for (let i = 0; i < slice.length - MAX_VAR_INT_SIZE; i++) {\n            slice.filePos = currentPos;\n            const elementId = readElementId(slice);\n            if (elementId !== null && idsSet.has(elementId)) {\n                return currentPos;\n            }\n            currentPos++;\n        }\n    }\n    return null;\n};\nexport const CODEC_STRING_MAP = {\n    'avc': 'V_MPEG4/ISO/AVC',\n    'hevc': 'V_MPEGH/ISO/HEVC',\n    'vp8': 'V_VP8',\n    'vp9': 'V_VP9',\n    'av1': 'V_AV1',\n    'aac': 'A_AAC',\n    'mp3': 'A_MPEG/L3',\n    'opus': 'A_OPUS',\n    'vorbis': 'A_VORBIS',\n    'flac': 'A_FLAC',\n    'pcm-u8': 'A_PCM/INT/LIT',\n    'pcm-s16': 'A_PCM/INT/LIT',\n    'pcm-s16be': 'A_PCM/INT/BIG',\n    'pcm-s24': 'A_PCM/INT/LIT',\n    'pcm-s24be': 'A_PCM/INT/BIG',\n    'pcm-s32': 'A_PCM/INT/LIT',\n    'pcm-s32be': 'A_PCM/INT/BIG',\n    'pcm-f32': 'A_PCM/FLOAT/IEEE',\n    'pcm-f64': 'A_PCM/FLOAT/IEEE',\n    'webvtt': 'S_TEXT/WEBVTT',\n};\nexport function assertDefinedSize(size) {\n    if (size === null) {\n        throw new Error('Undefined element size is used in a place where it is not supported.');\n    }\n}\n;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildMatroskaMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isWebM ? 'webm' : 'x-matroska');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings.filter(Boolean))];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AACM,MAAM,wBAAwB,CAAC;IAClC,MAAM,OAAO,KAAK,QAAQ,GACpB,WACA,KAAK,QAAQ,GACT,WACA;IACV,IAAI,SAAS,OAAO,CAAC,KAAK,MAAM,GAAG,SAAS,YAAY;IACxD,IAAI,KAAK,YAAY,CAAC,MAAM,GAAG,GAAG;QAC9B,MAAM,uBAAuB;eAAI,IAAI,IAAI,KAAK,YAAY,CAAC,MAAM,CAAC;SAAU;QAC5E,UAAU,CAAC,UAAU,EAAE,qBAAqB,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/matroska/matroska-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAv1CodecInfoFromPacket, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, extractVp9CodecInfoFromPacket, } from '../codec-data.js';\nimport { extractAudioCodecString, extractVideoCodecString, OPUS_SAMPLE_RATE, } from '../codec.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { AttachedFile, DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { assert, binarySearchLessOrEqual, COLOR_PRIMARIES_MAP_INVERSE, findLastIndex, isIso639Dash2LanguageCode, last, MATRIX_COEFFICIENTS_MAP_INVERSE, normalizeRotation, roundIfAlmostInteger, TRANSFER_CHARACTERISTICS_MAP_INVERSE, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { assertDefinedSize, CODEC_STRING_MAP, EBMLId, LEVEL_0_AND_1_EBML_IDS, LEVEL_1_EBML_IDS, MAX_HEADER_SIZE, MIN_HEADER_SIZE, readAsciiString, readUnicodeString, readElementHeader, readElementId, readFloat, readUnsignedInt, readVarInt, resync, searchForNextElementId, readUnsignedBigInt, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { FileSlice, readBytes, readI16Be, readU8 } from '../reader.js';\nvar BlockLacing;\n(function (BlockLacing) {\n    BlockLacing[BlockLacing[\"None\"] = 0] = \"None\";\n    BlockLacing[BlockLacing[\"Xiph\"] = 1] = \"Xiph\";\n    BlockLacing[BlockLacing[\"FixedSize\"] = 2] = \"FixedSize\";\n    BlockLacing[BlockLacing[\"Ebml\"] = 3] = \"Ebml\";\n})(BlockLacing || (BlockLacing = {}));\nvar ContentEncodingScope;\n(function (ContentEncodingScope) {\n    ContentEncodingScope[ContentEncodingScope[\"Block\"] = 1] = \"Block\";\n    ContentEncodingScope[ContentEncodingScope[\"Private\"] = 2] = \"Private\";\n    ContentEncodingScope[ContentEncodingScope[\"Next\"] = 4] = \"Next\";\n})(ContentEncodingScope || (ContentEncodingScope = {}));\nvar ContentCompAlgo;\n(function (ContentCompAlgo) {\n    ContentCompAlgo[ContentCompAlgo[\"Zlib\"] = 0] = \"Zlib\";\n    ContentCompAlgo[ContentCompAlgo[\"Bzlib\"] = 1] = \"Bzlib\";\n    ContentCompAlgo[ContentCompAlgo[\"lzo1x\"] = 2] = \"lzo1x\";\n    ContentCompAlgo[ContentCompAlgo[\"HeaderStripping\"] = 3] = \"HeaderStripping\";\n})(ContentCompAlgo || (ContentCompAlgo = {}));\nconst METADATA_ELEMENTS = [\n    { id: EBMLId.SeekHead, flag: 'seekHeadSeen' },\n    { id: EBMLId.Info, flag: 'infoSeen' },\n    { id: EBMLId.Tracks, flag: 'tracksSeen' },\n    { id: EBMLId.Cues, flag: 'cuesSeen' },\n];\nconst MAX_RESYNC_LENGTH = 10 * 2 ** 20; // 10 MiB\nexport class MatroskaDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.readMetadataPromise = null;\n        this.segments = [];\n        this.currentSegment = null;\n        this.currentTrack = null;\n        this.currentCluster = null;\n        this.currentBlock = null;\n        this.currentBlockAdditional = null;\n        this.currentCueTime = null;\n        this.currentDecodingInstruction = null;\n        this.currentTagTargetIsMovie = true;\n        this.currentSimpleTagName = null;\n        this.currentAttachedFile = null;\n        this.isWebM = false;\n        this.reader = input._reader;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.segments.flatMap(segment => segment.tracks.map(track => track.inputTrack));\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const tracks = await this.getTracks();\n        const codecStrings = await Promise.all(tracks.map(x => x.getCodecParameterString()));\n        return buildMatroskaMimeType({\n            isWebM: this.isWebM,\n            hasVideo: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'video')),\n            hasAudio: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'audio')),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        // Load metadata tags from each segment lazily (only once)\n        for (const segment of this.segments) {\n            if (!segment.metadataTagsCollected) {\n                if (this.reader.fileSize !== null) {\n                    await this.loadSegmentMetadata(segment);\n                }\n                else {\n                    // The seeking would be too crazy, let's not\n                }\n                segment.metadataTagsCollected = true;\n            }\n        }\n        // This is kinda handwavy, and how we handle multiple segments isn't suuuuper well-defined anyway; so we just\n        // shallow-merge metadata tags from all (usually just one) segments.\n        let metadataTags = {};\n        for (const segment of this.segments) {\n            metadataTags = { ...metadataTags, ...segment.metadataTags };\n        }\n        return metadataTags;\n    }\n    readMetadata() {\n        return this.readMetadataPromise ??= (async () => {\n            let currentPos = 0;\n            // Loop over all top-level elements in the file\n            while (true) {\n                let slice = this.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const header = readElementHeader(slice);\n                if (!header) {\n                    break; // Zero padding at the end of the file triggers this, for example\n                }\n                const id = header.id;\n                let size = header.size;\n                const dataStartPos = slice.filePos;\n                if (id === EBMLId.EBML) {\n                    assertDefinedSize(size);\n                    let slice = this.reader.requestSlice(dataStartPos, size);\n                    if (slice instanceof Promise)\n                        slice = await slice;\n                    if (!slice)\n                        break;\n                    this.readContiguousElements(slice);\n                }\n                else if (id === EBMLId.Segment) { // Segment found!\n                    await this.readSegment(dataStartPos, size);\n                    if (size === null) {\n                        // Segment sizes can be undefined (common in livestreamed files), so assume this is the last\n                        // and only segment\n                        break;\n                    }\n                    if (this.reader.fileSize === null) {\n                        break; // Stop at the first segment\n                    }\n                }\n                else if (id === EBMLId.Cluster) {\n                    if (this.reader.fileSize === null) {\n                        break; // Shouldn't be reached anyway, since we stop at the first segment\n                    }\n                    // Clusters are not a top-level element in Matroska, but some files contain a Segment whose size\n                    // doesn't contain any of the clusters that follow it. In the case, we apply the following logic: if\n                    // we find a top-level cluster, attribute it to the previous segment.\n                    if (size === null) {\n                        // Just in case this is one of those weird sizeless clusters, let's do our best and still try to\n                        // determine its size.\n                        const nextElementPos = await searchForNextElementId(this.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, this.reader.fileSize);\n                        size = nextElementPos.pos - dataStartPos;\n                    }\n                    const lastSegment = last(this.segments);\n                    if (lastSegment) {\n                        // Extend the previous segment's size\n                        lastSegment.elementEndPos = dataStartPos + size;\n                    }\n                }\n                assertDefinedSize(size);\n                currentPos = dataStartPos + size;\n            }\n        })();\n    }\n    async readSegment(segmentDataStart, dataSize) {\n        this.currentSegment = {\n            seekHeadSeen: false,\n            infoSeen: false,\n            tracksSeen: false,\n            cuesSeen: false,\n            tagsSeen: false,\n            attachmentsSeen: false,\n            timestampScale: -1,\n            timestampFactor: -1,\n            duration: -1,\n            seekEntries: [],\n            tracks: [],\n            cuePoints: [],\n            dataStartPos: segmentDataStart,\n            elementEndPos: dataSize === null\n                ? null // Assume it goes until the end of the file\n                : segmentDataStart + dataSize,\n            clusterSeekStartPos: segmentDataStart,\n            lastReadCluster: null,\n            metadataTags: {},\n            metadataTagsCollected: false,\n        };\n        this.segments.push(this.currentSegment);\n        let currentPos = segmentDataStart;\n        while (this.currentSegment.elementEndPos === null || currentPos < this.currentSegment.elementEndPos) {\n            let slice = this.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const elementStartPos = currentPos;\n            const header = readElementHeader(slice);\n            if (!header || (!LEVEL_1_EBML_IDS.includes(header.id) && header.id !== EBMLId.Void)) {\n                // Potential junk. Let's try to resync\n                const nextPos = await resync(this.reader, elementStartPos, LEVEL_1_EBML_IDS, Math.min(this.currentSegment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));\n                if (nextPos) {\n                    currentPos = nextPos;\n                    continue;\n                }\n                else {\n                    break; // Resync failed\n                }\n            }\n            const { id, size } = header;\n            const dataStartPos = slice.filePos;\n            const metadataElementIndex = METADATA_ELEMENTS.findIndex(x => x.id === id);\n            if (metadataElementIndex !== -1) {\n                const field = METADATA_ELEMENTS[metadataElementIndex].flag;\n                this.currentSegment[field] = true;\n                assertDefinedSize(size);\n                let slice = this.reader.requestSlice(dataStartPos, size);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (slice) {\n                    this.readContiguousElements(slice);\n                }\n            }\n            else if (id === EBMLId.Tags || id === EBMLId.Attachments) {\n                // Metadata found at the beginning of the segment, great, let's parse it\n                if (id === EBMLId.Tags) {\n                    this.currentSegment.tagsSeen = true;\n                }\n                else {\n                    this.currentSegment.attachmentsSeen = true;\n                }\n                assertDefinedSize(size);\n                let slice = this.reader.requestSlice(dataStartPos, size);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (slice) {\n                    this.readContiguousElements(slice);\n                }\n            }\n            else if (id === EBMLId.Cluster) {\n                this.currentSegment.clusterSeekStartPos = elementStartPos;\n                break; // Stop at the first cluster\n            }\n            if (size === null) {\n                break;\n            }\n            else {\n                currentPos = dataStartPos + size;\n            }\n        }\n        // Sort the seek entries by file position so reading them exhibits a sequential pattern\n        this.currentSegment.seekEntries.sort((a, b) => a.segmentPosition - b.segmentPosition);\n        if (this.reader.fileSize !== null) {\n            // Use the seek head to read missing metadata elements\n            for (const seekEntry of this.currentSegment.seekEntries) {\n                const target = METADATA_ELEMENTS.find(x => x.id === seekEntry.id);\n                if (!target) {\n                    continue;\n                }\n                if (this.currentSegment[target.flag])\n                    continue;\n                let slice = this.reader.requestSliceRange(segmentDataStart + seekEntry.segmentPosition, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    continue;\n                const header = readElementHeader(slice);\n                if (!header)\n                    continue;\n                const { id, size } = header;\n                if (id !== target.id)\n                    continue;\n                assertDefinedSize(size);\n                this.currentSegment[target.flag] = true;\n                let dataSlice = this.reader.requestSlice(slice.filePos, size);\n                if (dataSlice instanceof Promise)\n                    dataSlice = await dataSlice;\n                if (!dataSlice)\n                    continue;\n                this.readContiguousElements(dataSlice);\n            }\n        }\n        if (this.currentSegment.timestampScale === -1) {\n            // TimestampScale element is missing. Technically an invalid file, but let's default to the typical value,\n            // which is 1e6.\n            this.currentSegment.timestampScale = 1e6;\n            this.currentSegment.timestampFactor = 1e9 / 1e6;\n        }\n        // Put default tracks first\n        this.currentSegment.tracks.sort((a, b) => Number(b.disposition.default) - Number(a.disposition.default));\n        // Now, let's distribute the cue points to the tracks\n        const idToTrack = new Map(this.currentSegment.tracks.map(x => [x.id, x]));\n        // Assign cue points to their respective tracks\n        for (const cuePoint of this.currentSegment.cuePoints) {\n            const track = idToTrack.get(cuePoint.trackId);\n            if (track) {\n                track.cuePoints.push(cuePoint);\n            }\n        }\n        for (const track of this.currentSegment.tracks) {\n            // Sort cue points by time\n            track.cuePoints.sort((a, b) => a.time - b.time);\n            // Remove multiple cue points for the same time\n            for (let i = 0; i < track.cuePoints.length - 1; i++) {\n                const cuePoint1 = track.cuePoints[i];\n                const cuePoint2 = track.cuePoints[i + 1];\n                if (cuePoint1.time === cuePoint2.time) {\n                    track.cuePoints.splice(i + 1, 1);\n                    i--;\n                }\n            }\n        }\n        let trackWithMostCuePoints = null;\n        let maxCuePointCount = -Infinity;\n        for (const track of this.currentSegment.tracks) {\n            if (track.cuePoints.length > maxCuePointCount) {\n                maxCuePointCount = track.cuePoints.length;\n                trackWithMostCuePoints = track;\n            }\n        }\n        // For every track that has received 0 cue points (can happen, often only the video track receives cue points),\n        // we still want to have better seeking. Therefore, let's give it the cue points of the track with the most cue\n        // points, which should provide us with the most fine-grained seeking.\n        for (const track of this.currentSegment.tracks) {\n            if (track.cuePoints.length === 0) {\n                track.cuePoints = trackWithMostCuePoints.cuePoints;\n            }\n        }\n        this.currentSegment = null;\n    }\n    async readCluster(startPos, segment) {\n        if (segment.lastReadCluster?.elementStartPos === startPos) {\n            return segment.lastReadCluster;\n        }\n        let headerSlice = this.reader.requestSliceRange(startPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (headerSlice instanceof Promise)\n            headerSlice = await headerSlice;\n        assert(headerSlice);\n        const elementStartPos = startPos;\n        const elementHeader = readElementHeader(headerSlice);\n        assert(elementHeader);\n        const id = elementHeader.id;\n        assert(id === EBMLId.Cluster);\n        let size = elementHeader.size;\n        const dataStartPos = headerSlice.filePos;\n        if (size === null) {\n            // The cluster's size is undefined (can happen in livestreamed files). We'd still like to know the size of\n            // it, so we have no other choice but to iterate over the EBML structure until we find an element at level\n            // 0 or 1, indicating the end of the cluster (all elements inside the cluster are at level 2).\n            const nextElementPos = await searchForNextElementId(this.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n            size = nextElementPos.pos - dataStartPos;\n        }\n        // Load the entire cluster\n        let dataSlice = this.reader.requestSlice(dataStartPos, size);\n        if (dataSlice instanceof Promise)\n            dataSlice = await dataSlice;\n        const cluster = {\n            segment,\n            elementStartPos,\n            elementEndPos: dataStartPos + size,\n            dataStartPos,\n            timestamp: -1,\n            trackData: new Map(),\n        };\n        this.currentCluster = cluster;\n        if (dataSlice) {\n            // Read the children of the cluster, stopping early at level 0 or 1 EBML elements. We do this because some\n            // clusters have incorrect sizes that are too large\n            const endPos = this.readContiguousElements(dataSlice, LEVEL_0_AND_1_EBML_IDS);\n            cluster.elementEndPos = endPos;\n        }\n        for (const [, trackData] of cluster.trackData) {\n            const track = trackData.track;\n            // This must hold, as track datas only get created if a block for that track is encountered\n            assert(trackData.blocks.length > 0);\n            let hasLacedBlocks = false;\n            for (let i = 0; i < trackData.blocks.length; i++) {\n                const block = trackData.blocks[i];\n                block.timestamp += cluster.timestamp;\n                hasLacedBlocks ||= block.lacing !== BlockLacing.None;\n            }\n            trackData.presentationTimestamps = trackData.blocks\n                .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                .sort((a, b) => a.timestamp - b.timestamp);\n            for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                const currentEntry = trackData.presentationTimestamps[i];\n                const currentBlock = trackData.blocks[currentEntry.blockIndex];\n                if (trackData.firstKeyFrameTimestamp === null && currentBlock.isKeyFrame) {\n                    trackData.firstKeyFrameTimestamp = currentBlock.timestamp;\n                }\n                if (i < trackData.presentationTimestamps.length - 1) {\n                    // Update block durations based on presentation order\n                    const nextEntry = trackData.presentationTimestamps[i + 1];\n                    currentBlock.duration = nextEntry.timestamp - currentBlock.timestamp;\n                }\n                else if (currentBlock.duration === 0) {\n                    if (track.defaultDuration != null) {\n                        if (currentBlock.lacing === BlockLacing.None) {\n                            currentBlock.duration = track.defaultDuration;\n                        }\n                        else {\n                            // Handled by the lace resolution code\n                        }\n                    }\n                }\n            }\n            if (hasLacedBlocks) {\n                // Perform lace resolution. Here, we expand each laced block into multiple blocks where each contains\n                // one frame of the lace. We do this after determining block timestamps so we can properly distribute\n                // the block's duration across the laced frames.\n                this.expandLacedBlocks(trackData.blocks, track);\n                // Recompute since blocks have changed\n                trackData.presentationTimestamps = trackData.blocks\n                    .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                    .sort((a, b) => a.timestamp - b.timestamp);\n            }\n            const firstBlock = trackData.blocks[trackData.presentationTimestamps[0].blockIndex];\n            const lastBlock = trackData.blocks[last(trackData.presentationTimestamps).blockIndex];\n            trackData.startTimestamp = firstBlock.timestamp;\n            trackData.endTimestamp = lastBlock.timestamp + lastBlock.duration;\n            // Let's remember that a cluster with a given timestamp is here, speeding up future lookups if no cues exist\n            const insertionIndex = binarySearchLessOrEqual(track.clusterPositionCache, trackData.startTimestamp, x => x.startTimestamp);\n            if (insertionIndex === -1\n                || track.clusterPositionCache[insertionIndex].elementStartPos !== elementStartPos) {\n                track.clusterPositionCache.splice(insertionIndex + 1, 0, {\n                    elementStartPos: cluster.elementStartPos,\n                    startTimestamp: trackData.startTimestamp,\n                });\n            }\n        }\n        segment.lastReadCluster = cluster;\n        return cluster;\n    }\n    getTrackDataInCluster(cluster, trackNumber) {\n        let trackData = cluster.trackData.get(trackNumber);\n        if (!trackData) {\n            const track = cluster.segment.tracks.find(x => x.id === trackNumber);\n            if (!track) {\n                return null;\n            }\n            trackData = {\n                track,\n                startTimestamp: 0,\n                endTimestamp: 0,\n                firstKeyFrameTimestamp: null,\n                blocks: [],\n                presentationTimestamps: [],\n            };\n            cluster.trackData.set(trackNumber, trackData);\n        }\n        return trackData;\n    }\n    expandLacedBlocks(blocks, track) {\n        // https://www.matroska.org/technical/notes.html#block-lacing\n        for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n            const originalBlock = blocks[blockIndex];\n            if (originalBlock.lacing === BlockLacing.None) {\n                continue;\n            }\n            // Decode the block data if it hasn't been decoded yet (needed for lacing expansion)\n            if (!originalBlock.decoded) {\n                originalBlock.data = this.decodeBlockData(track, originalBlock.data);\n                originalBlock.decoded = true;\n            }\n            const slice = FileSlice.tempFromBytes(originalBlock.data);\n            const frameSizes = [];\n            const frameCount = readU8(slice) + 1;\n            switch (originalBlock.lacing) {\n                case BlockLacing.Xiph:\n                    {\n                        let totalUsedSize = 0;\n                        // Xiph lacing, just like in Ogg\n                        for (let i = 0; i < frameCount - 1; i++) {\n                            let frameSize = 0;\n                            while (slice.bufferPos < slice.length) {\n                                const value = readU8(slice);\n                                frameSize += value;\n                                if (value < 255) {\n                                    frameSizes.push(frameSize);\n                                    totalUsedSize += frameSize;\n                                    break;\n                                }\n                            }\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                case BlockLacing.FixedSize:\n                    {\n                        // Fixed size lacing: all frames have same size\n                        const totalDataSize = slice.length - 1; // Minus the frame count byte\n                        const frameSize = Math.floor(totalDataSize / frameCount);\n                        for (let i = 0; i < frameCount; i++) {\n                            frameSizes.push(frameSize);\n                        }\n                    }\n                    ;\n                    break;\n                case BlockLacing.Ebml:\n                    {\n                        // EBML lacing: first size absolute, subsequent ones are coded as signed differences from the last\n                        const firstResult = readVarInt(slice);\n                        assert(firstResult !== null); // Assume it's not an invalid VINT\n                        let currentSize = firstResult;\n                        frameSizes.push(currentSize);\n                        let totalUsedSize = currentSize;\n                        for (let i = 1; i < frameCount - 1; i++) {\n                            const startPos = slice.bufferPos;\n                            const diffResult = readVarInt(slice);\n                            assert(diffResult !== null);\n                            const unsignedDiff = diffResult;\n                            const width = slice.bufferPos - startPos;\n                            const bias = (1 << (width * 7 - 1)) - 1; // Typo-corrected version of 2^((7*n)-1)^-1\n                            const diff = unsignedDiff - bias;\n                            currentSize += diff;\n                            frameSizes.push(currentSize);\n                            totalUsedSize += currentSize;\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                default: assert(false);\n            }\n            assert(frameSizes.length === frameCount);\n            blocks.splice(blockIndex, 1); // Remove the original block\n            const blockDuration = originalBlock.duration || frameCount * (track.defaultDuration ?? 0);\n            // Now, let's insert each frame as its own block\n            for (let i = 0; i < frameCount; i++) {\n                const frameSize = frameSizes[i];\n                const frameData = readBytes(slice, frameSize);\n                // Distribute timestamps evenly across the block duration\n                const frameTimestamp = originalBlock.timestamp + (blockDuration * i / frameCount);\n                const frameDuration = blockDuration / frameCount;\n                blocks.splice(blockIndex + i, 0, {\n                    timestamp: frameTimestamp,\n                    duration: frameDuration,\n                    isKeyFrame: originalBlock.isKeyFrame,\n                    data: frameData,\n                    lacing: BlockLacing.None,\n                    decoded: true,\n                    mainAdditional: originalBlock.mainAdditional,\n                });\n            }\n            blockIndex += frameCount; // Skip the blocks we just added\n            blockIndex--;\n        }\n    }\n    async loadSegmentMetadata(segment) {\n        for (const seekEntry of segment.seekEntries) {\n            if (seekEntry.id === EBMLId.Tags && !segment.tagsSeen) {\n                // We need to load the tags\n            }\n            else if (seekEntry.id === EBMLId.Attachments && !segment.attachmentsSeen) {\n                // We need to load the attachments\n            }\n            else {\n                continue;\n            }\n            let slice = this.reader.requestSliceRange(segment.dataStartPos + seekEntry.segmentPosition, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                continue;\n            const header = readElementHeader(slice);\n            if (!header || header.id !== seekEntry.id)\n                continue;\n            const { size } = header;\n            assertDefinedSize(size);\n            assert(!this.currentSegment);\n            this.currentSegment = segment;\n            let dataSlice = this.reader.requestSlice(slice.filePos, size);\n            if (dataSlice instanceof Promise)\n                dataSlice = await dataSlice;\n            if (dataSlice) {\n                this.readContiguousElements(dataSlice);\n            }\n            this.currentSegment = null;\n            // Mark as seen\n            if (seekEntry.id === EBMLId.Tags) {\n                segment.tagsSeen = true;\n            }\n            else if (seekEntry.id === EBMLId.Attachments) {\n                segment.attachmentsSeen = true;\n            }\n        }\n    }\n    readContiguousElements(slice, stopIds) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_HEADER_SIZE) {\n            const startPos = slice.filePos;\n            const foundElement = this.traverseElement(slice, stopIds);\n            if (!foundElement) {\n                return startPos;\n            }\n        }\n        return slice.filePos;\n    }\n    traverseElement(slice, stopIds) {\n        const header = readElementHeader(slice);\n        if (!header) {\n            return false;\n        }\n        if (stopIds && stopIds.includes(header.id)) {\n            return false;\n        }\n        const { id, size } = header;\n        const dataStartPos = slice.filePos;\n        assertDefinedSize(size);\n        switch (id) {\n            case EBMLId.DocType:\n                {\n                    this.isWebM = readAsciiString(slice, size) === 'webm';\n                }\n                ;\n                break;\n            case EBMLId.Seek:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    const seekEntry = { id: -1, segmentPosition: -1 };\n                    this.currentSegment.seekEntries.push(seekEntry);\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (seekEntry.id === -1 || seekEntry.segmentPosition === -1) {\n                        this.currentSegment.seekEntries.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.SeekID:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.id = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.SeekPosition:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.segmentPosition = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TimestampScale:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.timestampScale = readUnsignedInt(slice, size);\n                    this.currentSegment.timestampFactor = 1e9 / this.currentSegment.timestampScale;\n                }\n                ;\n                break;\n            case EBMLId.Duration:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.duration = readFloat(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TrackEntry:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentTrack = {\n                        id: -1,\n                        segment: this.currentSegment,\n                        demuxer: this,\n                        clusterPositionCache: [],\n                        cuePoints: [],\n                        disposition: {\n                            ...DEFAULT_TRACK_DISPOSITION,\n                        },\n                        inputTrack: null,\n                        codecId: null,\n                        codecPrivate: null,\n                        defaultDuration: null,\n                        name: null,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        decodingInstructions: [],\n                        info: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentTrack.decodingInstructions.some((instruction) => {\n                        return instruction.data?.type !== 'decompress'\n                            || instruction.scope !== ContentEncodingScope.Block\n                            || instruction.data.algorithm !== ContentCompAlgo.HeaderStripping;\n                    })) {\n                        console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`);\n                        this.currentTrack = null;\n                    }\n                    if (this.currentTrack\n                        && this.currentTrack.id !== -1\n                        && this.currentTrack.codecId\n                        && this.currentTrack.info) {\n                        const slashIndex = this.currentTrack.codecId.indexOf('/');\n                        const codecIdWithoutSuffix = slashIndex === -1\n                            ? this.currentTrack.codecId\n                            : this.currentTrack.codecId.slice(0, slashIndex);\n                        if (this.currentTrack.info.type === 'video'\n                            && this.currentTrack.info.width !== -1\n                            && this.currentTrack.info.height !== -1) {\n                            if (this.currentTrack.codecId === CODEC_STRING_MAP.avc) {\n                                this.currentTrack.info.codec = 'avc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.hevc) {\n                                this.currentTrack.info.codec = 'hevc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp8) {\n                                this.currentTrack.info.codec = 'vp8';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp9) {\n                                this.currentTrack.info.codec = 'vp9';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.av1) {\n                                this.currentTrack.info.codec = 'av1';\n                            }\n                            const videoTrack = this.currentTrack;\n                            const inputTrack = new InputVideoTrack(this.input, new MatroskaVideoTrackBacking(videoTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                        else if (this.currentTrack.info.type === 'audio'\n                            && this.currentTrack.info.numberOfChannels !== -1\n                            && this.currentTrack.info.sampleRate !== -1) {\n                            if (codecIdWithoutSuffix === CODEC_STRING_MAP.aac) {\n                                this.currentTrack.info.codec = 'aac';\n                                this.currentTrack.info.aacCodecInfo = {\n                                    isMpeg2: this.currentTrack.codecId.includes('MPEG2'),\n                                };\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.mp3) {\n                                this.currentTrack.info.codec = 'mp3';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.opus) {\n                                this.currentTrack.info.codec = 'opus';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                                this.currentTrack.info.sampleRate = OPUS_SAMPLE_RATE; // Always the same\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vorbis) {\n                                this.currentTrack.info.codec = 'vorbis';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.flac) {\n                                this.currentTrack.info.codec = 'flac';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/LIT') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/BIG') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32be';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/FLOAT/IEEE') {\n                                if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-f32';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 64) {\n                                    this.currentTrack.info.codec = 'pcm-f64';\n                                }\n                            }\n                            const audioTrack = this.currentTrack;\n                            const inputTrack = new InputAudioTrack(this.input, new MatroskaAudioTrackBacking(audioTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case EBMLId.TrackNumber:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.id = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TrackType:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const type = readUnsignedInt(slice, size);\n                    if (type === 1) {\n                        this.currentTrack.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            rotation: 0,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                            alphaMode: false,\n                        };\n                    }\n                    else if (type === 2) {\n                        this.currentTrack.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            bitDepth: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagEnabled:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const enabled = readUnsignedInt(slice, size);\n                    if (!enabled) {\n                        this.currentSegment.tracks.pop();\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagDefault:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.default = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagForced:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.forced = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagOriginal:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.original = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagHearingImpaired:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.hearingImpaired = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagVisualImpaired:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.visuallyImpaired = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagCommentary:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.commentary = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CodecID:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecId = readAsciiString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CodecPrivate:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecPrivate = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.DefaultDuration:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.defaultDuration\n                        = this.currentTrack.segment.timestampFactor * readUnsignedInt(slice, size) / 1e9;\n                }\n                ;\n                break;\n            case EBMLId.Name:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.name = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Language:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    if (this.currentTrack.languageCode !== UNDETERMINED_LANGUAGE) {\n                        // LanguageBCP47 was present, which takes precedence\n                        break;\n                    }\n                    this.currentTrack.languageCode = readAsciiString(slice, size);\n                    if (!isIso639Dash2LanguageCode(this.currentTrack.languageCode)) {\n                        this.currentTrack.languageCode = UNDETERMINED_LANGUAGE;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.LanguageBCP47:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const bcp47 = readAsciiString(slice, size);\n                    const languageSubtag = bcp47.split('-')[0];\n                    if (languageSubtag) {\n                        // Technically invalid, for now: The language subtag might be a language code from ISO 639-1,\n                        // ISO 639-2, ISO 639-3, ISO 639-5 or some other thing (source: Wikipedia). But, `languageCode` is\n                        // documented as ISO 639-2. Changing the definition would be a breaking change. This will get\n                        // cleaned up in the future by defining languageCode to be BCP 47 instead.\n                        this.currentTrack.languageCode = languageSubtag;\n                    }\n                    else {\n                        this.currentTrack.languageCode = UNDETERMINED_LANGUAGE;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Video:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.PixelWidth:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.width = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.PixelHeight:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.height = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.AlphaMode:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.alphaMode = readUnsignedInt(slice, size) === 1;\n                }\n                ;\n                break;\n            case EBMLId.Colour:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.colorSpace = {};\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.MatrixCoefficients:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const matrixCoefficients = readUnsignedInt(slice, size);\n                    const mapped = MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients] ?? null;\n                    this.currentTrack.info.colorSpace.matrix = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Range:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    this.currentTrack.info.colorSpace.fullRange = readUnsignedInt(slice, size) === 2;\n                }\n                ;\n                break;\n            case EBMLId.TransferCharacteristics:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const transferCharacteristics = readUnsignedInt(slice, size);\n                    const mapped = TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics] ?? null;\n                    this.currentTrack.info.colorSpace.transfer = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Primaries:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const primaries = readUnsignedInt(slice, size);\n                    const mapped = COLOR_PRIMARIES_MAP_INVERSE[primaries] ?? null;\n                    this.currentTrack.info.colorSpace.primaries = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Projection:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.ProjectionPoseRoll:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    const rotation = readFloat(slice, size);\n                    const flippedRotation = -rotation; // Convert counter-clockwise to clockwise\n                    try {\n                        this.currentTrack.info.rotation = normalizeRotation(flippedRotation);\n                    }\n                    catch {\n                        // It wasn't a valid rotation\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Audio:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.SamplingFrequency:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.sampleRate = readFloat(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Channels:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.numberOfChannels = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BitDepth:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.bitDepth = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CuePoint:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    this.currentCueTime = null;\n                }\n                ;\n                break;\n            case EBMLId.CueTime:\n                {\n                    this.currentCueTime = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CueTrackPositions:\n                {\n                    if (this.currentCueTime === null)\n                        break;\n                    assert(this.currentSegment);\n                    const cuePoint = { time: this.currentCueTime, trackId: -1, clusterPosition: -1 };\n                    this.currentSegment.cuePoints.push(cuePoint);\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (cuePoint.trackId === -1 || cuePoint.clusterPosition === -1) {\n                        this.currentSegment.cuePoints.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.CueTrack:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    lastCuePoint.trackId = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CueClusterPosition:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    assert(this.currentSegment);\n                    lastCuePoint.clusterPosition = this.currentSegment.dataStartPos + readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Timestamp:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.currentCluster.timestamp = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.SimpleBlock:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = readVarInt(slice);\n                    if (trackNumber === null)\n                        break;\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    if (!trackData)\n                        break; // Not a track we care about\n                    const relativeTimestamp = readI16Be(slice);\n                    const flags = readU8(slice);\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    let isKeyFrame = !!(flags & 0x80);\n                    if (trackData.track.info?.type === 'audio' && trackData.track.info.codec) {\n                        // Some files don't mark their audio packets as key packets (I'm looking at you, Firefox). But, we\n                        // can fix this in most cases: if we recognize the codec of the track, then we know every packet is\n                        // necessarily a key packet, no matter what the container says.\n                        // https://github.com/Vanilagy/mediabunny/issues/192\n                        isKeyFrame = true;\n                    }\n                    const blockData = readBytes(slice, size - (slice.filePos - dataStartPos));\n                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;\n                    trackData.blocks.push({\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame,\n                        data: blockData,\n                        lacing,\n                        decoded: !hasDecodingInstructions,\n                        mainAdditional: null,\n                    });\n                }\n                ;\n                break;\n            case EBMLId.BlockGroup:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    this.currentBlock = null;\n                }\n                ;\n                break;\n            case EBMLId.Block:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = readVarInt(slice);\n                    if (trackNumber === null)\n                        break;\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    if (!trackData)\n                        break;\n                    const relativeTimestamp = readI16Be(slice);\n                    const flags = readU8(slice);\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    const blockData = readBytes(slice, size - (slice.filePos - dataStartPos));\n                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;\n                    this.currentBlock = {\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame: true,\n                        data: blockData,\n                        lacing,\n                        decoded: !hasDecodingInstructions,\n                        mainAdditional: null,\n                    };\n                    trackData.blocks.push(this.currentBlock);\n                }\n                ;\n                break;\n            case EBMLId.BlockAdditions:\n                {\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.BlockMore:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlockAdditional = {\n                        addId: 1,\n                        data: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentBlockAdditional.data && this.currentBlockAdditional.addId === 1) {\n                        this.currentBlock.mainAdditional = this.currentBlockAdditional.data;\n                    }\n                    this.currentBlockAdditional = null;\n                }\n                ;\n                break;\n            case EBMLId.BlockAdditional:\n                {\n                    if (!this.currentBlockAdditional)\n                        break;\n                    this.currentBlockAdditional.data = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BlockAddID:\n                {\n                    if (!this.currentBlockAdditional)\n                        break;\n                    this.currentBlockAdditional.addId = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BlockDuration:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.duration = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ReferenceBlock:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.isKeyFrame = false;\n                    // We ignore the actual value here, we just use the reference as an indicator for \"not a key frame\".\n                    // This is in line with FFmpeg's behavior.\n                }\n                ;\n                break;\n            case EBMLId.Tag:\n                {\n                    this.currentTagTargetIsMovie = true;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.Targets:\n                {\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.TargetTypeValue:\n                {\n                    const targetTypeValue = readUnsignedInt(slice, size);\n                    if (targetTypeValue !== 50) {\n                        this.currentTagTargetIsMovie = false;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.TagTrackUID:\n            case EBMLId.TagEditionUID:\n            case EBMLId.TagChapterUID:\n            case EBMLId.TagAttachmentUID:\n                {\n                    this.currentTagTargetIsMovie = false;\n                }\n                ;\n                break;\n            case EBMLId.SimpleTag:\n                {\n                    if (!this.currentTagTargetIsMovie)\n                        break;\n                    this.currentSimpleTagName = null;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.TagName:\n                {\n                    this.currentSimpleTagName = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TagString:\n                {\n                    if (!this.currentSimpleTagName)\n                        break;\n                    const value = readUnicodeString(slice, size);\n                    this.processTagValue(this.currentSimpleTagName, value);\n                }\n                ;\n                break;\n            case EBMLId.TagBinary:\n                {\n                    if (!this.currentSimpleTagName)\n                        break;\n                    const value = readBytes(slice, size);\n                    this.processTagValue(this.currentSimpleTagName, value);\n                }\n                ;\n                break;\n            case EBMLId.AttachedFile:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentAttachedFile = {\n                        fileUid: null,\n                        fileName: null,\n                        fileMediaType: null,\n                        fileData: null,\n                        fileDescription: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    const tags = this.currentSegment.metadataTags;\n                    if (this.currentAttachedFile.fileUid && this.currentAttachedFile.fileData) {\n                        // All attached files get surfaced in the `raw` metadata tags\n                        tags.raw ??= {};\n                        tags.raw[this.currentAttachedFile.fileUid.toString()] = new AttachedFile(this.currentAttachedFile.fileData, this.currentAttachedFile.fileMediaType ?? undefined, this.currentAttachedFile.fileName ?? undefined, this.currentAttachedFile.fileDescription ?? undefined);\n                    }\n                    // Only process image attachments\n                    if (this.currentAttachedFile.fileMediaType?.startsWith('image/') && this.currentAttachedFile.fileData) {\n                        const fileName = this.currentAttachedFile.fileName;\n                        let kind = 'unknown';\n                        if (fileName) {\n                            const lowerName = fileName.toLowerCase();\n                            if (lowerName.startsWith('cover.')) {\n                                kind = 'coverFront';\n                            }\n                            else if (lowerName.startsWith('back.')) {\n                                kind = 'coverBack';\n                            }\n                        }\n                        tags.images ??= [];\n                        tags.images.push({\n                            data: this.currentAttachedFile.fileData,\n                            mimeType: this.currentAttachedFile.fileMediaType,\n                            kind,\n                            name: this.currentAttachedFile.fileName ?? undefined,\n                            description: this.currentAttachedFile.fileDescription ?? undefined,\n                        });\n                    }\n                    this.currentAttachedFile = null;\n                }\n                ;\n                break;\n            case EBMLId.FileUID:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileUid = readUnsignedBigInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileName:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileName = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileMediaType:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileMediaType = readAsciiString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileData:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileData = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileDescription:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileDescription = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodings:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    // \"**MUST** start with the `ContentEncoding` with the highest `ContentEncodingOrder`\"\n                    this.currentTrack.decodingInstructions.sort((a, b) => b.order - a.order);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncoding:\n                {\n                    this.currentDecodingInstruction = {\n                        order: 0,\n                        scope: ContentEncodingScope.Block,\n                        data: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentDecodingInstruction.data) {\n                        this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction);\n                    }\n                    this.currentDecodingInstruction = null;\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodingOrder:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.order = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodingScope:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.scope = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentCompression:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.data = {\n                        type: 'decompress',\n                        algorithm: ContentCompAlgo.Zlib,\n                        settings: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.ContentCompAlgo:\n                {\n                    if (this.currentDecodingInstruction?.data?.type !== 'decompress')\n                        break;\n                    this.currentDecodingInstruction.data.algorithm = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentCompSettings:\n                {\n                    if (this.currentDecodingInstruction?.data?.type !== 'decompress')\n                        break;\n                    this.currentDecodingInstruction.data.settings = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncryption:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.data = {\n                        type: 'decrypt',\n                    };\n                }\n                ;\n                break;\n        }\n        slice.filePos = dataStartPos + size;\n        return true;\n    }\n    decodeBlockData(track, rawData) {\n        assert(track.decodingInstructions.length > 0); // This method shouldn't be called otherwise\n        let currentData = rawData;\n        for (const instruction of track.decodingInstructions) {\n            assert(instruction.data);\n            switch (instruction.data.type) {\n                case 'decompress':\n                    {\n                        switch (instruction.data.algorithm) {\n                            case ContentCompAlgo.HeaderStripping:\n                                {\n                                    if (instruction.data.settings && instruction.data.settings.length > 0) {\n                                        const prefix = instruction.data.settings;\n                                        const newData = new Uint8Array(prefix.length + currentData.length);\n                                        newData.set(prefix, 0);\n                                        newData.set(currentData, prefix.length);\n                                        currentData = newData;\n                                    }\n                                }\n                                ;\n                                break;\n                            default:\n                                {\n                                    // Unhandled\n                                }\n                                ;\n                        }\n                    }\n                    ;\n                    break;\n                default:\n                    {\n                        // Unhandled\n                    }\n                    ;\n            }\n        }\n        return currentData;\n    }\n    processTagValue(name, value) {\n        if (!this.currentSegment?.metadataTags)\n            return;\n        const metadataTags = this.currentSegment.metadataTags;\n        metadataTags.raw ??= {};\n        metadataTags.raw[name] ??= value;\n        if (typeof value === 'string') {\n            switch (name.toLowerCase()) {\n                case 'title':\n                    {\n                        metadataTags.title ??= value;\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        metadataTags.description ??= value;\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        metadataTags.artist ??= value;\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        metadataTags.album ??= value;\n                    }\n                    ;\n                    break;\n                case 'album_artist':\n                    {\n                        metadataTags.albumArtist ??= value;\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        metadataTags.genre ??= value;\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        metadataTags.comment ??= value;\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        metadataTags.lyrics ??= value;\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        const date = new Date(value);\n                        if (!Number.isNaN(date.getTime())) {\n                            metadataTags.date ??= date;\n                        }\n                    }\n                    ;\n                    break;\n                case 'track_number':\n                case 'part_number':\n                    {\n                        const parts = value.split('/');\n                        const trackNum = Number.parseInt(parts[0], 10);\n                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                            metadataTags.trackNumber ??= trackNum;\n                        }\n                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                            metadataTags.tracksTotal ??= tracksTotal;\n                        }\n                    }\n                    ;\n                    break;\n                case 'disc_number':\n                case 'disc':\n                    {\n                        const discParts = value.split('/');\n                        const discNum = Number.parseInt(discParts[0], 10);\n                        const discsTotal = discParts[1] && Number.parseInt(discParts[1], 10);\n                        if (Number.isInteger(discNum) && discNum > 0) {\n                            metadataTags.discNumber ??= discNum;\n                        }\n                        if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                            metadataTags.discsTotal ??= discsTotal;\n                        }\n                    }\n                    ;\n                    break;\n            }\n        }\n    }\n}\nclass MatroskaTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToClusterLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    getInternalCodecId() {\n        return this.internalTrack.codecId;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getName() {\n        return this.internalTrack.name;\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    getTimeResolution() {\n        return this.internalTrack.segment.timestampFactor;\n    }\n    getDisposition() {\n        return this.internalTrack.disposition;\n    }\n    async getFirstPacket(options) {\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (trackData) {\n                return {\n                    blockIndex: 0,\n                    correctBlockFound: true,\n                };\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    intoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundIfAlmostInteger(timestamp * this.internalTrack.segment.timestampFactor);\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { blockIndex: -1, correctBlockFound: false };\n            }\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.timestamp);\n            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;\n            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { blockIndex, correctBlockFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performClusterLookup(locationInCluster.cluster, (cluster) => {\n            if (cluster === locationInCluster.cluster) {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (locationInCluster.blockIndex + 1 < trackData.blocks.length) {\n                    // We can simply take the next block in the cluster\n                    return {\n                        blockIndex: locationInCluster.blockIndex + 1,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (trackData) {\n                    return {\n                        blockIndex: 0,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { blockIndex: -1, correctBlockFound: false };\n            }\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const block = trackData.blocks[x.blockIndex];\n                return block.isKeyFrame && x.timestamp <= timestampInTimescale;\n            });\n            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;\n            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { blockIndex, correctBlockFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performClusterLookup(locationInCluster.cluster, (cluster) => {\n            if (cluster === locationInCluster.cluster) {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                const nextKeyFrameIndex = trackData.blocks.findIndex((x, i) => x.isKeyFrame && i > locationInCluster.blockIndex);\n                if (nextKeyFrameIndex !== -1) {\n                    // We can simply take the next key frame in the cluster\n                    return {\n                        blockIndex: nextKeyFrameIndex,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                    const keyFrameIndex = trackData.blocks.findIndex(x => x.isKeyFrame);\n                    assert(keyFrameIndex !== -1); // There must be one\n                    return {\n                        blockIndex: keyFrameIndex,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async fetchPacketInCluster(cluster, blockIndex, options) {\n        if (blockIndex === -1) {\n            return null;\n        }\n        const trackData = cluster.trackData.get(this.internalTrack.id);\n        const block = trackData.blocks[blockIndex];\n        assert(block);\n        // Perform lazy decoding if needed\n        if (!block.decoded) {\n            block.data = this.internalTrack.demuxer.decodeBlockData(this.internalTrack, block.data);\n            block.decoded = true;\n        }\n        const data = options.metadataOnly ? PLACEHOLDER_DATA : block.data;\n        const timestamp = block.timestamp / this.internalTrack.segment.timestampFactor;\n        const duration = block.duration / this.internalTrack.segment.timestampFactor;\n        const sideData = {};\n        if (block.mainAdditional && this.internalTrack.info?.type === 'video' && this.internalTrack.info.alphaMode) {\n            sideData.alpha = options.metadataOnly ? PLACEHOLDER_DATA : block.mainAdditional;\n            sideData.alphaByteLength = block.mainAdditional.byteLength;\n        }\n        const packet = new EncodedPacket(data, block.isKeyFrame ? 'key' : 'delta', timestamp, duration, cluster.dataStartPos + blockIndex, block.data.byteLength, sideData);\n        this.packetToClusterLocation.set(packet, { cluster, blockIndex });\n        return packet;\n    }\n    /** Looks for a packet in the clusters while trying to load as few clusters as possible to retrieve it. */\n    async performClusterLookup(\n    // The cluster where we start looking\n    startCluster, \n    // This function returns the best-matching block in a given cluster\n    getMatchInCluster, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct block will not come after it\n    latestTimestamp, options) {\n        const { demuxer, segment } = this.internalTrack;\n        let currentCluster = null;\n        let bestCluster = null;\n        let bestBlockIndex = -1;\n        if (startCluster) {\n            const { blockIndex, correctBlockFound } = getMatchInCluster(startCluster);\n            if (correctBlockFound) {\n                return this.fetchPacketInCluster(startCluster, blockIndex, options);\n            }\n            if (blockIndex !== -1) {\n                bestCluster = startCluster;\n                bestBlockIndex = blockIndex;\n            }\n        }\n        // Search for a cue point; this way, we won't need to start searching from the start of the file\n        // but can jump right into the correct cluster (or at least nearby).\n        const cuePointIndex = binarySearchLessOrEqual(this.internalTrack.cuePoints, searchTimestamp, x => x.time);\n        const cuePoint = cuePointIndex !== -1\n            ? this.internalTrack.cuePoints[cuePointIndex]\n            : null;\n        // Also check the position cache\n        const positionCacheIndex = binarySearchLessOrEqual(this.internalTrack.clusterPositionCache, searchTimestamp, x => x.startTimestamp);\n        const positionCacheEntry = positionCacheIndex !== -1\n            ? this.internalTrack.clusterPositionCache[positionCacheIndex]\n            : null;\n        const lookupEntryPosition = Math.max(cuePoint?.clusterPosition ?? 0, positionCacheEntry?.elementStartPos ?? 0) || null;\n        let currentPos;\n        if (!startCluster) {\n            currentPos = lookupEntryPosition ?? segment.clusterSeekStartPos;\n        }\n        else {\n            if (lookupEntryPosition === null || startCluster.elementStartPos >= lookupEntryPosition) {\n                currentPos = startCluster.elementEndPos;\n                currentCluster = startCluster;\n            }\n            else {\n                // Use the lookup entry\n                currentPos = lookupEntryPosition;\n            }\n        }\n        while (segment.elementEndPos === null || currentPos <= segment.elementEndPos - MIN_HEADER_SIZE) {\n            if (currentCluster) {\n                const trackData = currentCluster.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.startTimestamp > latestTimestamp) {\n                    // We're already past the upper bound, no need to keep searching\n                    break;\n                }\n            }\n            // Load the header\n            let slice = demuxer.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const elementStartPos = currentPos;\n            const elementHeader = readElementHeader(slice);\n            if (!elementHeader\n                || (!LEVEL_1_EBML_IDS.includes(elementHeader.id) && elementHeader.id !== EBMLId.Void)) {\n                // There's an element here that shouldn't be here. Might be garbage. In this case, let's\n                // try and resync to the next valid element.\n                const nextPos = await resync(demuxer.reader, elementStartPos, LEVEL_1_EBML_IDS, Math.min(segment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));\n                if (nextPos) {\n                    currentPos = nextPos;\n                    continue;\n                }\n                else {\n                    break; // Resync failed\n                }\n            }\n            const id = elementHeader.id;\n            let size = elementHeader.size;\n            const dataStartPos = slice.filePos;\n            if (id === EBMLId.Cluster) {\n                currentCluster = await demuxer.readCluster(elementStartPos, segment);\n                // readCluster computes the proper size even if it's undefined in the header, so let's use that instead\n                size = currentCluster.elementEndPos - dataStartPos;\n                const { blockIndex, correctBlockFound } = getMatchInCluster(currentCluster);\n                if (correctBlockFound) {\n                    return this.fetchPacketInCluster(currentCluster, blockIndex, options);\n                }\n                if (blockIndex !== -1) {\n                    bestCluster = currentCluster;\n                    bestBlockIndex = blockIndex;\n                }\n            }\n            if (size === null) {\n                // Undefined element size (can happen in livestreamed files). In this case, we need to do some\n                // searching to determine the actual size of the element.\n                assert(id !== EBMLId.Cluster); // Undefined cluster sizes are fixed further up\n                // Search for the next element at level 0 or 1\n                const nextElementPos = await searchForNextElementId(demuxer.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n                size = nextElementPos.pos - dataStartPos;\n            }\n            const endPos = dataStartPos + size;\n            if (segment.elementEndPos === null) {\n                // Check the next element. If it's a new segment, we know this segment ends here. The new\n                // segment is just ignored, since we're likely in a livestreamed file and thus only care about\n                // the first segment.\n                let slice = demuxer.reader.requestSliceRange(endPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const elementId = readElementId(slice);\n                if (elementId === EBMLId.Segment) {\n                    segment.elementEndPos = endPos; // We now know the segment's size\n                    break;\n                }\n            }\n            currentPos = endPos;\n        }\n        // Catch faulty cue points\n        if (cuePoint && (!bestCluster || bestCluster.elementStartPos < cuePoint.clusterPosition)) {\n            // The cue point lied to us! We found a cue point but no cluster there that satisfied the match. In this\n            // case, let's search again but using the cue point before that.\n            const previousCuePoint = this.internalTrack.cuePoints[cuePointIndex - 1];\n            assert(!previousCuePoint || previousCuePoint.time < cuePoint.time);\n            const newSearchTimestamp = previousCuePoint?.time ?? -Infinity;\n            return this.performClusterLookup(null, getMatchInCluster, newSearchTimestamp, latestTimestamp, options);\n        }\n        if (bestCluster) {\n            // If we finished looping but didn't find a perfect match, still return the best match we found\n            return this.fetchPacketInCluster(bestCluster, bestBlockIndex, options);\n        }\n        return null;\n    }\n}\nclass MatroskaVideoTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.info.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async canBeTransparent() {\n        return this.internalTrack.info.alphaMode;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            let firstPacket = null;\n            const needsPacketForAdditionalInfo = this.internalTrack.info.codec === 'vp9'\n                || this.internalTrack.info.codec === 'av1'\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'avc' && !this.internalTrack.info.codecDescription)\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'hevc' && !this.internalTrack.info.codecDescription);\n            if (needsPacketForAdditionalInfo) {\n                firstPacket = await this.getFirstPacket({});\n            }\n            return {\n                codec: extractVideoCodecString({\n                    width: this.internalTrack.info.width,\n                    height: this.internalTrack.info.height,\n                    codec: this.internalTrack.info.codec,\n                    codecDescription: this.internalTrack.info.codecDescription,\n                    colorSpace: this.internalTrack.info.colorSpace,\n                    avcType: 1, // We don't know better (or do we?) so just assume 'avc1'\n                    avcCodecInfo: this.internalTrack.info.codec === 'avc' && firstPacket\n                        ? extractAvcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    hevcCodecInfo: this.internalTrack.info.codec === 'hevc' && firstPacket\n                        ? extractHevcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    vp9CodecInfo: this.internalTrack.info.codec === 'vp9' && firstPacket\n                        ? extractVp9CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                    av1CodecInfo: this.internalTrack.info.codec === 'av1' && firstPacket\n                        ? extractAv1CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                }),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass MatroskaAudioTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString({\n                codec: this.internalTrack.info.codec,\n                codecDescription: this.internalTrack.info.codecDescription,\n                aacCodecInfo: this.internalTrack.info.aacCodecInfo,\n            }),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2662, "column": 0}, "map": {"version":3,"sources":["file:///C:/ata/ins_post_creator/post_kidsai%20-%20Kopya/node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, UNDETERMINED_LANGUAGE, assert, assertNever, colorSpaceIsComplete, imageMimeTypeToExtension, keyValueIterator, normalizeRotation, promiseWithResolvers, roundToMultiple, textEncoder, toUint8Array, uint8ArraysAreEqual, writeBits, } from '../misc.js';\nimport { CODEC_STRING_MAP, EBMLFloat32, EBMLFloat64, EBMLId, EBMLSignedInt, EBMLUnicodeString, EBMLWriter, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { WebMOutputFormat } from '../output-format.js';\nimport { formatSubtitleTimestamp, inlineTimestampRegex, parseSubtitleTimestamp, } from '../subtitles.js';\nimport { OPUS_SAMPLE_RATE, PCM_AUDIO_CODECS, generateAv1CodecConfigurationFromCodecString, generateVp9CodecConfigurationFromCodecString, parsePcmCodec, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { Muxer } from '../muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { AttachedFile } from '../metadata.js';\nconst MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);\nconst MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;\nconst APP_NAME = 'Mediabunny';\nconst SEGMENT_SIZE_BYTES = 6;\nconst CLUSTER_SIZE_BYTES = 5;\nconst TRACK_TYPE_MAP = {\n    video: 1,\n    audio: 2,\n    subtitle: 17,\n};\nexport class MatroskaMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.segment = null;\n        this.segmentInfo = null;\n        this.seekHead = null;\n        this.tracksElement = null;\n        this.tagsElement = null;\n        this.attachmentsElement = null;\n        this.segmentDuration = null;\n        this.cues = null;\n        this.currentCluster = null;\n        this.currentClusterStartMsTimestamp = null;\n        this.currentClusterMaxMsTimestamp = null;\n        this.trackDatasInCurrentCluster = new Map();\n        this.duration = 0;\n        this.writer = output._writer;\n        this.format = format;\n        this.ebmlWriter = new EBMLWriter(this.writer);\n        if (this.format._options.appendOnly) {\n            this.writer.ensureMonotonicity = true;\n        }\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        this.writeEBMLHeader();\n        this.createSegmentInfo();\n        this.createCues();\n        await this.writer.flush();\n        release();\n    }\n    writeEBMLHeader() {\n        if (this.format._options.onEbmlHeader) {\n            this.writer.startTrackingWrites();\n        }\n        const ebmlHeader = { id: EBMLId.EBML, data: [\n                { id: EBMLId.EBMLVersion, data: 1 },\n                { id: EBMLId.EBMLReadVersion, data: 1 },\n                { id: EBMLId.EBMLMaxIDLength, data: 4 },\n                { id: EBMLId.EBMLMaxSizeLength, data: 8 },\n                { id: EBMLId.DocType, data: this.format instanceof WebMOutputFormat ? 'webm' : 'matroska' },\n                { id: EBMLId.DocTypeVersion, data: 2 },\n                { id: EBMLId.DocTypeReadVersion, data: 2 },\n            ] };\n        this.ebmlWriter.writeEBML(ebmlHeader);\n        if (this.format._options.onEbmlHeader) {\n            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0\n            this.format._options.onEbmlHeader(data, start);\n        }\n    }\n    /**\n     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to\n     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.\n     */\n    maybeCreateSeekHead(writeOffsets) {\n        if (this.format._options.appendOnly) {\n            return;\n        }\n        const kaxCues = new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]);\n        const kaxInfo = new Uint8Array([0x15, 0x49, 0xa9, 0x66]);\n        const kaxTracks = new Uint8Array([0x16, 0x54, 0xae, 0x6b]);\n        const kaxAttachments = new Uint8Array([0x19, 0x41, 0xa4, 0x69]);\n        const kaxTags = new Uint8Array([0x12, 0x54, 0xc3, 0x67]);\n        const seekHead = { id: EBMLId.SeekHead, data: [\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxCues },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxInfo },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxTracks },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                this.attachmentsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxAttachments },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.attachmentsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n                this.tagsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxTags },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n            ] };\n        this.seekHead = seekHead;\n    }\n    createSegmentInfo() {\n        const segmentDuration = { id: EBMLId.Duration, data: new EBMLFloat64(0) };\n        this.segmentDuration = segmentDuration;\n        const segmentInfo = { id: EBMLId.Info, data: [\n                { id: EBMLId.TimestampScale, data: 1e6 },\n                { id: EBMLId.MuxingApp, data: APP_NAME },\n                { id: EBMLId.WritingApp, data: APP_NAME },\n                !this.format._options.appendOnly ? segmentDuration : null,\n            ] };\n        this.segmentInfo = segmentInfo;\n    }\n    createTracks() {\n        const tracksElement = { id: EBMLId.Tracks, data: [] };\n        this.tracksElement = tracksElement;\n        for (const trackData of this.trackDatas) {\n            const codecId = CODEC_STRING_MAP[trackData.track.source._codec];\n            assert(codecId);\n            let seekPreRollNs = 0;\n            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {\n                seekPreRollNs = 1e6 * 80; // In \"Matroska ticks\" (nanoseconds)\n                const description = trackData.info.decoderConfig.description;\n                if (description) {\n                    const bytes = toUint8Array(description);\n                    const header = parseOpusIdentificationHeader(bytes);\n                    // Use the preSkip value from the header\n                    seekPreRollNs = Math.round(1e9 * (header.preSkip / OPUS_SAMPLE_RATE));\n                }\n            }\n            tracksElement.data.push({ id: EBMLId.TrackEntry, data: [\n                    { id: EBMLId.TrackNumber, data: trackData.track.id },\n                    { id: EBMLId.TrackUID, data: trackData.track.id },\n                    { id: EBMLId.TrackType, data: TRACK_TYPE_MAP[trackData.type] },\n                    trackData.track.metadata.disposition?.default === false\n                        ? { id: EBMLId.FlagDefault, data: 0 }\n                        : null,\n                    trackData.track.metadata.disposition?.forced\n                        ? { id: EBMLId.FlagForced, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.hearingImpaired\n                        ? { id: EBMLId.FlagHearingImpaired, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.visuallyImpaired\n                        ? { id: EBMLId.FlagVisualImpaired, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.original\n                        ? { id: EBMLId.FlagOriginal, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.commentary\n                        ? { id: EBMLId.FlagCommentary, data: 1 }\n                        : null,\n                    { id: EBMLId.FlagLacing, data: 0 },\n                    { id: EBMLId.Language, data: trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE },\n                    { id: EBMLId.CodecID, data: codecId },\n                    { id: EBMLId.CodecDelay, data: 0 },\n                    { id: EBMLId.SeekPreRoll, data: seekPreRollNs },\n                    trackData.track.metadata.name !== undefined\n                        ? { id: EBMLId.Name, data: new EBMLUnicodeString(trackData.track.metadata.name) }\n                        : null,\n                    (trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null),\n                ] });\n        }\n    }\n    videoSpecificTrackInfo(trackData) {\n        const { frameRate, rotation } = trackData.track.metadata;\n        const elements = [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            (frameRate\n                ? {\n                    id: EBMLId.DefaultDuration,\n                    data: 1e9 / frameRate,\n                }\n                : null),\n        ];\n        // Convert from clockwise to counter-clockwise\n        const flippedRotation = rotation ? normalizeRotation(-rotation) : 0;\n        const colorSpace = trackData.info.decoderConfig.colorSpace;\n        const videoElement = { id: EBMLId.Video, data: [\n                { id: EBMLId.PixelWidth, data: trackData.info.width },\n                { id: EBMLId.PixelHeight, data: trackData.info.height },\n                trackData.info.alphaMode ? { id: EBMLId.AlphaMode, data: 1 } : null,\n                (colorSpaceIsComplete(colorSpace)\n                    ? {\n                        id: EBMLId.Colour,\n                        data: [\n                            {\n                                id: EBMLId.MatrixCoefficients,\n                                data: MATRIX_COEFFICIENTS_MAP[colorSpace.matrix],\n                            },\n                            {\n                                id: EBMLId.TransferCharacteristics,\n                                data: TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer],\n                            },\n                            {\n                                id: EBMLId.Primaries,\n                                data: COLOR_PRIMARIES_MAP[colorSpace.primaries],\n                            },\n                            {\n                                id: EBMLId.Range,\n                                data: colorSpace.fullRange ? 2 : 1,\n                            },\n                        ],\n                    }\n                    : null),\n                (flippedRotation\n                    ? {\n                        id: EBMLId.Projection,\n                        data: [\n                            {\n                                id: EBMLId.ProjectionType,\n                                data: 0, // rectangular\n                            },\n                            {\n                                id: EBMLId.ProjectionPoseRoll,\n                                data: new EBMLFloat32((flippedRotation + 180) % 360 - 180), // [0, 270] -> [-180, 90]\n                            },\n                        ],\n                    }\n                    : null),\n            ] };\n        elements.push(videoElement);\n        return elements;\n    }\n    audioSpecificTrackInfo(trackData) {\n        const pcmInfo = PCM_AUDIO_CODECS.includes(trackData.track.source._codec)\n            ? parsePcmCodec(trackData.track.source._codec)\n            : null;\n        return [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            { id: EBMLId.Audio, data: [\n                    { id: EBMLId.SamplingFrequency, data: new EBMLFloat32(trackData.info.sampleRate) },\n                    { id: EBMLId.Channels, data: trackData.info.numberOfChannels },\n                    pcmInfo ? { id: EBMLId.BitDepth, data: 8 * pcmInfo.sampleSize } : null,\n                ] },\n        ];\n    }\n    subtitleSpecificTrackInfo(trackData) {\n        return [\n            { id: EBMLId.CodecPrivate, data: textEncoder.encode(trackData.info.config.description) },\n        ];\n    }\n    maybeCreateTags() {\n        const simpleTags = [];\n        const addSimpleTag = (key, value) => {\n            simpleTags.push({ id: EBMLId.SimpleTag, data: [\n                    { id: EBMLId.TagName, data: new EBMLUnicodeString(key) },\n                    typeof value === 'string'\n                        ? { id: EBMLId.TagString, data: new EBMLUnicodeString(value) }\n                        : { id: EBMLId.TagBinary, data: value },\n                ] });\n        };\n        const metadataTags = this.output._metadataTags;\n        const writtenTags = new Set();\n        for (const { key, value } of keyValueIterator(metadataTags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        addSimpleTag('TITLE', value);\n                        writtenTags.add('TITLE');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        addSimpleTag('DESCRIPTION', value);\n                        writtenTags.add('DESCRIPTION');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        addSimpleTag('ARTIST', value);\n                        writtenTags.add('ARTIST');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        addSimpleTag('ALBUM', value);\n                        writtenTags.add('ALBUM');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        addSimpleTag('ALBUM_ARTIST', value);\n                        writtenTags.add('ALBUM_ARTIST');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        addSimpleTag('GENRE', value);\n                        writtenTags.add('GENRE');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        addSimpleTag('COMMENT', value);\n                        writtenTags.add('COMMENT');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        addSimpleTag('LYRICS', value);\n                        writtenTags.add('LYRICS');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        addSimpleTag('DATE', value.toISOString().slice(0, 10));\n                        writtenTags.add('DATE');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadataTags.tracksTotal !== undefined\n                            ? `${value}/${metadataTags.tracksTotal}`\n                            : value.toString();\n                        addSimpleTag('PART_NUMBER', string);\n                        writtenTags.add('PART_NUMBER');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = metadataTags.discsTotal !== undefined\n                            ? `${value}/${metadataTags.discsTotal}`\n                            : value.toString();\n                        addSimpleTag('DISC', string);\n                        writtenTags.add('DISC');\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'images':\n                case 'raw':\n                    {\n                        // Handled elsewhere\n                    }\n                    ;\n                    break;\n                default: assertNever(key);\n            }\n        }\n        if (metadataTags.raw) {\n            for (const key in metadataTags.raw) {\n                const value = metadataTags.raw[key];\n                if (value == null || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string' || value instanceof Uint8Array) {\n                    addSimpleTag(key, value);\n                }\n            }\n        }\n        if (simpleTags.length === 0) {\n            return;\n        }\n        this.tagsElement = {\n            id: EBMLId.Tags,\n            data: [{ id: EBMLId.Tag, data: [\n                        { id: EBMLId.Targets, data: [\n                                { id: EBMLId.TargetTypeValue, data: 50 },\n                                { id: EBMLId.TargetType, data: 'MOVIE' },\n                            ] },\n                        ...simpleTags,\n                    ] }],\n        };\n    }\n    maybeCreateAttachments() {\n        const metadataTags = this.output._metadataTags;\n        const elements = [];\n        const existingFileUids = new Set();\n        const images = metadataTags.images ?? [];\n        for (const image of images) {\n            let imageName = image.name;\n            if (imageName === undefined) {\n                const baseName = image.kind === 'coverFront' ? 'cover' : image.kind === 'coverBack' ? 'back' : 'image';\n                imageName = baseName + (imageMimeTypeToExtension(image.mimeType) ?? '');\n            }\n            let fileUid;\n            while (true) {\n                // Generate a random 64-bit unsigned integer\n                fileUid = 0n;\n                for (let i = 0; i < 8; i++) {\n                    fileUid <<= 8n;\n                    fileUid |= BigInt(Math.floor(Math.random() * 256));\n                }\n                if (fileUid !== 0n && !existingFileUids.has(fileUid)) {\n                    break;\n                }\n            }\n            existingFileUids.add(fileUid);\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    image.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(image.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(imageName) },\n                    { id: EBMLId.FileMediaType, data: image.mimeType },\n                    { id: EBMLId.FileData, data: image.data },\n                    { id: EBMLId.FileUID, data: fileUid },\n                ],\n            });\n        }\n        // Add all AttachedFiles from the raw metadata\n        for (const [key, value] of Object.entries(metadataTags.raw ?? {})) {\n            if (!(value instanceof AttachedFile)) {\n                continue;\n            }\n            const keyIsNumeric = /^\\d+$/.test(key);\n            if (!keyIsNumeric) {\n                continue;\n            }\n            if (images.find(x => x.mimeType === value.mimeType && uint8ArraysAreEqual(x.data, value.data))) {\n                // This attached file has very likely already been added as an image above\n                // (happens when remuxing Matroska)\n                continue;\n            }\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    value.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(value.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(value.name ?? '') },\n                    { id: EBMLId.FileMediaType, data: value.mimeType ?? '' },\n                    { id: EBMLId.FileData, data: value.data },\n                    { id: EBMLId.FileUID, data: BigInt(key) },\n                ],\n            });\n        }\n        if (elements.length === 0) {\n            return;\n        }\n        this.attachmentsElement = { id: EBMLId.Attachments, data: elements };\n    }\n    createSegment() {\n        this.createTracks();\n        this.maybeCreateTags();\n        this.maybeCreateAttachments();\n        this.maybeCreateSeekHead(false);\n        const segment = {\n            id: EBMLId.Segment,\n            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,\n            data: [\n                this.seekHead, // null if append-only\n                this.segmentInfo,\n                this.tracksElement,\n                // Matroska spec says put this at the end of the file, but I think placing it before the first cluster\n                // makes more sense, and FFmpeg agrees (argumentum ad ffmpegum fallacy)\n                this.attachmentsElement,\n                this.tagsElement,\n            ],\n        };\n        this.segment = segment;\n        if (this.format._options.onSegmentHeader) {\n            this.writer.startTrackingWrites();\n        }\n        this.ebmlWriter.writeEBML(segment);\n        if (this.format._options.onSegmentHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onSegmentHeader(data, start);\n        }\n    }\n    createCues() {\n        this.cues = { id: EBMLId.Cues, data: [] };\n    }\n    get segmentDataOffset() {\n        assert(this.segment);\n        return this.ebmlWriter.dataOffsets.get(this.segment);\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildMatroskaMimeType({\n            isWebM: this.format instanceof WebMOutputFormat,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        assert(meta.decoderConfig.codedWidth !== undefined);\n        assert(meta.decoderConfig.codedHeight !== undefined);\n        const newTrackData = {\n            track,\n            type: 'video',\n            info: {\n                width: meta.decoderConfig.codedWidth,\n                height: meta.decoderConfig.codedHeight,\n                decoderConfig: meta.decoderConfig,\n                alphaMode: !!packet.sideData.alpha, // The first packet determines if this track has alpha or not\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        if (track.source._codec === 'vp9') {\n            // https://www.webmproject.org/docs/container specifies that VP9 \"SHOULD\" make use of the CodecPrivate\n            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateVp9CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        else if (track.source._codec === 'av1') {\n            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires\n            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive\n            // it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateAv1CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            const isKeyFrame = packet.type === 'key';\n            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            let duration = packet.duration;\n            if (track.metadata.frameRate !== undefined) {\n                // Constrain the time values to the frame rate\n                timestamp = roundToMultiple(timestamp, 1 / track.metadata.frameRate);\n                duration = roundToMultiple(duration, 1 / track.metadata.frameRate);\n            }\n            const additions = trackData.info.alphaMode\n                ? packet.sideData.alpha ?? null\n                : null;\n            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type, additions);\n            if (track.source._codec === 'vp9')\n                this.fixVP9ColorSpace(trackData, videoChunk);\n            trackData.chunkQueue.push(videoChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);\n            trackData.chunkQueue.push(audioChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            let bodyText = cue.text;\n            const timestampMs = Math.round(timestamp * 1000);\n            // Replace in-body timestamps so that they're relative to the cue start time\n            inlineTimestampRegex.lastIndex = 0;\n            bodyText = bodyText.replace(inlineTimestampRegex, (match) => {\n                const time = parseSubtitleTimestamp(match.slice(1, -1));\n                const offsetTime = time - timestampMs;\n                return `<${formatSubtitleTimestamp(offsetTime)}>`;\n            });\n            const body = textEncoder.encode(bodyText);\n            const additions = `${cue.settings ?? ''}\\n${cue.identifier ?? ''}\\n${cue.notes ?? ''}`;\n            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? textEncoder.encode(additions) : null);\n            trackData.chunkQueue.push(subtitleChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async interleaveChunks(isFinalCall = false) {\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.chunkQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const chunk = trackWithMinTimestamp.chunkQueue.shift();\n            this.writeBlock(trackWithMinTimestamp, chunk);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    /**\n     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often\n     * lack color space information. This method patches in that information.\n     */\n    fixVP9ColorSpace(trackData, chunk) {\n        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n        if (chunk.type !== 'key')\n            return;\n        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix)\n            return;\n        const bitstream = new Bitstream(chunk.data);\n        bitstream.skipBits(2);\n        const profileLowBit = bitstream.readBits(1);\n        const profileHighBit = bitstream.readBits(1);\n        const profile = (profileHighBit << 1) + profileLowBit;\n        if (profile === 3)\n            bitstream.skipBits(1);\n        const showExistingFrame = bitstream.readBits(1);\n        if (showExistingFrame)\n            return;\n        const frameType = bitstream.readBits(1);\n        if (frameType !== 0)\n            return; // Just to be sure\n        bitstream.skipBits(2);\n        const syncCode = bitstream.readBits(24);\n        if (syncCode !== 0x498342)\n            return;\n        if (profile >= 2)\n            bitstream.skipBits(1);\n        const colorSpaceID = {\n            rgb: 7,\n            bt709: 2,\n            bt470bg: 1,\n            smpte170m: 3,\n        }[trackData.info.decoderConfig.colorSpace.matrix];\n        // The bitstream position is now at the start of the color space bits.\n        // We can use the global writeBits function here as requested.\n        writeBits(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);\n    }\n    /** Converts a read-only external chunk into an internal one for easier use. */\n    createInternalChunk(data, timestamp, duration, type, additions = null) {\n        const internalChunk = {\n            data,\n            type,\n            timestamp,\n            duration,\n            additions,\n        };\n        return internalChunk;\n    }\n    /** Writes a block containing media data to the file. */\n    writeBlock(trackData, chunk) {\n        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.\n        if (!this.segment) {\n            this.createSegment();\n        }\n        const msTimestamp = Math.round(1000 * chunk.timestamp);\n        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to\n        // start the new one with a key frame.\n        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n            if (trackData === otherTrackData) {\n                return chunk.type === 'key';\n            }\n            const firstQueuedSample = otherTrackData.chunkQueue[0];\n            if (firstQueuedSample) {\n                return firstQueuedSample.type === 'key';\n            }\n            return otherTrackData.track.source._closed;\n        });\n        let shouldCreateNewCluster = false;\n        if (!this.currentCluster) {\n            shouldCreateNewCluster = true;\n        }\n        else {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            assert(this.currentClusterMaxMsTimestamp !== null);\n            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n            shouldCreateNewCluster = (keyFrameQueuedEverywhere\n                // This check is required because that means there is already a block with this timestamp in the\n                // CURRENT chunk, meaning that starting the next cluster at the same timestamp is forbidden (since\n                // the already-written block would belong into it instead).\n                && msTimestamp > this.currentClusterMaxMsTimestamp\n                && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1))\n                // The cluster would exceed its maximum allowed length. This puts us in an unfortunate position and forces\n                // us to begin the next cluster with a delta frame. Although this is undesirable, it is not forbidden by the\n                // spec and is supported by players.\n                || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;\n        }\n        if (shouldCreateNewCluster) {\n            this.createNewCluster(msTimestamp);\n        }\n        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {\n            // The block lies too far in the past, it's not representable within this cluster\n            return;\n        }\n        const prelude = new Uint8Array(4);\n        const view = new DataView(prelude.buffer);\n        // 0x80 to indicate it's the last byte of a multi-byte number\n        view.setUint8(0, 0x80 | trackData.track.id);\n        view.setInt16(1, relativeTimestamp, false);\n        const msDuration = Math.round(1000 * chunk.duration);\n        if (!chunk.additions) {\n            // No additions, we can write out a SimpleBlock\n            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)\n            const simpleBlock = { id: EBMLId.SimpleBlock, data: [\n                    prelude,\n                    chunk.data,\n                ] };\n            this.ebmlWriter.writeEBML(simpleBlock);\n        }\n        else {\n            const blockGroup = { id: EBMLId.BlockGroup, data: [\n                    { id: EBMLId.Block, data: [\n                            prelude,\n                            chunk.data,\n                        ] },\n                    chunk.type === 'delta'\n                        ? {\n                            id: EBMLId.ReferenceBlock,\n                            data: new EBMLSignedInt(trackData.lastWrittenMsTimestamp - msTimestamp),\n                        }\n                        : null,\n                    chunk.additions\n                        ? { id: EBMLId.BlockAdditions, data: [\n                                { id: EBMLId.BlockMore, data: [\n                                        { id: EBMLId.BlockAddID, data: 1 }, // Some players expect BlockAddID to come first\n                                        { id: EBMLId.BlockAdditional, data: chunk.additions },\n                                    ] },\n                            ] }\n                        : null,\n                    msDuration > 0 ? { id: EBMLId.BlockDuration, data: msDuration } : null,\n                ] };\n            this.ebmlWriter.writeEBML(blockGroup);\n        }\n        this.duration = Math.max(this.duration, msTimestamp + msDuration);\n        trackData.lastWrittenMsTimestamp = msTimestamp;\n        if (!this.trackDatasInCurrentCluster.has(trackData)) {\n            this.trackDatasInCurrentCluster.set(trackData, {\n                firstMsTimestamp: msTimestamp,\n            });\n        }\n        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);\n    }\n    /** Creates a new Cluster element to contain media chunks. */\n    createNewCluster(msTimestamp) {\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        if (this.format._options.onCluster) {\n            this.writer.startTrackingWrites();\n        }\n        this.currentCluster = {\n            id: EBMLId.Cluster,\n            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,\n            data: [\n                { id: EBMLId.Timestamp, data: msTimestamp },\n            ],\n        };\n        this.ebmlWriter.writeEBML(this.currentCluster);\n        this.currentClusterStartMsTimestamp = msTimestamp;\n        this.currentClusterMaxMsTimestamp = msTimestamp;\n        this.trackDatasInCurrentCluster.clear();\n    }\n    finalizeCurrentCluster() {\n        assert(this.currentCluster);\n        if (!this.format._options.appendOnly) {\n            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);\n            const endPos = this.writer.getPos();\n            // Write the size now that we know it\n            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);\n            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n            this.writer.seek(endPos);\n        }\n        if (this.format._options.onCluster) {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);\n        }\n        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;\n        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp\n        const groupedByTimestamp = new Map();\n        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster) {\n            if (!groupedByTimestamp.has(firstMsTimestamp)) {\n                groupedByTimestamp.set(firstMsTimestamp, []);\n            }\n            groupedByTimestamp.get(firstMsTimestamp).push(trackData);\n        }\n        const groupedAndSortedByTimestamp = [...groupedByTimestamp.entries()].sort((a, b) => a[0] - b[0]);\n        // Add CuePoints to the Cues element for better seeking\n        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp) {\n            assert(this.cues);\n            this.cues.data.push({ id: EBMLId.CuePoint, data: [\n                    { id: EBMLId.CueTime, data: msTimestamp },\n                    // Create CueTrackPositions for each track that starts at this timestamp\n                    ...trackDatas.map((trackData) => {\n                        return { id: EBMLId.CueTrackPositions, data: [\n                                { id: EBMLId.CueTrack, data: trackData.track.id },\n                                { id: EBMLId.CueClusterPosition, data: clusterOffsetFromSegment },\n                            ] };\n                    }),\n                ] });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleaveChunks();\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        if (!this.segment) {\n            this.createSegment();\n        }\n        // Flush any remaining queued chunks to the file\n        await this.interleaveChunks(true);\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        assert(this.cues);\n        this.ebmlWriter.writeEBML(this.cues);\n        if (!this.format._options.appendOnly) {\n            const endPos = this.writer.getPos();\n            // Write the Segment size\n            const segmentSize = this.writer.getPos() - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);\n            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n            // Write the duration of the media to the Segment\n            this.segmentDuration.data = new EBMLFloat64(this.duration);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));\n            this.ebmlWriter.writeEBML(this.segmentDuration);\n            // Fill in SeekHead position data and write it again\n            assert(this.seekHead);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));\n            this.maybeCreateSeekHead(true);\n            this.ebmlWriter.writeEBML(this.seekHead);\n            this.writer.seek(endPos);\n        }\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}